# A0134177E
###### taskey\src\taskey\logic\Add.java
``` java
 * This class provides the basic resources necessary for subclasses to encapsulate the instructions that the receiver, 
 * LogicMemory, must perform in order to facilitate the adding of tasks. 
 */
abstract class Add extends Command {
	
	protected Task taskToAdd; 
	
	protected Add(Task taskToAdd) {
		this.taskToAdd = taskToAdd;
	}
	
	protected void addTagsToMemory(LogicMemory logicMemory, ArrayList<String> tagList) {
		logicMemory.addTags(tagList);
	}
}
```
###### taskey\src\taskey\logic\AddDeadline.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * adding of deadline tasks. 
 */
final class AddDeadline extends Add {

	AddDeadline(Task taskToAdd) {
		super(taskToAdd);
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.addDeadline(taskToAdd);
		addTagsToMemory(logicMemory, taskToAdd.getTaskTags());
	}
}
```
###### taskey\src\taskey\logic\AddEvent.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * adding of event tasks. 
 */
final class AddEvent extends Add {

	AddEvent(Task taskToAdd) {
		super(taskToAdd);
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.addEvent(taskToAdd);
		addTagsToMemory(logicMemory, taskToAdd.getTaskTags());
	}
}
```
###### taskey\src\taskey\logic\AddFloating.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * adding of floating tasks. 
 */
final class AddFloating extends Add {

	AddFloating(Task taskToAdd) {
		super(taskToAdd);
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.addFloating(taskToAdd);
		addTagsToMemory(logicMemory, taskToAdd.getTaskTags());
	}
}
```
###### taskey\src\taskey\logic\ChangeSaveDirectory.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * changing of the directory where saved task and tag category data is stored.
 */
final class ChangeSaveDirectory extends Command {
	
	String pathName;

	ChangeSaveDirectory(String pathName) {
		this.pathName = pathName;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.changeSaveDirectory(pathName);
	}
}
```
###### taskey\src\taskey\logic\Clear.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * clearing of all Task and TagCategory data <b>in memory. Data present in disk is not affected.</b> Note that the 
 * "clear" command is only used for developer testing and is not available to the user.
 */
final class Clear extends Command {
	
	@Override
	void execute(LogicMemory logicMemory) {
		logicMemory.clearAllTaskLists();
		logicMemory.clearTagCategoryList();
	}
}
```
###### taskey\src\taskey\logic\Command.java
``` java
 * This class is the base class that requires concrete subclasses to implement the execute() method. The actual
 * implementations of the execute() method will vary between subclasses, depending on which user command they are 
 * specific to.
 */
abstract class Command {
	
	abstract void execute(LogicMemory logicMemory) throws LogicException;
}
```
###### taskey\src\taskey\logic\CommandExecutor.java
``` java
 * This class acts as an invoker by executing Commands. It has no knowledge of the specifics of the individual Command
 * objects.
 */
class CommandExecutor {
	
	void execute(Command cmd, LogicMemory logicMemory) throws LogicException {
		cmd.execute(logicMemory);
	}
}
```
###### taskey\src\taskey\logic\DeleteByIndex.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * deleting of indexed tasks. 
 */
final class DeleteByIndex extends Command {
	
	private ContentBox contentBox;
	private int deleteIndex;
	
	DeleteByIndex(ContentBox contentBox, int deleteIndex) {
		this.contentBox = contentBox;
		this.deleteIndex = deleteIndex;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.deleteByIndex(contentBox, deleteIndex);
	}
}
```
###### taskey\src\taskey\logic\DeleteByTagName.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * deleting of indexed tasks. 
 */
final class DeleteByTagName extends Command {
	
	private String tagName;
	
	DeleteByTagName(String tagName) {
		this.tagName = tagName;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.deleteByTagName(tagName);
	}
}
```
###### taskey\src\taskey\logic\DoneByIndex.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * completion of indexed tasks. 
 */
final class DoneByIndex extends Command {
	
	private ContentBox contentBox;
	private int doneIndex;
	
	DoneByIndex(ContentBox contentBox, int doneIndex) {
		this.contentBox = contentBox;
		this.doneIndex = doneIndex;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.doneByIndex(contentBox, doneIndex);
	}
}
```
###### taskey\src\taskey\logic\History.java
``` java
	 * Pushes the given task lists to History.
	 * @param taskLists
	 */
	void addTaskLists(ArrayList<ArrayList<Task>> taskLists) {
		taskStack.push(taskLists);
		redoTaskStack.clear();
	}
	
	/**
	 * Pushes the given tag category list to History.
	 * @param tagCategoryList
	 */
	void addTagCategoryList(ArrayList<TagCategory> tagCategoryList) {
		tagStack.push(tagCategoryList);
		redoTagStack.clear();
	}

	/*=========*
	 * Getters *
	 *=========*/
	/**
	 * Peeks at the last added task lists in History.
	 * @return
	 */
	ArrayList<ArrayList<Task>> peekTaskStack() {
		return taskStack.peek();
	}

	/**
	 * Peeks at the last added tag category list in History.
	 * @return
	 */
	ArrayList<TagCategory> peekTagStack() {
		return tagStack.peek();
	}


	/*==========*
	 * For undo *
	 *==========*/
	/**
	 * Pop the last added task lists from History.
	 * @return 
	 */
	ArrayList<ArrayList<Task>> popTaskStack() {
		ArrayList<ArrayList<Task>> popped = taskStack.pop();
		redoTaskStack.push(popped);
		return popped;
	}

	/**
	 * Pop the last added tag category list from History.
	 * @return 
	 */
	ArrayList<TagCategory> popTagStack() {
		ArrayList<TagCategory> popped = tagStack.pop();
		redoTagStack.push(popped);
		return popped;
	}

	/*==========*
	 * For redo *
	 *==========*/
	/**
```
###### taskey\src\taskey\logic\ListCloner.java
``` java
 * This class provides methods for creating deep copies of ArrayList<Task>, ArrayList<ArrayList<Task>>, and
 * ArrayList<TagCategory> objects.
 */
public class ListCloner {
	
	public static ArrayList<Task> cloneTaskList(ArrayList<Task> taskList) {
		ArrayList<Task> clone = new ArrayList<Task>();
		
		for (Task t : taskList) {
			clone.add(new Task(t));
		}
		
		return clone;
	}
	
	public static ArrayList<ArrayList<Task>> cloneTaskLists(ArrayList<ArrayList<Task>> taskLists) {
		ArrayList<ArrayList<Task>> clone = new ArrayList<ArrayList<Task>>();	
		
		for (int i = 0; i < taskLists.size(); i++) {
			clone.add(cloneTaskList(taskLists.get(i)));
		}
		
		return clone;
	}
	
	public static ArrayList<TagCategory> cloneTagCategoryList(ArrayList<TagCategory> tagCategoryList) {
		ArrayList<TagCategory> clone = new ArrayList<TagCategory>();
		
		for (TagCategory tc : tagCategoryList) {
			clone.add(new TagCategory(tc));
		}
		
		return clone;
	}
}
```
###### taskey\src\taskey\logic\Logic.java
``` java
 * The Logic class provides a simplified interface to the Logic component and hides the more complex aspects, 
 * such as memory management and the internal details of the execution of each specific command. As a result, from the 
 * perspective of UI, all UI needs to do is call the executeCommand() method of Logic whenever the user enters a 
 * command.
 */
public class Logic {
	
    //================================================================================
    // Fields
    //================================================================================
	
	private Parser parser;
	private History history;
	private CommandExecutor cmdExecutor;
	private LogicMemory logicMemory;
	private AutoComplete autoComplete;
	
    //================================================================================
    // Constructors
    //================================================================================
	
	public Logic() {
		parser = new Parser();
		history = new History();
		cmdExecutor = new CommandExecutor();
		logicMemory = new LogicMemory();
		autoComplete = new AutoComplete();
		updateHistory();
		TaskeyLog.getInstance().log(LogSystems.LOGIC, "Successfully initialized Logic.", Level.ALL);
	}
	
```
###### taskey\src\taskey\logic\Logic.java
``` java
    //================================================================================
    // Accessors
    //================================================================================
	
	/**
	 * Returns a (sorted) deep copy of all task lists.
	 */
	public ArrayList<ArrayList<Task>> getAllTaskLists() {
		return ListCloner.cloneTaskLists(logicMemory.getTaskLists());
	}
	
	/**
	 * Returns a (sorted) deep copy of the current tag category list.
	 */
	public ArrayList<TagCategory> getTagCategoryList() {
		return ListCloner.cloneTagCategoryList(logicMemory.getTagCategoryList());
	}
	
    //================================================================================
    // Interface Methods
    //================================================================================
	
	/**
	 * Executes the user supplied command.
	 *
	 * @param currentContent specifies the current tab that user is in.
	 * @param input			 the input String entered by the user
	 * @return               an object encapsulating the information required to update UI display
	 */
	public LogicFeedback executeCommand(ContentBox currentContent, String input) {
    	ProcessedObject po = parser.parseInput(input);
    	String command = po.getCommand();
    	Command cmd;
  
    	switch (command) {
			case "ADD_FLOATING":
				cmd = new AddFloating(po.getTask());
				return executeAdd(po, cmd);
				
			case "ADD_DEADLINE":
				cmd = new AddDeadline(po.getTask());
				return executeAdd(po, cmd);

			case "ADD_EVENT":
				cmd = new AddEvent(po.getTask());
				return executeAdd(po, cmd);
				
			case "CHANGE_FILE_LOC":
				cmd = new ChangeSaveDirectory(po.getNewFileLoc());
				return executeChangeSaveDirectory(po, cmd);
				
			case "CLEAR":
	    		cmd = new Clear();
				return executeClear(po, cmd);
				
			case "DELETE_BY_CATEGORY":
				cmd = new DeleteByTagName(po.getCategory());
				return executeDelete(po, cmd);

			case "DELETE_BY_INDEX":
				cmd = new DeleteByIndex(currentContent, po.getIndex());
				return executeDelete(po, cmd);
			
			case "DONE_BY_INDEX":
				cmd = new DoneByIndex(currentContent, po.getIndex());
				return executeDone(po, cmd);	
				
			case "ERROR":
				return new LogicFeedback(getAllTaskLists(), po, new LogicException(po.getErrorType()));
				
			case "SAVE":
	    		cmd = new Save();
				return executeSave(po, cmd);
				
			case "SEARCH":
				cmd = new Search(po.getSearchPhrase());
				return executeSearch(po, cmd);
				
			case "UNDO":
				return executeUndo(po);
				
			case "UPDATE_BY_INDEX_CHANGE_BOTH":
				cmd = new UpdateByIndexChangeBoth(currentContent, po.getIndex(), po.getNewTaskName(), po.getTask());
				return executeUpdate(po, cmd);
				
			case "UPDATE_BY_INDEX_CHANGE_DATE":
				cmd = new UpdateByIndexChangeDate(currentContent, po.getIndex(), po.getTask());
				return executeUpdate(po, cmd);
				
			case "UPDATE_BY_INDEX_CHANGE_NAME":
				cmd = new UpdateByIndexChangeName(currentContent, po.getIndex(), po.getNewTaskName());
				return executeUpdate(po, cmd);		
				
			case "UPDATE_BY_INDEX_CHANGE_PRIORITY":
				cmd = new UpdateByIndexChangePriority(currentContent, po.getIndex(), po.getNewPriority());
				return executeUpdate(po, cmd);

			case "VIEW_BASIC":
				cmd = new ViewBasic(po.getViewType().get(0));
				return executeView(po, cmd);
			
			case "VIEW_TAGS":
				cmd = new ViewTags(po.getViewType());
				return executeView(po, cmd);

			default:
				return new LogicFeedback(getAllTaskLists(), po, 
						                 new LogicException(LogicException.MSG_ERROR_INVALID_COMMAND));
		}
	}
	
    //================================================================================
    // Command Methods
    //================================================================================
	
	private LogicFeedback executeAdd(ProcessedObject po, Command cmd) {
		try {
			cmdExecutor.execute(cmd, logicMemory);
		} catch (LogicException le) {
			if (le.getMessage().equals(LogicException.MSG_SUCCESS_ADD_EXPIRED)) {
				updateHistory();
			}
			return new LogicFeedback(getAllTaskLists(), po, le);
		}
		updateHistory();
		return new LogicFeedback(getAllTaskLists(), po, new LogicException(LogicException.MSG_SUCCESS_ADD));
	}
	
	private LogicFeedback executeChangeSaveDirectory(ProcessedObject po, Command cmd) {
		try {
			cmdExecutor.execute(cmd, logicMemory);
		} catch (LogicException le) {
			if (le.getMessage().equals(LogicException.MSG_SUCCESS_SETDIR_LOAD)) {
				history.clear();
				updateHistory();
			}
			return new LogicFeedback(getAllTaskLists(), po, le);
		}
		return new LogicFeedback(getAllTaskLists(), po, new LogicException(LogicException.MSG_SUCCESS_SETDIR));
	}
	
	private LogicFeedback executeClear(ProcessedObject po, Command cmd) {
		try {
			cmdExecutor.execute(cmd, logicMemory);
		} catch (LogicException le) {
			return new LogicFeedback(getAllTaskLists(), po, le);
		}
		updateHistory();
		return new LogicFeedback(getAllTaskLists(), po, new LogicException(LogicException.MSG_SUCCESS_CLEAR));
	}
	
	private LogicFeedback executeDelete(ProcessedObject po, Command cmd) {
		try {
			cmdExecutor.execute(cmd, logicMemory);
		} catch (LogicException le) {
			return new LogicFeedback(getAllTaskLists(), po, le);
		}
		updateHistory();
		return new LogicFeedback(getAllTaskLists(), po, new LogicException(LogicException.MSG_SUCCESS_DELETE));
	}
	
	private LogicFeedback executeDone(ProcessedObject po, Command cmd) {
		try {
			cmdExecutor.execute(cmd, logicMemory);
		} catch (LogicException le) {
			return new LogicFeedback(getAllTaskLists(), po, le);
		}
		updateHistory();
		return new LogicFeedback(getAllTaskLists(), po, new LogicException(LogicException.MSG_SUCCESS_DONE));
	}
	
	private LogicFeedback executeSave(ProcessedObject po, Command cmd) {
		try {
			cmdExecutor.execute(cmd, logicMemory);
		} catch (LogicException le) {
			return new LogicFeedback(getAllTaskLists(), po, le);
		}
		return new LogicFeedback(getAllTaskLists(), po, new LogicException(LogicException.MSG_SUCCESS_SAVE));
	}
	
	private LogicFeedback executeSearch(ProcessedObject po, Command cmd) {
		return executeView(po, cmd);
	}
	
	private LogicFeedback executeUndo(ProcessedObject po) {
		// History stacks must always have at least one item, which is inserted at startup
		assert(!history.taskStackIsEmpty());
		assert(!history.tagStackIsEmpty()); 
		ArrayList<ArrayList<Task>> currentTaskLists = history.popTaskStack();
		ArrayList<ArrayList<Task>> previousTaskLists = history.peekTaskStack();
		ArrayList<TagCategory> currentTagCategoryList = history.popTagStack();
		ArrayList<TagCategory> previousTagCategoryList = history.peekTagStack();
		
		if (previousTaskLists == null) {
			history.addTaskLists(currentTaskLists);
			history.addTagCategoryList(currentTagCategoryList);
			return new LogicFeedback(getAllTaskLists(), po, new LogicException(LogicException.MSG_ERROR_UNDO));
		}
		
		logicMemory.setTaskLists(ListCloner.cloneTaskLists(previousTaskLists));
		logicMemory.setTagCategoryList(ListCloner.cloneTagCategoryList(previousTagCategoryList));
		
		return new LogicFeedback(getAllTaskLists(), po, new LogicException(LogicException.MSG_SUCCESS_UNDO));
	}
	
	private LogicFeedback executeUpdate(ProcessedObject po, Command cmd) {
		try {
			cmdExecutor.execute(cmd, logicMemory);
		} catch (LogicException le) {
			if (le.getMessage().equals(LogicException.MSG_SUCCESS_UPDATE_EXPIRED)) {
				updateHistory();
			}
			return new LogicFeedback(getAllTaskLists(), po, le);
		}
		updateHistory();
		return new LogicFeedback(getAllTaskLists(), po, new LogicException(LogicException.MSG_SUCCESS_UPDATE));
	}
	
	private LogicFeedback executeView(ProcessedObject po, Command cmd) {
		try {
			cmdExecutor.execute(cmd, logicMemory);
		} catch (LogicException le) {
			return new LogicFeedback(getAllTaskLists(), po, le);
		}
		return new LogicFeedback(getAllTaskLists(), po, null);
	}
	
    //================================================================================
    // Miscellaneous
    //================================================================================
	
	// Push the latest task lists and tag category list to history.
	private void updateHistory() {
		history.addTaskLists(getAllTaskLists());
		history.addTagCategoryList(getTagCategoryList());
	}
	
	public ArrayList<String> autoCompleteLine(String line, ContentBox currentContent) {
		ProcessedAC pac = autoComplete.getSuggestions(line, getTagCategoryList());
		String pacCommand = pac.getCommand();
		
		if (pacCommand.equals(DISPLAY_COMMAND)) { // to complete a command
			ArrayList<String> suggestions = pac.getAvailCommands(); 
			return suggestions;
		} else if (pacCommand.equals(FINISHED_COMMAND)) {
			return new ArrayList<String>();
		} else { // Command not recognized
			return null;  
		}
	}
}
```
###### taskey\src\taskey\logic\LogicException.java
``` java
 * Whenever the Logic component encounters an error in command execution, or wishes to pass a message to UI, it
 * encapsulates the message in an instance of this class. This class is made public to facilitate testing, but components 
 * other than Logic should not have any reason to create objects of this class.
 */
@SuppressWarnings("serial")
public class LogicException extends Exception {
	
    //================================================================================
    // Constants
    //================================================================================
	
	public static final String MSG_SUCCESS_ADD = "Successfully added task.";
	public static final String MSG_SUCCESS_DELETE = "Successfully deleted task(s).";
	public static final String MSG_SUCCESS_DONE = "Task moved to archive.";
	public static final String MSG_SUCCESS_UPDATE = "Successfully updated task.";
	public static final String MSG_SUCCESS_CLEAR = "Successfully cleared memory.";
	public static final String MSG_SUCCESS_SAVE = "Save successful.";
	public static final String MSG_SUCCESS_SETDIR = "Successfully changed save directory.";
	public static final String MSG_SUCCESS_SETDIR_LOAD = "Successfully loaded from new directory.";
	public static final String MSG_SUCCESS_VIEW = "Viewing \"%1$s\"";
	public static final String MSG_SUCCESS_VIEW_TODAY = "Viewing today's tasks.";
	public static final String MSG_SUCCESS_VIEW_TOMORROW = "Viewing tomorrow's tasks.";
	public static final String MSG_SUCCESS_VIEW_PRIORITY = "Viewing tasks with \"%1$s\" priority.";
	public static final String MSG_SUCCESS_VIEW_TAGS = "Viewing tag(s).";
	public static final String MSG_SUCCESS_SEARCH = "Searching \"%1$s\".";
	public static final String MSG_SUCCESS_ADD_EXPIRED = "Added task to expired tab.";
	public static final String MSG_SUCCESS_UPDATE_EXPIRED = "Moved task to expired tab.";
	public static final String MSG_SUCCESS_UNDO = "Undo successful.";
	public static final String MSG_ERROR_INVALID_COMMAND = "Invalid command!";
	public static final String MSG_ERROR_DUPLICATE_TASKS = "Duplicate tasks are not allowed.";	                                             
	public static final String MSG_ERROR_INVALID_INDEX = "Invalid index specified!";
	public static final String MSG_ERROR_DONE_INVALID = "This task is already archived!";
	public static final String MSG_ERROR_UPDATE_INVALID = "Cannot update archived tasks!";
	public static final String MSG_ERROR_UNDO = "Nothing to undo!";
	public static final String MSG_ERROR_TAG_NOT_FOUND = "Cannot delete a tag that does not exist!";
	public static final String MSG_ERROR_PRIORITY_NOT_FOUND = "There are no pending/expired tasks with that priority level.";
	public static final String MSG_ERROR_SAVE = "Error occurred during save.";
	public static final String MSG_ERROR_SETDIR = "Error changing save directory!";
	public static final String MSG_ERROR_VIEWTYPE = "Error: \"%1$s\" is not a valid category";
	
    //================================================================================
    // Constructor
    //================================================================================

	public LogicException(String message) {
		super(message);
	}
	
    //================================================================================
    // Overriding Methods
    //================================================================================
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((getMessage() == null) ? 0 : getMessage().hashCode());
		
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		
		if (obj == null) {
			return false;
		}
		
		if (getClass() != obj.getClass()) {
			return false;
		}
		
		LogicException other = (LogicException) obj;
		
		if (getMessage() == null) {
			if (other.getMessage() != null) {
				return false;
			}
		} else if (!getMessage().equals(other.getMessage())) {
			return false;
		}
		
		return true;
	}
}
```
###### taskey\src\taskey\logic\LogicFeedback.java
``` java
 * This class is the default feedback mechanism from Logic to UI.
 * Objects of this class encapsulate ArrayLists of Task objects for updating the UI display,
 * a ProcessedObject which by itself encapsulates information on the executed command and its associated
 * task, and an Exception reflecting the outcome of command execution.
 */
public class LogicFeedback {
	private ArrayList<ArrayList<Task>> taskLists;
	private ProcessedObject po;
	private LogicException le;
	
	/** This is the only constructor for the LogicFeedback class. taskLists and po should not be null.
	 * 
	 * @param taskLists  a list of task lists for the purposes of updating the UI display
	 * @param po         an object encapsulating information on the executed command and its associated task
	 * @param le         an exception containing a message to reflect the outcome of command execution. It can be null.
	 */
	LogicFeedback(ArrayList<ArrayList<Task>> taskLists, ProcessedObject po, LogicException le) {
		assert (taskLists != null);
		assert (taskLists.size() == 8); //taskLists should be fully initialized
		assert (!taskLists.contains(null)); //All lists should be instantiated
		assert (po != null);
		
		this.taskLists = taskLists;
		this.po = po;
		this.le = le;
	}

	public ArrayList<ArrayList<Task>> getTaskLists() {
		return taskLists;
	}

	void setTaskLists(ArrayList<ArrayList<Task>> taskLists) {
		assert (taskLists != null);
		this.taskLists = taskLists;
	}

	public ProcessedObject getPo() {
		return po;
	}

	void setPo(ProcessedObject po) {
		assert (po != null);
		this.po = po;
	}

	public LogicException getException() {
		return le;
	}
	
	void setException(LogicException le) {
		this.le = le;
	}
}
```
###### taskey\src\taskey\logic\LogicMemory.java
``` java
 * This class serves as the memory component for the Logic class. It holds references to all the Task and TagCategory
 * objects in use for the session. Each time a command is executed, the data in this component will be modified. 
 * Note that the data in this component will not be saved to disk unless the user enters the "save" command.  
 */
public class LogicMemory {
	
    //================================================================================
    // Constants
    //================================================================================
	
	public static final int NUM_TASK_LISTS = 8;
	public static final int NUM_SECONDS_1_DAY = 86400;
	
	// Indices of each list
	public static final int INDEX_THIS_WEEK = 0;
	public static final int INDEX_PENDING = 1;
	public static final int INDEX_EXPIRED = 2;
	public static final int INDEX_FLOATING = 3;
	public static final int INDEX_DEADLINE = 4;
	public static final int INDEX_EVENT = 5;
	public static final int INDEX_COMPLETED = 6;
	public static final int INDEX_ACTION = 7;
	
    //================================================================================
    // Fields
    //================================================================================
	
	private Storage storage;
	private ArrayList<ArrayList<Task>> taskLists;
	private ArrayList<TagCategory> tagCategoryList;
	
    //================================================================================
    // Constructors
    //================================================================================
	
	LogicMemory() {
		TaskeyLog.getInstance().removeHandlers(LogSystems.LOGIC);
		TaskeyLog.getInstance().addHandler(LogSystems.LOGIC, "LogicLog.txt", 1);
		storage = new Storage();
		initializeTaskLists();
		TaskeyLog.getInstance().log(LogSystems.LOGIC, "Successfully initialized task lists in LogicMemory.", Level.ALL);
		initializeTagCategoryList();
		TaskeyLog.getInstance().log(LogSystems.LOGIC, "Successfully initialized tag list in LogicMemory.", Level.ALL);
	}
	
    //================================================================================
    // Accessors
    //================================================================================

	ArrayList<ArrayList<Task>> getTaskLists() {
		assert(taskLists != null);
		assert(!taskLists.contains(null));
		assert(taskLists.size() == NUM_TASK_LISTS);
		sortTaskLists();
		return taskLists;
	}

	void setTaskLists(ArrayList<ArrayList<Task>> taskLists) {
		assert(taskLists != null);
		assert(!taskLists.contains(null));
		assert(taskLists.size() == NUM_TASK_LISTS);
		this.taskLists = taskLists;
	}

	ArrayList<TagCategory> getTagCategoryList() {
		assert(tagCategoryList != null);
		assert(!tagCategoryList.contains(null));
		sortTagCategoryList();
		return tagCategoryList;
	}

	void setTagCategoryList(ArrayList<TagCategory> tagCategoryList) {
		assert(tagCategoryList != null);
		assert(!tagCategoryList.contains(null));
		this.tagCategoryList = tagCategoryList;
	}
	
    //================================================================================
    // Command Methods
    //================================================================================
	
	/**
	 * Adds a floating task to the task lists.
	 * @param taskToAdd
	 * @throws LogicException if the task to add is a duplicate
	 */
	void addFloating(Task taskToAdd) throws LogicException {
		if (taskAlreadyExists(taskToAdd)) {
			throw new LogicException(LogicException.MSG_ERROR_DUPLICATE_TASKS);
		}
		
		taskLists.get(INDEX_PENDING).add(taskToAdd);
		taskLists.get(INDEX_FLOATING).add(taskToAdd);
		clearActionList(); // Action list not relevant for "add" command.
	}
	
	/**
	 * Adds a deadline task to the task lists.
	 * @param taskToAdd
	 * @throws LogicException if the task to add is a duplicate, or is already expired
	 */
	void addDeadline(Task taskToAdd) throws LogicException {
		if (taskAlreadyExists(taskToAdd)) {
			throw new LogicException(LogicException.MSG_ERROR_DUPLICATE_TASKS);
		}
		
		clearActionList(); // Action list not relevant for "add" command.
		
		if (taskToAdd.isExpired()) {
			taskLists.get(INDEX_EXPIRED).add(taskToAdd);
			addTags(taskToAdd.getTaskTags());
			throw new LogicException(LogicException.MSG_SUCCESS_ADD_EXPIRED);
		}
		
		taskLists.get(INDEX_PENDING).add(taskToAdd);
		taskLists.get(INDEX_DEADLINE).add(taskToAdd);
	
		if (taskToAdd.isThisWeek()) {
			taskLists.get(INDEX_THIS_WEEK).add(taskToAdd);
		}
	}
	
	/**
	 * Adds an event task to the task lists.
	 * @param taskToAdd
	 * @throws LogicException if the task to add is a duplicate, or is already expired
	 */
	void addEvent(Task taskToAdd) throws LogicException {
		if (taskAlreadyExists(taskToAdd)) {
			throw new LogicException(LogicException.MSG_ERROR_DUPLICATE_TASKS);
		}
		
		clearActionList(); // Action list not relevant for "add" command.
		
		if (taskToAdd.isExpired()) {
			taskLists.get(INDEX_EXPIRED).add(taskToAdd);
			addTags(taskToAdd.getTaskTags());
			throw new LogicException(LogicException.MSG_SUCCESS_ADD_EXPIRED);
		}
		
		taskLists.get(INDEX_PENDING).add(taskToAdd);
		taskLists.get(INDEX_EVENT).add(taskToAdd);

		if (taskToAdd.isThisWeek()) {
			taskLists.get(INDEX_THIS_WEEK).add(taskToAdd);
		}
	}
	
	/**
	 * Change the directory where task and tag category data are saved. If this method succeeds, all saved files are 
	 * moved from the current save directory to the new directory.
	 * @param pathName        the new directory pathname
```
###### taskey\src\taskey\logic\LogicMemory.java
``` java
	 * Removes an indexed task from the specified task list, and deletes all its tags from the tag category list.
	 * @param contentBox specifies the current tab that user is in
	 * @param taskIndex  the index of task to be deleted
	 * @return           the Task that was deleted
	 * @throws LogicException if the index is invalid
	 */
	Task deleteByIndex(ContentBox contentBox, int taskIndex) throws LogicException {
		ArrayList<Task> targetList = taskLists.get(getListIndex(contentBox));
		
		if (taskIndex >= targetList.size() || taskIndex < 0) {
			throw new LogicException(LogicException.MSG_ERROR_INVALID_INDEX);
		}
		
		Task toDelete = targetList.get(taskIndex);

		if (!taskLists.get(INDEX_COMPLETED).contains(toDelete)) { // Completed tasks already have their tags removed.
			removeTaskTags(toDelete.getTaskTags());
		}
		
		removeFromAllLists(toDelete);
		
		if (!contentBox.equals(ContentBox.ACTION)) { // User not in ACTION tab, clear it to remove clutter
			clearActionList();
		}
		
		return toDelete;
	}
	
	/**
	 * Deletes all tasks with the given tag name from the expired and pending lists, and updates the tag category list 
	 * accordingly.
	 * @param tagName
	 * @throws LogicException if the tag name was not found in the expired and pending lists
	 */
	void deleteByTagName(String tagName) throws LogicException {
		boolean tagFound = removeTaggedTasks(taskLists.get(INDEX_EXPIRED), tagName);
		tagFound = tagFound || removeTaggedTasks(taskLists.get(INDEX_PENDING), tagName);
		
		if (!tagFound) {
			throw new LogicException(LogicException.MSG_ERROR_TAG_NOT_FOUND);
		}
		
		clearActionList();
	}
	
	/**
	 * Marks an indexed task from the specified task list as done, and deletes all its tags from the tag category list.
	 * @param contentBox specifies the current tab that user is in
	 * @param taskIndex  the index of task to be completed
	 * @throws LogicException if index is invalid or the user is trying to mark an archived task as done
	 */
	void doneByIndex(ContentBox contentBox, int taskIndex) throws LogicException {
		ArrayList<Task> targetList = taskLists.get(getListIndex(contentBox));
		
		if (taskIndex >= targetList.size() || taskIndex < 0) {
			throw new LogicException(LogicException.MSG_ERROR_INVALID_INDEX);
		}
		
		Task toComplete = targetList.get(taskIndex);
		
		if (taskLists.get(INDEX_COMPLETED).contains(toComplete)) {
			throw new LogicException(LogicException.MSG_ERROR_DONE_INVALID);
		}
		
		removeFromAllLists(toComplete);
		taskLists.get(INDEX_COMPLETED).add(toComplete);
		removeTaskTags(toComplete.getTaskTags());
		
		if (!contentBox.equals(ContentBox.ACTION)) { // User not in ACTION tab, clear it to remove clutter
			clearActionList();
		}
	}
	
	/**
	 * Updates an indexed task from the specified task list, and also updates all lists that contained the updated task.
	 * @param contentBox specifies the current tab that user is in
	 * @param taskIndex  the index of task to be updated
	 * @param newName    the new name to update the task to
	 * @param newTask    the task with the new date
	 * @throws LogicException if the index is invalid, or the updated task is a duplicate or expired
	 */
	void updateByIndexChangeBoth(ContentBox contentBox, int taskIndex, String newName, Task newTask) throws LogicException {
		ArrayList<Task> targetList = taskLists.get(getListIndex(contentBox));
		
		if (taskIndex >= targetList.size() || taskIndex < 0) {
			throw new LogicException(LogicException.MSG_ERROR_INVALID_INDEX);
		}
		
		Task toUpdate = targetList.get(taskIndex);
		
		if (taskLists.get(INDEX_COMPLETED).contains(toUpdate)) {
			throw new LogicException(LogicException.MSG_ERROR_UPDATE_INVALID);
		}
		
		newTask.setTaskName(newName);
		if (toUpdate.getTaskTags() != null) {
			newTask.setTaskTags(new ArrayList<String>(toUpdate.getTaskTags()));
		}
		
		if (taskAlreadyExists(newTask)) {
			throw new LogicException(LogicException.MSG_ERROR_DUPLICATE_TASKS);
		}
		
		removeFromAllLists(toUpdate);
		addTaskToLists(contentBox, newTask);
		
		if (!contentBox.equals(ContentBox.ACTION)) { // User not in ACTION tab, clear it to remove clutter
			clearActionList();
		}
		
		if (newTask.isExpired()) {
			throw new LogicException(LogicException.MSG_SUCCESS_UPDATE_EXPIRED);
		}
	}
	
	/**
	 * Updates an indexed task from the specified task list, and also updates all lists that contained the updated task.
	 * @param contentBox specifies the current tab that user is in
	 * @param taskIndex  the index of task to be updated
	 * @param newTask    the task with the new date
	 * @throws LogicException if the index is invalid, or the updated task is a duplicate or expired
	 */
	void updateByIndexChangeDate(ContentBox contentBox, int taskIndex, Task newTask) throws LogicException {
		ArrayList<Task> targetList = taskLists.get(getListIndex(contentBox));
		
		if (taskIndex >= targetList.size() || taskIndex < 0) {
			throw new LogicException(LogicException.MSG_ERROR_INVALID_INDEX);
		}
		
		Task toUpdate = targetList.get(taskIndex);
		updateByIndexChangeBoth(contentBox, taskIndex, toUpdate.getTaskName(), newTask);
	}
	
	/**
	 * Updates an indexed task from the specified task list, and also updates all lists that contained the updated task.
	 * @param contentBox specifies the current tab that user is in
	 * @param taskIndex  the index of task to be updated
	 * @param newName    the new name to update the task to
	 * @throws LogicException if the index is invalid, or the updated task is a duplicate or expired
	 */
	void updateByIndexChangeName(ContentBox contentBox, int taskIndex, String newName) throws LogicException {
		ArrayList<Task> targetList = taskLists.get(getListIndex(contentBox));
		
		if (taskIndex >= targetList.size() || taskIndex < 0) {
			throw new LogicException(LogicException.MSG_ERROR_INVALID_INDEX);
		}
		
		Task toUpdate = targetList.get(taskIndex);
		Task toUpdateCopy = new Task(toUpdate);
		updateByIndexChangeBoth(contentBox, taskIndex, newName, toUpdateCopy);
	}
	
	void updateByIndexChangePriority(ContentBox contentBox, int taskIndex, int newPriority) throws LogicException {
		ArrayList<Task> targetList = taskLists.get(getListIndex(contentBox));
		
		if (taskIndex >= targetList.size() || taskIndex < 0) {
			throw new LogicException(LogicException.MSG_ERROR_INVALID_INDEX);
		}
		
		Task toUpdate = targetList.get(taskIndex);
		
		if (taskLists.get(INDEX_COMPLETED).contains(toUpdate)) {
			throw new LogicException(LogicException.MSG_ERROR_UPDATE_INVALID);
		}
		
		removeFromAllLists(toUpdate);
		toUpdate.setPriority(newPriority);
		addTaskToLists(contentBox, toUpdate);
		
		if (!contentBox.equals(ContentBox.ACTION)) { // User not in ACTION tab, clear it to remove clutter
			clearActionList();
		}
	}
	
	/**
	 * Saves the current task lists and tag category list in memory to disk.
	 * @throws LogicException if error occurred during save
	 */
	void save() throws LogicException {
		try {
			storage.saveAllTasklists(ListCloner.cloneTaskLists(taskLists));
			storage.saveTaglist(ListCloner.cloneTagCategoryList(tagCategoryList));
		} catch (Exception e) {
			throw new LogicException(LogicException.MSG_ERROR_SAVE);
		}
	}
	
	/**
	 * Search for all expired and pending tasks via the given search phrase (not case sensitive).
	 * @param searchPhrase
	 * @throws LogicException if no matches were found
	 */
	void search(String searchPhrase) throws LogicException {
		ArrayList<Task> actionList = taskLists.get(INDEX_ACTION);
		clearActionList();
		//actionList.addAll(getSearchResults(taskLists.get(INDEX_EXPIRED), searchPhrase));
		actionList.addAll(getSearchResults(taskLists.get(INDEX_PENDING), searchPhrase));
		String exceptionMsg = String.format(LogicException.MSG_SUCCESS_SEARCH, searchPhrase);
		throw new LogicException(exceptionMsg);
	}
	
	/**
	 * Updates the action list based on the view type. When the user wants to view tasks by priority i.e. "high", "medium"
	 * or "low", only expired and pending tasks will be displayed.
	 * @param viewType
	 * @throws LogicException 
	 */
	void viewBasic(String viewType) throws LogicException {
		String exceptionMsg;
		
		switch (viewType) {
			case "general":
				taskLists.set(INDEX_ACTION, new ArrayList<Task>(taskLists.get(INDEX_FLOATING)));
				exceptionMsg = String.format(LogicException.MSG_SUCCESS_VIEW, viewType) + " tasks.";
				throw new LogicException(exceptionMsg);
			
			case "deadlines":
				taskLists.set(INDEX_ACTION, new ArrayList<Task>(taskLists.get(INDEX_DEADLINE)));
				break;
				
			case "events":
				taskLists.set(INDEX_ACTION, new ArrayList<Task>(taskLists.get(INDEX_EVENT)));
				break;
				
			case "archive":
				taskLists.set(INDEX_ACTION, new ArrayList<Task>(taskLists.get(INDEX_COMPLETED)));
				break;
				
			case "high":
			case "medium":
			case "low":
				clearActionList();
				// viewPriority(taskLists.get(INDEX_EXPIRED), viewType);
				viewPriority(taskLists.get(INDEX_PENDING), viewType);
				exceptionMsg = String.format(LogicException.MSG_SUCCESS_VIEW_PRIORITY, viewType);
				throw new LogicException(exceptionMsg);
							
			case "help": // Display of help will be handled by UI. UI should disallow any commands while in help mode.
				clearActionList();
				break;
			
			case "today":
				clearActionList();
				viewToday(taskLists.get(INDEX_PENDING));
				throw new LogicException(LogicException.MSG_SUCCESS_VIEW_TODAY);
			
			case "tomorrow":
				clearActionList();
				viewTomorrow(taskLists.get(INDEX_PENDING));
				throw new LogicException(LogicException.MSG_SUCCESS_VIEW_TOMORROW);
			
			default: // Should not reach this point
				exceptionMsg = String.format(LogicException.MSG_ERROR_VIEWTYPE, viewType);
				throw new LogicException(exceptionMsg);
		}
		
		exceptionMsg = String.format(LogicException.MSG_SUCCESS_VIEW, viewType) + ".";
		throw new LogicException(exceptionMsg);
	}

	/**
	 * Updates the action list with all the expired and pending tasks that contain at least one of the tag categories 
	 * that the user wants to view.
	 * @param tagNames
	 * @throws LogicException if the tag categories do not exist
	 */
	void viewTags(ArrayList<String> tagNames) throws LogicException {
		clearActionList();
		//boolean tagFound = viewTaggedTasks(taskLists.get(INDEX_EXPIRED), tagNames);
		boolean tagFound = viewTaggedTasks(taskLists.get(INDEX_PENDING), tagNames);
		
		throw new LogicException(LogicException.MSG_SUCCESS_VIEW_TAGS);
	}
	
    //================================================================================
    // Miscellaneous
    //================================================================================
	
	private void initializeTaskLists() {
		taskLists = storage.loadAllTasklists();
		assert(taskLists != null);
		
		// THIS_WEEK and ACTION lists are not loaded from storage and hence must be manually added.
		taskLists.add(INDEX_THIS_WEEK, new ArrayList<Task>());
		taskLists.add(INDEX_ACTION, new ArrayList<Task>());
		assert(taskLists.size() == NUM_TASK_LISTS);
		
		synchroniseTaskLists();
	}
	
	private void initializeTagCategoryList() {
		tagCategoryList = storage.loadTaglist();
	}
	
	/** Updates all the lists based on the current time on the user's computer clock. For example, deadline tasks that
	 *  are newly expired will be removed from the DEADLINE list and PENDING lists and added to the EXPIRED list. The 
	 *  tag category list is not affected.
	 */
	private void synchroniseTaskLists() {
		ArrayList<Task> thisWeekList = taskLists.get(INDEX_THIS_WEEK);
		ArrayList<Task> expiredList = taskLists.get(INDEX_EXPIRED);
		ArrayList<Task> pendingList = taskLists.get(INDEX_PENDING);

		for (Iterator<Task> it = pendingList.iterator(); it.hasNext();) { // Iterator is used for safe removal of
			                                                              // elements while iterating
			Task task = it.next();
			
			if (task.isExpired()) {
				it.remove();
				removeFromAllLists(task);
				expiredList.add(task);
			} else if (task.isThisWeek()) {
				thisWeekList.add(task);
			}
		}
	}
	
	void clearAllTaskLists() {
		for (int i = 0; i < taskLists.size(); i++) {
			taskLists.get(i).clear();
		}
	}
	
	private void clearActionList() {
		taskLists.get(INDEX_ACTION).clear();
	}
	
	void clearTagCategoryList() {
		tagCategoryList.clear();
	}
	
	private void sortTaskLists() {
		for (ArrayList<Task> list : taskLists) {
			Collections.sort(list, Collections.reverseOrder()); // Sort in reverse order because compareTo logic in
			                                                    // Task.java is reversed
		}
	}
	
	private void sortTagCategoryList() {
		Collections.sort(tagCategoryList); 
	}
	
	/** 
	 * Returns the index of the list corresponding to the current tab user is in.
	 * @param currentContent the current tab user is in
	 * @return
	 */
	private int getListIndex(ContentBox currentContent) {
		switch (currentContent) {
			case THIS_WEEK:
				return INDEX_THIS_WEEK;
			
			case PENDING:
				return INDEX_PENDING;
			
			case EXPIRED:
				return INDEX_EXPIRED;
				
			case ACTION:
				return INDEX_ACTION;
			
			default:
				return -1; // Stub
		}
	}
	
	/** 
	 * Adds the new Task to all the lists it should belong to, depending on the current tab the user is in.
	 * @param contentBox the current tab user is in
	 * @param newTask
	 */
	private void addTaskToLists(ContentBox contentBox, Task newTask) {
		for (int i = 0; i < taskLists.size(); i++) {
			if (belongsToList(contentBox, i, newTask)) {
				taskLists.get(i).add(newTask);
			}
		}
	}
	
	/** 
	 * Returns true if and only if the new Task belongs to the list specified by listIndex, depending on the current
	 * tab the user is in 
	 * @param contentBox the current tab user is in
	 * @param listIndex
	 * @param newTask
	 * @return
	 */
	private boolean belongsToList(ContentBox contentBox, int listIndex, Task newTask) {
		String taskType = newTask.getTaskType();
		boolean isExpired = newTask.isExpired();

		if (listIndex == INDEX_THIS_WEEK) {
			return (!isExpired && newTask.isThisWeek());
		} else if (listIndex == INDEX_PENDING) {
			return !isExpired;
		} else if (listIndex == INDEX_EXPIRED) {
			return isExpired;
		} else if (listIndex == INDEX_FLOATING) {
			return (taskType.equals("FLOATING"));
		} else if (listIndex == INDEX_DEADLINE) {
			return (!isExpired && taskType.equals("DEADLINE"));
		} else if (listIndex == INDEX_EVENT) {
			return (!isExpired && taskType.equals("EVENT"));
		} else if (listIndex == INDEX_ACTION) {
			return (!isExpired && contentBox.equals(ContentBox.ACTION));
		} else {
			return false;
		}
	}
	
	private void removeFromAllLists(Task toRemove) {
		taskLists.get(INDEX_THIS_WEEK).remove(toRemove);
		taskLists.get(INDEX_PENDING).remove(toRemove);
		taskLists.get(INDEX_EXPIRED).remove(toRemove);
		taskLists.get(INDEX_FLOATING).remove(toRemove);
		taskLists.get(INDEX_DEADLINE).remove(toRemove);
		taskLists.get(INDEX_EVENT).remove(toRemove);
		taskLists.get(INDEX_COMPLETED).remove(toRemove);
		taskLists.get(INDEX_ACTION).remove(toRemove);
	}
	
	/** 
	 * Removes all tasks from the given list which contain a tag with the given name. The tasks will be removed from
	 * other lists that contain them as well. For each task that is removed, the tag category list will be updated 
	 * accordingly.
	 * 
	 * @param list
	 * @param tagName
	 * @return true if and only if at least one task was removed from the given list
	 */
	private boolean removeTaggedTasks(ArrayList<Task> list, String tagName) {
		boolean taskRemoved = false;
		
		for (Iterator<Task> it = list.iterator(); it.hasNext();) { // Iterator is for save removal of elements while 
			                                                       // iterating
			Task task = it.next();
			ArrayList<String> taskTags = task.getTaskTags();
			if (taskTags != null && taskTags.contains(tagName)) {
				it.remove();
				removeFromAllLists(task); // This is safe because the task has already been removed from the current list.
				removeTaskTags(task.getTaskTags());
				taskRemoved = true;
			}
		}
		
		return taskRemoved;
	}
	
	/** 
	 * Views all tasks from the given list which contain at least one of the tags specified in tagNames. 
	 * 
	 * @param list
	 * @param tagName
	 * @return true if and only if at least one task was removed from the given list
	 */
	private boolean viewTaggedTasks(ArrayList<Task> list, ArrayList<String> tagNames) {
		boolean taskFound = false;
		
		for (Iterator<Task> it = list.iterator(); it.hasNext();) { 
			Task task = it.next();
			
			for (String s : tagNames) {
				ArrayList<String> taskTags = task.getTaskTags();
				if (taskTags != null && taskTags.contains(s)) {
					taskLists.get(INDEX_ACTION).add(task);
					taskFound = true;
					break;
				}
			}
		}
		
		return taskFound;
	}
	
	/** 
	 * Views all tasks from the given list which are of the specified priority. 
	 * 
	 * @param list
	 * @param priority
	 * @return true if and only if at least one task was found with the specified priority
	 */
	private boolean viewPriority(ArrayList<Task> list, String priority) {
		boolean priorityFound = false;
		int priorityNumber;
		
		if (priority.equals("high")) {
			priorityNumber = 3;
		} else if (priority.equals("medium")) {
			priorityNumber = 2;
		} else { // "low"
			priorityNumber = 1;
		}
		
		for (Iterator<Task> it = list.iterator(); it.hasNext();) { 
			Task task = it.next();
			
			if (task.getPriority() == priorityNumber) {
				taskLists.get(INDEX_ACTION).add(task);
				priorityFound = true;
			}
		}
		
		return priorityFound;
	}
	
	/** Views all tasks from the given list which are happening today. 
	 * 
	 * @param list
	 */
	private void viewToday(ArrayList<Task> list) {
		TimeConverter tc = new TimeConverter();
		
		for (Task t : list) {
			if (t.getTaskType().equals("DEADLINE") && tc.isToday(t.getDeadlineEpoch())) {
				taskLists.get(INDEX_ACTION).add(t);
			} else if (t.getTaskType().equals("EVENT")) {
				long currTime = tc.getCurrTime();
				long startDate = t.getStartDateEpoch();
				long endDate = t.getEndDateEpoch();
				
				if (tc.isToday(startDate) || tc.isToday(endDate)
				    || (startDate <= currTime && currTime <= endDate)) {
					taskLists.get(INDEX_ACTION).add(t);
				}
			}
		}
	}
	
	/** Views all tasks from the given list which are happening tomorrow. 
	 * 
	 * @param list
	 */
	private void viewTomorrow(ArrayList<Task> list) {
		TimeConverter tc = new TimeConverter();
		
		for (Task t : list) {
			if (t.getTaskType().equals("DEADLINE") && tc.isTmr(t.getDeadlineEpoch())) {
				taskLists.get(INDEX_ACTION).add(t);
			} else if (t.getTaskType().equals("EVENT")) {
				long tmrTime = tc.getCurrTime() + NUM_SECONDS_1_DAY;
				long startDate = t.getStartDateEpoch();
				long endDate = t.getEndDateEpoch();
				
				if (tc.isTmr(startDate) || tc.isTmr(endDate)
				    || (startDate <= tmrTime && tmrTime <= endDate)) {
					taskLists.get(INDEX_ACTION).add(t);
				}
			}
		}
	}
	
	/** 
	 * Adds all task tags in the given list into the tag category list.
	 * 
	 * @param taskTags
	 */
	void addTags(ArrayList<String> taskTags) {
		if (taskTags != null) {
			for (String s : taskTags) {
				addTag(s);
			}
		}
	}
	
	/** 
	 * Removes all task tags in the given list from the tag category list.
	 * 
	 * @param taskTags
	 */
	private void removeTaskTags(ArrayList<String> taskTags) {
		if (taskTags != null) {
			for (String s : taskTags) {
				removeTag(s);
			}
		}
	}
	
	/**
	 *  Returns true if and only if the given task already exists in any of the task lists.
	 * @param task
	 * @return
	 */
	private boolean taskAlreadyExists(Task task) {
		return (taskLists.get(INDEX_PENDING).contains(task) || taskLists.get(INDEX_COMPLETED).contains(task)
				|| taskLists.get(INDEX_EXPIRED).contains(task));
	}
	
	/**
	 * Add a new tag to the tag category list
	 * @param tagToAdd
	 */
	void addTag(String tagToAdd) { 
		int tagIndex = getTagIndex(tagToAdd);
		
		if (tagIndex == -1) { // Tag category list does not contain the tag to be added; add a new category for that tag.
			tagCategoryList.add(new TagCategory(tagToAdd)); 
		} else { // Tag category list already contains the tag to be added; increase the number of tags in that 
			     // category by one.
			tagCategoryList.get(tagIndex).increaseCount();
		}
	}
	
	/**
	 * Remove a tag from the tag category list. The tag should currently exist in the tag category list.
	 * @param tagToRemove
	 */
	private void removeTag(String tagToRemove) {
		int tagIndex = getTagIndex(tagToRemove);
		assert(tagIndex != -1);
		
		if (tagCategoryList.get(tagIndex).getNumTags() == 1) {
			tagCategoryList.remove(tagIndex);
		} else {
			tagCategoryList.get(tagIndex).decreaseCount();
		}
	}
	
	/**
	 * Returns the index of the specified tag name in the tag category list. If the tag name is not found, 
	 * -1 is returned.
	 * @param tagName
	 * @return
	 */
	private int getTagIndex(String tagName) {
		for (int i = 0; i < tagCategoryList.size(); i++) {
			if (tagCategoryList.get(i).getTagName().equals(tagName)) {
				return i;
			}
		}
		
		return -1;
	}
	
	/**
	 * Performs a search on the given list using the given search phrase, and returns a list of search results.
	 * The search algorithm uses the Levenshtein distance metric.
	 * @param list
	 * @param searchPhrase
	 * @return
	 */
	private ArrayList<Task> getSearchResults(ArrayList<Task> list, String searchPhrase) {
		ArrayList<Task> searchResults = new ArrayList<Task>();
		String[] searchTokens = searchPhrase.toLowerCase().split(" ");
		
		for (Task task : list) {
			double sumOfLevenshteinRatios = 0;
			boolean foundMatch = false;
			String[] taskNameTokens = task.getTaskName().toLowerCase().split(" ");
			
			if (searchTokens.length == 1) {
				if (searchPhrase.length() <= 2) { // For search phrases that are only one word with <= 2 characters,
					                              // perform whole word search only, for more precision.
					if (searchWholeWord(searchPhrase, taskNameTokens)) {
						searchResults.add(task);
					}
					continue;
				} else if (searchPhrase.length() >= 3 && searchSubstring(searchPhrase, taskNameTokens)) {
					searchResults.add(task);
					foundMatch = true;
				}
			}
			
			if (foundMatch) {
				continue;
			}
			
			for (String searchToken : searchTokens) {
				sumOfLevenshteinRatios += getMaxLevenshteinRatio(searchToken, taskNameTokens);
			}
			
			if ((sumOfLevenshteinRatios / searchTokens.length) >= 0.65) {
				searchResults.add(task);
			}
		}
		
		return searchResults;
	}
	
	/**
	 * Returns true if and only if the entire search phrase matches at least one of the task name tokens exactly.
	 * 
	 * @param searchToken
	 * @param taskNameTokens
	 * @return
	 */
	private static boolean searchWholeWord(String searchPhrase, String[] taskNameTokens) {
		for (String s : taskNameTokens) {
			if (searchPhrase.equals(s)) {
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Returns true if and only if the entire search phrase is a substring of at least one of the task name tokens.
	 * @param searchPhrase
	 * @param taskNameTokens
	 * @return
	 */
	private static boolean searchSubstring(String searchPhrase, String[] taskNameTokens) {
		for (String s : taskNameTokens) {
			if (s.contains(searchPhrase)) {
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Returns the maximum Levenshtein ratio when the search token is compared to each of the task name tokens.
	 * <p>The Levenshtein ratio between two Strings is calculated as follows: 
	 * <br>First, find the Levenshtein distance between the two Strings.
	 * <br>Then, divide the distance by the length of the longest String.
	 * <br>Finally, subtract the result from the number 1.
	 * 
	 * @param searchToken
	 * @param taskNameTokens
	 * @return
	 */
	private static double getMaxLevenshteinRatio(String searchToken, String[] taskNameTokens) {
		double maxRatio = 0;
		
		for (String s : taskNameTokens) {
			int currDist = getLevenshteinDist(searchToken, s);
			double currRatio = 1 - ((double) currDist / Math.max(searchToken.length(), s.length()));
			
			if (currRatio > maxRatio) {
				maxRatio = currRatio;
			}
		}
		
		return maxRatio;
	}

	/**
	 * Returns the Levenshtein distance between two Strings. The Levenshtein distance between two Strings is the minimum 
	 * number of single-character edits (i.e. insertions, deletions or substitutions) required to change one String into 
	 * the other.
	 *  
	 * @param source
	 * @param target
	 * @return
	 */
	private static int getLevenshteinDist(String source, String target) {
		// For all i and j, d[i][j] will hold the Levenshtein distance between the first i characters of source and 
		// the first j characters of target
		int[][] d = new int[source.length() + 1][target.length() + 1];
		
		// If target is an empty string, then the first i characters of source can be converted to target by deleting
		// each of these i characters, yielding a Levenshtein distance of i.
		for (int i = 1; i <= source.length(); i++) {
		      d[i][0] = i;
		}
		
		// If source is an empty string, then the first j characters of target can be converted to source by deleting
		// each of these j characters, yielding a Levenshtein distance of j.
		for (int j = 1; j <= target.length(); j++) {
		      d[0][j] = j;
		}
		
		for (int j = 1; j <= target.length(); j++) {
			for (int i = 1; i <= source.length(); i++) {
				int substitutionCost = 0;
				
				if (source.charAt(i - 1) != target.charAt(j - 1)) { // i-th character from source and j-th character
		        	                                                // from target do not match (1-based indices)
					substitutionCost = 1;
				}
				
				d[i][j] = Math.min(d[i-1][j] + 1, // Deleting i-th character from source yields a cost of 1
		                      	   Math.min(d[i][j-1] + 1, // Deleting j-th character from target yields a cost of 1
		                                    d[i-1][j-1] + substitutionCost)); // Substituting the i-th character from 
				                                                              // source to match the j-th character in
				                                                              // target
			}
	
		}
		
		return d[source.length()][target.length()];
	}
	
	// For testing
	public static void main(String[] args) {
		assert(getLevenshteinDist("kitten", "sitting") == 3);
		assert(getLevenshteinDist("sitting", "kitten") == 3);
		assert(getLevenshteinDist("", "abcd") == 4);
		assert(getLevenshteinDist("abcd", "abcd") == 0);
	}
}
```
###### taskey\src\taskey\logic\Save.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * saving of Task and TagCategory data in memory to disk.
 */
final class Save extends Command {
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.save();
	}
}
```
###### taskey\src\taskey\logic\Search.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * searching of tasks containing a specific keyword. 
 */
final class Search extends Command {
	
	private String searchPhrase;
	
	Search(String searchPhrase) {
		this.searchPhrase = searchPhrase;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.search(searchPhrase);
	}
}
```
###### taskey\src\taskey\logic\UpdateByIndex.java
``` java
 * This class provides the basic resources necessary for subclasses to encapsulate the instructions that the receiver, 
 * LogicMemory, must perform in order to facilitate the updating of indexed tasks. 
 */
abstract class UpdateByIndex extends Command {
	
	protected ContentBox contentBox;
	protected int updateIndex;
	
	protected UpdateByIndex(ContentBox contentBox, int updateIndex) {
		this.contentBox = contentBox;
		this.updateIndex = updateIndex;
	}
}
```
###### taskey\src\taskey\logic\UpdateByIndexChangeBoth.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * updating of indexed tasks by changing both their name and date. 
 */
final class UpdateByIndexChangeBoth extends UpdateByIndex {
	
	private String newName;
	private Task newTask; // Contains the new date

	UpdateByIndexChangeBoth(ContentBox contentBox, int updateIndex, String newName, Task newTask) {
		super(contentBox, updateIndex);
		this.newName = newName;
		this.newTask = newTask;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.updateByIndexChangeBoth(contentBox, updateIndex, newName, newTask);
	}
}
```
###### taskey\src\taskey\logic\UpdateByIndexChangeDate.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * updating of indexed tasks by changing their date. 
 */
final class UpdateByIndexChangeDate extends UpdateByIndex {
	
	private Task newTask; // Contains the new date

	UpdateByIndexChangeDate(ContentBox contentBox, int updateIndex, Task newTask) {
		super(contentBox, updateIndex);
		this.newTask = newTask;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.updateByIndexChangeDate(contentBox, updateIndex, newTask);
	}
}
```
###### taskey\src\taskey\logic\UpdateByIndexChangeName.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * updating of indexed tasks by changing their name. 
 */
final class UpdateByIndexChangeName extends UpdateByIndex {
	
	private String newName;

	UpdateByIndexChangeName(ContentBox contentBox, int updateIndex, String newName) {
		super(contentBox, updateIndex);
		this.newName = newName;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.updateByIndexChangeName(contentBox, updateIndex, newName);
	}
}
```
###### taskey\src\taskey\logic\UpdateByIndexChangePriority.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * updating of indexed tasks by changing their priority. 
 */
final class UpdateByIndexChangePriority extends UpdateByIndex {
	
	private int newPriority;

	UpdateByIndexChangePriority(ContentBox contentBox, int updateIndex, int newPriority) {
		super(contentBox, updateIndex);
		this.newPriority = newPriority;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.updateByIndexChangePriority(contentBox, updateIndex, newPriority);
	}
}
```
###### taskey\src\taskey\logic\ViewBasic.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * viewing of basic task categories (such as deadline or event). 
 */
final class ViewBasic extends Command {
	
	private String viewType;
	
	ViewBasic(String viewType) {
		this.viewType = viewType;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.viewBasic(viewType);
	}
}
```
###### taskey\src\taskey\logic\ViewTags.java
``` java
 * This class encapsulates the instructions that the receiver, LogicMemory, must perform in order to facilitate the 
 * viewing of tasks with the specified tags. 
 */
final class ViewTags extends Command {
	
	private ArrayList<String> tagNames;
	
	ViewTags(ArrayList<String> tagNames) {
		this.tagNames = tagNames;
	}
	
	@Override
	void execute(LogicMemory logicMemory) throws LogicException {
		logicMemory.viewTags(tagNames);
	}
}
```
###### taskey\src\taskey\messenger\TagCategory.java
``` java
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + numTags;
		result = prime * result + ((tagName == null) ? 0 : tagName.hashCode());
		
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		
		if (obj == null) {
			return false;
		}
		
		if (getClass() != obj.getClass()) {
			return false;
		}
		
		TagCategory other = (TagCategory) obj;
		
		if (numTags != other.numTags) {
			return false;
		}
		
		if (tagName == null) {
			if (other.tagName != null) {
				return false;
			}
		} else if (!tagName.equals(other.tagName)) {
			return false;
		}
		
		return true;
	}

	@Override
```
###### taskey\src\taskey\messenger\Task.java
``` java
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(datesEpoch);
		result = prime * result + Arrays.hashCode(datesHuman);
		result = prime * result + ((taskName == null) ? 0 : taskName.hashCode());
		result = prime * result + ((taskType == null) ? 0 : taskType.hashCode());
		
		return result;
	}

	// Two Tasks are considered to be equal if and only if they have the same name, task type, and dates.
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		
		if (obj == null) {
			return false;
		}
		
		if (getClass() != obj.getClass()) {
			return false;
		}
		
		Task other = (Task) obj;
		
		if (taskName == null) {
			if (other.taskName != null) {
				return false;
			}
		} else if (!taskName.equals(other.taskName)) {
			return false;
		}
		
		if (taskType == null) {
			if (other.taskType != null) {
				return false;
			}
		} else if (!taskType.equals(other.taskType)) {
			return false;
		}
		
		if ( priority != other.getPriority() ) {
			return false;
		}
		
		if (!Arrays.equals(datesEpoch, other.datesEpoch)) {
			return false;
		}
		
		if (!Arrays.equals(datesHuman, other.datesHuman)) {
			return false;
		}
			
		return true;
	}
	
	// Returns true if and only if the task is expired, according to the current time on the user's computer clock.
	public boolean isExpired() {
		long currTime = timeConverter.getCurrTime();
		
		if (taskType.equals("DEADLINE")) { // TODO: remove magic strings
			long deadline = getDeadlineEpoch();
			return (deadline < currTime);
		} else if (taskType.equals("EVENT")) {
			long endDate = getEndDateEpoch();
			return (endDate < currTime);
		} else { // Floating tasks are never expired
			return false;
		}
	}
	
	// Returns true if and only if the task is occurring this week, according to the current time on the user's computer 
	// clock.
	public boolean isThisWeek() {
		long currTime = timeConverter.getCurrTime();
		
		if (taskType.equals("DEADLINE")) { // TODO: remove magic strings
			long deadline = getDeadlineEpoch();
			return (timeConverter.isSameWeek(currTime, deadline));
		} else if (taskType.equals("EVENT")) { // An event is considered to be occurring this week if its start date or
			                                   // end date is within the current week, or the current time is between
			                                   // the start date and end date.
			long startDate = getStartDateEpoch();
			long endDate = getEndDateEpoch();
			return (timeConverter.isSameWeek(currTime, startDate) || timeConverter.isSameWeek(currTime, endDate)
					|| (startDate <= currTime && currTime <= endDate));
		} else { // Floating tasks are never this week
			return false;
		}
	}
	
	@Override 
	/**
```
###### taskey\src\taskey\messenger\Task.java
``` java
	 * To test whether the getDuplicate() method returns a deep copy of a given Task.
	public static void main(String[] args) {
		Task t1 = new Task("t1");
		t1.setTaskType("FLOATING");
		t1.addTaskTag("meow");
		Task t2 = t1.getDuplicate();
		t2.setTaskName("t2");
		t2.setTaskType("DEADLINE");
		t2.addTaskTag("crap");
		System.out.println("t1: " + t1);
		System.out.println("t2: " + t2);
	}*/
}
```
###### taskey\src\taskey\parser\ParseView.java
``` java
	 * For quick testing if parsing of tags is done correctly.
	public static void main(String[] args) {
		ParseView pv = new ParseView();
		ProcessedObject po = pv.processView("view", "view tag1#tag2 #tag3");
		System.out.println(po.getCommand());
		po = pv.processView("view", "view #tag1 #tag 2 #tag3");
		System.out.println(po.getCommand());
	}*/
}
```
###### taskey\test\taskey\junit\SystemTest.java
``` java
 */
public class SystemTest {
	public static final int NUM_SECONDS_1_DAY = 86400;
	public static final int NUM_SECONDS_1_WEEK = 604800;
	public static final int NUM_SECONDS_BUFFER_TIME = 10; // Used for safety in dealing with boundary conditions
	
	private Logic logic;
	private Parser parser;
	private TimeConverter timeConverter;
	
	private static ArrayList<ArrayList<Task>> getEmptyLists() {
		ArrayList<ArrayList<Task>> lists = new ArrayList<ArrayList<Task>>();
		
		while (lists.size() < LogicMemory.NUM_TASK_LISTS) {
			lists.add(new ArrayList<Task>());
		}
		
		return lists;
	}
	
	private static void sortLists(ArrayList<ArrayList<Task>> lists) {
		for (ArrayList<Task> list : lists) {
			Collections.sort(list);
		}
	}
	
	private static void sortListsReversed(ArrayList<ArrayList<Task>> lists) {
		for (ArrayList<Task> list : lists) {
			Collections.sort(list, Collections.reverseOrder());
		}
	}
	
	private static void sortListReversed(ArrayList<Task> list) {
		Collections.sort(list, Collections.reverseOrder());
	}
	
	
	// Make sure "clear" command works because it is used in setUp().
	// "clear" command is supposed to clear all task and tag data in memory.
	@BeforeClass
	public static void testClear() {
		Logic logic = new Logic();
		logic.executeCommand(ContentBox.PENDING, "clear");
		assertEquals(getEmptyLists(), logic.getAllTaskLists());
		assertTrue(logic.getTagCategoryList().isEmpty());
	}
	
	@Before
	public void setUp() {
		logic = new Logic();
		parser = new Parser(); 
		timeConverter = new TimeConverter();
		logic.executeCommand(ContentBox.PENDING, "clear");
	}
	
	@Test
	public void addingFloatingTaskShouldUpdateOnlyGeneralAndPendingLists() {
		String input = "add task";
		Task task = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_FLOATING).add(task);
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void addingDeadlineTaskEndingThisWeekShouldUpdateOnlyPendingAndDeadlineAndThisWeekLists() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime + NUM_SECONDS_BUFFER_TIME);
		String input = "add task on " + deadline;
		Task task = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_DEADLINE).add(task);
		expected.get(LogicMemory.INDEX_THIS_WEEK).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void addingDeadlineTaskNotEndingThisWeekShouldUpdateOnlyPendingAndDeadlineLists() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK + NUM_SECONDS_BUFFER_TIME);
		String input = "add task on " + deadline;
		Task task = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_DEADLINE).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void addingEventTaskStartingThisWeekShouldUpdateOnlyPendingAndEventAndThisWeekLists() {
		long currTime = timeConverter.getCurrTime();
		String startDate = timeConverter.getDate(currTime + NUM_SECONDS_BUFFER_TIME);
		String endDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK + NUM_SECONDS_BUFFER_TIME);
		String input = "add task from " + startDate + " to " + endDate;
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_EVENT).add(task);
		expected.get(LogicMemory.INDEX_THIS_WEEK).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void addingEventTaskNotStartingThisWeekShouldUpdateOnlyPendingAndEventLists() {
		long currTime = timeConverter.getCurrTime();
		String startDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK);
		String endDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK + NUM_SECONDS_1_DAY);
		String input = "add task from " + startDate + " to " + endDate;
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_EVENT).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Ignore
	public void addingExpiredDeadlineTaskShouldNotUpdateAnyLists() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY);
		String input = "add task on " + deadline;
		logic.executeCommand(ContentBox.PENDING, input);
		assertEquals(getEmptyLists(), logic.getAllTaskLists());
	}
	
	// Equivalence partitions: floating tasks, deadline tasks, event tasks with the same name but different dates
	@Test
	public void addingTasksWithSameNameButDifferentDatesShouldNotThrowException() {
		logic.executeCommand(ContentBox.PENDING, "add task");
		Exception e = logic.executeCommand(ContentBox.PENDING, "add task on 31 dec 3pm").getException();
		assertEquals(LogicException.MSG_SUCCESS_ADD, e.getMessage());
		e = logic.executeCommand(ContentBox.PENDING, "add task from 30 dec 5pm to 31 dec 6pm").getException();
		assertEquals(LogicException.MSG_SUCCESS_ADD, e.getMessage());
	}
	
	@Test
	public void tasksWithSameNameButDifferentDatesShouldBeAddedToTaskLists() {
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_FLOATING).add(task);
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		
		input = "add task on 31 dec 3pm";
		logic.executeCommand(ContentBox.PENDING, input);
		task = parser.parseInput(input).getTask();
		expected.get(LogicMemory.INDEX_DEADLINE).add(task);
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		
		input = "add task from 30 dec 5pm to 31 dec 6pm";
		logic.executeCommand(ContentBox.PENDING, input);
		task = parser.parseInput(input).getTask();
		expected.get(LogicMemory.INDEX_EVENT).add(task);
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		
		sortListsReversed(expected);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void deletingFloatingTaskByIndexShouldUpdatePendingAndGeneralLists() {
		logic.executeCommand(ContentBox.PENDING, "add task");
		logic.executeCommand(ContentBox.PENDING, "del 1");
		assertEquals(getEmptyLists(), logic.getAllTaskLists());
	}
	
	@Test
	public void deletingDeadlineTaskEndingThisWeekByIndexShouldUpdatePendingdAndDeadlineAndThisWeekLists() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime);
		logic.executeCommand(ContentBox.PENDING, "add task on " + deadline);
		logic.executeCommand(ContentBox.PENDING, "del 1");
		assertEquals(getEmptyLists(), logic.getAllTaskLists());
	}
	
	@Test
	public void deletingDeadlineTaskNotEndingThisWeekByIndexShouldUpdatePendingAndDeadlineLists() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK);
		logic.executeCommand(ContentBox.PENDING, "add task on " + deadline);
		logic.executeCommand(ContentBox.PENDING, "del 1");
		assertEquals(getEmptyLists(), logic.getAllTaskLists());
	}
	
	@Test
	public void deletingEventTaskStartingThisWeekByIndexShouldUpdatePendingAndEventAndThisWeekLists() {
		long currTime = timeConverter.getCurrTime();
		String startDate = timeConverter.getDate(currTime);
		String endDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK);
		logic.executeCommand(ContentBox.PENDING, "add task from " + startDate + " to " + endDate);
		logic.executeCommand(ContentBox.PENDING, "del 1");
		assertEquals(getEmptyLists(), logic.getAllTaskLists());
	}
	
	@Test
	public void deletingEventTaskNotStartingThisWeekByIndexShouldUpdatePendingAndEventLists() {
		long currTime = timeConverter.getCurrTime();
		String startDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK);
		String endDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK + NUM_SECONDS_1_DAY);
		logic.executeCommand(ContentBox.PENDING, "add task from " + startDate + " to " + endDate);
		logic.executeCommand(ContentBox.PENDING, "del 1");
		assertEquals(getEmptyLists(), logic.getAllTaskLists());
	}
	
	// Test inputs: 2 is out of range, 0 is an impossible index, -1 is a negative index and should not be allowed.
	@Test
	public void deletingTaskByInvalidIndexShouldThrowException() {
		logic.executeCommand(ContentBox.PENDING, "add task");
		Exception actual = logic.executeCommand(ContentBox.PENDING, "del 2").getException();
		String exceptionMsg = LogicException.MSG_ERROR_INVALID_INDEX;
		Exception expected = new Exception(exceptionMsg);
		assertEquals(expected.getMessage(), actual.getMessage());
		
		actual = logic.executeCommand(ContentBox.PENDING, "del 0").getException();
		expected = new Exception(exceptionMsg);
		assertEquals(expected.getMessage(), actual.getMessage());
		
		actual = logic.executeCommand(ContentBox.PENDING, "del -1").getException();
		expected = new Exception(exceptionMsg);
		assertEquals(expected.getMessage(), actual.getMessage());
	}
	
	@Test
	public void deletingTaskByInvalidIndexShouldNotChangeTaskLists() {
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_FLOATING).add(task);
		logic.executeCommand(ContentBox.PENDING, "del 2");
		assertEquals(expected, logic.getAllTaskLists());
		
		logic.executeCommand(ContentBox.PENDING, "del 0");
		assertEquals(expected, logic.getAllTaskLists());
		
		logic.executeCommand(ContentBox.PENDING, "del -1");
		assertEquals(expected, logic.getAllTaskLists());
	}
	
	// This test might fail once PowerSearch is implemented.
	@Ignore
	public void searchShouldReturnAllTasksWhoseNameContainsSearchPhrase() {
		String input = "add task1";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task1 = parser.parseInput(input).getTask();

		input = "add task2 on 31 dec";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task2 = parser.parseInput(input).getTask();

		// Both task1 and task2 match
		logic.executeCommand(ContentBox.PENDING, "search t");
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(task1);
		expected.add(task2);
		sortListReversed(expected);
		assertEquals(expected, logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION));
		
		// Only task2 matches
		logic.executeCommand(ContentBox.PENDING, "search 2");
		expected.remove(task1);
		assertEquals(expected, logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION));
	}
	
	@Ignore
	public void testSearch() {
		String input = "add I will initialize it before the eve of xmas";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task1 = parser.parseInput(input).getTask();
		
		input = "add In the end, it doesn't even matter";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task2 = parser.parseInput(input).getTask();
		
		logic.executeCommand(ContentBox.PENDING, "search eVe");
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(task1);
		expected.add(task2);
		assertEquals(expected, logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION));
		
		logic.executeCommand(ContentBox.PENDING, "search tHe eve");
		assertEquals(expected, logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION));
		
		logic.executeCommand(ContentBox.PENDING, "search evE THe");
		assertEquals(expected, logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION));
		
		logic.executeCommand(ContentBox.PENDING, "search tHe IN");
		expected.remove(task1);
		assertEquals(expected, logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION));
		
		logic.executeCommand(ContentBox.PENDING, "search iN");
		assertEquals(expected, logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION));
		
		logic.executeCommand(ContentBox.PENDING, "search e");
		expected.remove(task2);
		assertEquals(expected, logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION));
		
		logic.executeCommand(ContentBox.PENDING, "search i");
		expected.add(task1);
		assertEquals(expected, logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION));
	}
	
	// The completed task should be removed from all lists and then inserted into the COMPLETED list.
	@Test
	public void doneTaskByIndexShouldUpdateTaskLists() {
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, "done 1");
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_COMPLETED).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	// The completed task's tags should be removed from the tag database.
	// No other tags should be affected.
	@Test
	public void doneTaskByIndexShouldUpdateTagDatabase() {
		logic.executeCommand(ContentBox.PENDING, "add task #tag1 #tag2");
		logic.executeCommand(ContentBox.PENDING, "add task2 #tag1 #tag3");
		logic.executeCommand(ContentBox.PENDING, "done 1");
		ArrayList<TagCategory> expected = new ArrayList<TagCategory>();
		expected.add(new TagCategory("tag1"));
		expected.add(new TagCategory("tag3"));
		assertEquals(expected, logic.getTagCategoryList());
	}
	
	@Test
	public void doneTaskByInvalidIndexShouldThrowException() {
		logic.executeCommand(ContentBox.PENDING, "add task");
		Exception actual = logic.executeCommand(ContentBox.PENDING, "done 2").getException();
		String exceptionMsg = String.format(LogicException.MSG_ERROR_INVALID_INDEX, 2);
		Exception expected = new Exception(exceptionMsg);
		assertEquals(expected.getMessage(), actual.getMessage());
		
		actual = logic.executeCommand(ContentBox.PENDING, "done 0").getException();
		exceptionMsg = String.format(LogicException.MSG_ERROR_INVALID_INDEX, 0);
		expected = new Exception(exceptionMsg);
		assertEquals(expected.getMessage(), actual.getMessage());
		
		actual = logic.executeCommand(ContentBox.PENDING, "done -1").getException();
		exceptionMsg = String.format(LogicException.MSG_ERROR_INVALID_INDEX, -1);
		expected = new Exception(exceptionMsg);
		assertEquals(expected.getMessage(), actual.getMessage());
	}
	
	@Test
	public void doneTaskByInvalidIndexShouldNotChangeTaskLists() {
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_FLOATING).add(task);
		logic.executeCommand(ContentBox.PENDING, "done 2");
		assertEquals(expected, logic.getAllTaskLists());
		
		logic.executeCommand(ContentBox.PENDING, "done 0");
		assertEquals(expected, logic.getAllTaskLists());
		
		logic.executeCommand(ContentBox.PENDING, "done -1");
		assertEquals(expected, logic.getAllTaskLists());
	}
	
	// Every list that contains the updated task should also be updated.
	@Test
	public void updateTaskByIndexChangeNameShouldUpdateTaskLists() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime);
		String input = "add task on " + deadline;
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, "set 1 \"new name\"");
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		task.setTaskName("new name");
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_DEADLINE).add(task);
		expected.get(LogicMemory.INDEX_THIS_WEEK).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void updateTaskByInvalidIndexShouldThrowExceptionMessage() {
		logic.executeCommand(ContentBox.PENDING, "add task");
		Exception actual = logic.executeCommand(ContentBox.PENDING, "set 2 \"new name\"").getException();
		String exceptionMsg = LogicException.MSG_ERROR_INVALID_INDEX;
		Exception expected = new Exception(exceptionMsg);
		assertEquals(expected.getMessage(), actual.getMessage());
		
		actual = logic.executeCommand(ContentBox.PENDING, "set 0 \"new name\" [31 dec]").getException();
		expected = new Exception(exceptionMsg);
		assertEquals(expected.getMessage(), actual.getMessage());
		
		actual = logic.executeCommand(ContentBox.PENDING, "set -1 [31 dec]").getException();
		expected = new Exception(exceptionMsg);
		assertEquals(expected.getMessage(), actual.getMessage());
	}
	
	@Test
	public void updateTaskByInvalidIndexShouldNotChangeTaskLists() {
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_FLOATING).add(task);
		logic.executeCommand(ContentBox.PENDING, "set 2 \"new name\"");
		assertEquals(expected, logic.getAllTaskLists());
		
		logic.executeCommand(ContentBox.PENDING, "set 0 \"new name\" [31 dec]");
		assertEquals(expected, logic.getAllTaskLists());
		
		logic.executeCommand(ContentBox.PENDING, "set -1 [31 dec]");
		assertEquals(expected, logic.getAllTaskLists());
		
		logic.executeCommand(ContentBox.PENDING, "set 0 !!");
		assertEquals(1, logic.getAllTaskLists().get(LogicMemory.INDEX_PENDING).get(0).getPriority());
	}
		
	@Test
	public void changingTaskDateFromFloatingToDeadlineShouldUpdateTaskLists() {
		long currTime = timeConverter.getCurrTime();
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		String oldTaskName = parser.parseInput(input).getTask().getTaskName();
		String deadline = timeConverter.getDate(currTime);
		input = "set 1 [" + deadline + "]";
		logic.executeCommand(ContentBox.PENDING, input);
		Task newTask = parser.parseInput(input).getTask();
		newTask.setTaskName(oldTaskName);
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_DEADLINE).add(newTask);
		expected.get(LogicMemory.INDEX_PENDING).add(newTask);
		expected.get(LogicMemory.INDEX_THIS_WEEK).add(newTask);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void changingTaskDateFromDeadlineToEventShouldUpdateTaskLists() {
		long currTime = timeConverter.getCurrTime();
		String input = "add task on " + timeConverter.getDate(currTime);
		logic.executeCommand(ContentBox.PENDING, input);
		String oldTaskName = parser.parseInput(input).getTask().getTaskName();
		input = "set 1 [30 dec 5pm, 31 dec 3pm]";
		logic.executeCommand(ContentBox.PENDING, input);
		Task newTask = parser.parseInput(input).getTask();
		newTask.setTaskName(oldTaskName);
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_EVENT).add(newTask);
		expected.get(LogicMemory.INDEX_PENDING).add(newTask);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void changingTaskDateFromEventToFloatingShouldUpdateTaskLists() {
		long currTime = timeConverter.getCurrTime();
		String input = "add task from " + timeConverter.getDate(currTime) + " to 31 dec 11pm";
		logic.executeCommand(ContentBox.PENDING, input);
		String oldTaskName = parser.parseInput(input).getTask().getTaskName();
		input = "set 1 [none]";
		logic.executeCommand(ContentBox.PENDING, input);
		Task newTask = parser.parseInput(input).getTask();
		newTask.setTaskName(oldTaskName);
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_FLOATING).add(newTask);
		expected.get(LogicMemory.INDEX_PENDING).add(newTask);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void changingTaskDateToExpiredShouldUpdateTaskLists() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime);
		String input = "add task on " + deadline;
		Task oldTask = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);

		input = "view deadlines";
		logic.executeCommand(ContentBox.PENDING, input);
		
		deadline = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY);
		input = "set 1 [" + deadline + "]";
		Task newTask = parser.parseInput(input).getTask();
		newTask.setTaskName(oldTask.getTaskName());
		logic.executeCommand(ContentBox.ACTION, input);
		
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_EXPIRED).add(newTask);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}

	@Test
	public void changingTaskNameAndDateShouldUpdateTaskLists() {
		long currTime = timeConverter.getCurrTime();
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		String deadline = timeConverter.getDate(currTime);
		input = "set 1 [" + deadline + "] \"new name\"";
		logic.executeCommand(ContentBox.PENDING, input);
		Task newTask = parser.parseInput(input).getTask();
		newTask.setTaskName("new name");
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_DEADLINE).add(newTask);
		expected.get(LogicMemory.INDEX_PENDING).add(newTask);
		expected.get(LogicMemory.INDEX_THIS_WEEK).add(newTask);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Ignore
	public void changingTaskNameShouldThrowExceptionMessageIfThereIsDuplicateTask() {
		logic.executeCommand(ContentBox.PENDING, "add task");
		logic.executeCommand(ContentBox.PENDING, "add task 2");
		Exception actual = logic.executeCommand(ContentBox.PENDING, "set 2 \"task\"").getException();
		String expected = LogicException.MSG_ERROR_DUPLICATE_TASKS;
		assertEquals(expected, actual.getMessage());
	}
	
	@Ignore
	public void changingTaskNameShouldNotChangeTaskListsIfThereIsDuplicateTask() {
		String input = "add task";
		Task task1 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);

		input = "add task 2";
		Task task2 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, "add task 2");

		input = "set 2 \"task\"";
		logic.executeCommand(ContentBox.PENDING, input); // Should fail
		
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task1);
		expected.get(LogicMemory.INDEX_PENDING).add(task2);
		expected.get(LogicMemory.INDEX_FLOATING).add(task1);
		expected.get(LogicMemory.INDEX_FLOATING).add(task2);
		assertEquals(expected, logic.getAllTaskLists());
	}
	
	
	@Test
	public void undoAddShouldUpdateTaskLists() {
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		logic.executeCommand(ContentBox.PENDING, "undo");
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void undoAddShouldUpdateTagDatabase() {
		String input = "add task #tag1 #tag2";
		logic.executeCommand(ContentBox.PENDING, input);
		logic.executeCommand(ContentBox.PENDING, "undo");
		assertTrue(logic.getTagCategoryList().isEmpty());
	}
	
	@Test
	public void undoDeleteShouldUpdateTaskLists() {
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, "del 1");
		logic.executeCommand(ContentBox.PENDING, "undo");
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_FLOATING).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void undoDeleteShouldUpdateTagDatabase() {
		String input = "add task #tag1 #tag2";
		logic.executeCommand(ContentBox.PENDING, input);
		logic.executeCommand(ContentBox.PENDING, "del 1");
		logic.executeCommand(ContentBox.PENDING, "undo");
		ArrayList<TagCategory> expected = new ArrayList<TagCategory>();
		expected.add(new TagCategory("tag1"));
		expected.add(new TagCategory("tag2"));
		ArrayList<TagCategory> actual = logic.getTagCategoryList();
		assertEquals(expected, actual);
	}
	
	@Test
	public void undoUpdateShouldUpdateTaskLists() {
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, "set 1 \"new name\" [30 dec 5pm, 31 dec 3pm]");
		logic.executeCommand(ContentBox.PENDING, "undo");
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_FLOATING).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void undoDoneShouldUpdateTaskLists() {
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		Task task = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, "done 1");
		logic.executeCommand(ContentBox.PENDING, "undo");
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_FLOATING).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void undoDoneShouldUpdateTagDatabase() {
		String input = "add task #tag1 #tag2";
		logic.executeCommand(ContentBox.PENDING, input);
		logic.executeCommand(ContentBox.PENDING, "done 1");
		logic.executeCommand(ContentBox.PENDING, "undo");
		ArrayList<TagCategory> expected = new ArrayList<TagCategory>();
		expected.add(new TagCategory("tag1"));
		expected.add(new TagCategory("tag2"));
		ArrayList<TagCategory> actual = logic.getTagCategoryList();
		assertEquals(expected, actual);
	}
	
	@Test
	public void addingTaggedFloatingTaskShouldUpdateTagDatabase() {
		logic.executeCommand(ContentBox.PENDING, "add task #tag1 #tag2");
		ArrayList<TagCategory> expected = new ArrayList<TagCategory>();
		expected.add(new TagCategory("tag1"));
		expected.add(new TagCategory("tag2"));
		ArrayList<TagCategory> actual = logic.getTagCategoryList();
		assertEquals(expected, actual);
	}
	
	@Test
	public void addingTaggedDeadlineTaskShouldUpdateTagDatabase() {
		logic.executeCommand(ContentBox.PENDING, "add task on 31 dec 5pm #tag1 #tag2");
		ArrayList<TagCategory> expected = new ArrayList<TagCategory>();
		expected.add(new TagCategory("tag1"));
		expected.add(new TagCategory("tag2"));
		ArrayList<TagCategory> actual = logic.getTagCategoryList();
		assertEquals(expected, actual);
	}
	
	@Test
	public void addingTaggedEventTaskShouldUpdateTagDatabase() {
		logic.executeCommand(ContentBox.PENDING, "add task from 30 dec 5pm to 31 dec 5pm #tag1 #tag2");
		ArrayList<TagCategory> expected = new ArrayList<TagCategory>();
		expected.add(new TagCategory("tag1"));
		expected.add(new TagCategory("tag2"));
		ArrayList<TagCategory> actual = logic.getTagCategoryList();
		assertEquals(expected, actual);
	}
	
	@Test
	public void addingDuplicateTaskShouldNotChangeTaskLists() {
		String input = "add task";
		Task task1 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		logic.executeCommand(ContentBox.PENDING, input); // Attempting to add duplicate floating task
		
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK);
		input = "add task on " + deadline;
		Task task2 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		logic.executeCommand(ContentBox.PENDING, input); // Attempting to add duplicate deadline task
		
		String startDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK);
		String endDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK + NUM_SECONDS_1_DAY);
		input = "add task from " + startDate + " to " + endDate;
		Task task3 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		logic.executeCommand(ContentBox.PENDING, input); // Attempting to add duplicate event task
		
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task1);
		expected.get(LogicMemory.INDEX_PENDING).add(task2);
		expected.get(LogicMemory.INDEX_PENDING).add(task3);
		expected.get(LogicMemory.INDEX_FLOATING).add(task1);
		expected.get(LogicMemory.INDEX_DEADLINE).add(task2);
		expected.get(LogicMemory.INDEX_EVENT).add(task3);
		sortListsReversed(expected);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void deletingArchivedTaskShouldNotUpdateTagCategoryList() {
		logic.executeCommand(ContentBox.PENDING, "add task #yolo #swag");
		logic.executeCommand(ContentBox.PENDING, "add task2 #swag #420");
		logic.executeCommand(ContentBox.PENDING, "done 2"); // Archive task2; this should delete one instance of #swag and
		                                                    // #420 from the tag category list
		logic.executeCommand(ContentBox.PENDING, "view archive");
		logic.executeCommand(ContentBox.ACTION, "del 1"); // Delete the archived task2; this should not change the tag 
		                                                  // category list
		
		ArrayList<TagCategory> expected = new ArrayList<TagCategory>();
		expected.add(new TagCategory("swag"));
		expected.add(new TagCategory("yolo"));
		Collections.sort(expected);
		assertEquals(expected, logic.getTagCategoryList());
	}
	
	@Test
	public void deletingTaggedTaskByIndexShouldUpdateTagDatabase() {
		logic.executeCommand(ContentBox.PENDING, "add task #tag1 #tag2");
		logic.executeCommand(ContentBox.PENDING,"del 1");
		assertTrue(logic.getTagCategoryList().isEmpty());
	}
	
	@Test
	public void deletingTagCategoryShouldUpdateTaskLists() {
		logic.executeCommand(ContentBox.PENDING, "add task #tag1");
		logic.executeCommand(ContentBox.PENDING, "add task2 on 31 dec 3pm #tag2 #tag3");
		logic.executeCommand(ContentBox.PENDING, "add task3 from 30 dec 1pm to 31 dec 2pm #tag1 #tag3");
		logic.executeCommand(ContentBox.PENDING, "del #tag3");
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		Task task = parser.parseInput("add task #tag1").getTask();
		expected.get(LogicMemory.INDEX_PENDING).add(task);
		expected.get(LogicMemory.INDEX_FLOATING).add(task);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
	}
	
	@Test
	public void deletingTagCategoryShouldUpdateTagDatabase() {
		logic.executeCommand(ContentBox.PENDING, "add task #tag1");
		logic.executeCommand(ContentBox.PENDING, "add task2 on 31 dec 3pm #tag2 #tag3");
		logic.executeCommand(ContentBox.PENDING, "add task3 from 30 dec 1pm to 31 dec 2pm #tag1 #tag3");
		logic.executeCommand(ContentBox.PENDING, "del #tag3");
		ArrayList<TagCategory> expected = new ArrayList<TagCategory>();
		expected.add(new TagCategory("tag1")); // #tag2 and #tag3 should not be in tag database
		assertEquals(expected, logic.getTagCategoryList());
	}
	
	@Test
	public void deletingNonExistentTagCategoryShouldThrowException() {
		logic.executeCommand(ContentBox.PENDING, "add task #tag1");
		logic.executeCommand(ContentBox.PENDING, "add task2 on 31 dec 3pm #tag2 #tag3");
		logic.executeCommand(ContentBox.PENDING, "add task3 from 30 dec 1pm to 31 dec 2pm #tag1 #tag3");
		LogicException expected = new LogicException(LogicException.MSG_ERROR_TAG_NOT_FOUND);
		LogicException actual = logic.executeCommand(ContentBox.PENDING, "del #tag4").getException();
		assertEquals(expected, actual);
	}
	
	// The order of displayed tasks is not tested here.
	// This test also checks that there are no duplicate tasks in the displayed list.
	@Test
	public void viewingTagsShouldOnlyDisplayAllTasksWithAtLeastOneOfThoseTags() {
		logic.executeCommand(ContentBox.PENDING, "add task1 #tag1");
		logic.executeCommand(ContentBox.PENDING, "add task2 on 31 dec 3pm #tag2 #tag3");
		logic.executeCommand(ContentBox.PENDING, "add task3 from 30 dec 1pm to 31 dec 2pm #tag1 #tag3");
		logic.executeCommand(ContentBox.PENDING, "add task4 #tag2 #tag4");
		logic.executeCommand(ContentBox.PENDING, "view #tag1 #tag3 #tag5");
		ArrayList<Task> viewList = logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION);
		Task task1 = parser.parseInput("add task1 #tag1").getTask();
		assertTrue(viewList.contains(task1));
		Task task2 = parser.parseInput("add task2 on 31 dec 3pm #tag2 #tag3").getTask();
		assertTrue(viewList.contains(task2));
		Task task3 = parser.parseInput("add task3 from 30 dec 1pm to 31 dec 2pm #tag1 #tag3").getTask();
		assertTrue(viewList.contains(task3));
		assertTrue(viewList.size() == 3); // Should not contain task4
	}
	
	@Test
	public void updatingCompletedTasksShouldNotChangeTaskLists() {
		String input = "add task !!";
		Task task = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		logic.executeCommand(ContentBox.PENDING, "done 1");
		logic.executeCommand(ContentBox.PENDING, "view archive");
		logic.executeCommand(ContentBox.ACTION, "set 1 \"new name\"");
		logic.executeCommand(ContentBox.ACTION, "set 1 !!!");
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_COMPLETED).add(task);
		expected.get(LogicMemory.INDEX_ACTION).add(task);
		assertEquals(expected, logic.getAllTaskLists());
		assertEquals(logic.getAllTaskLists().get(LogicMemory.INDEX_COMPLETED).get(0).getPriority(), 2);
	}
	
	@Test
	public void doneCompletedTasksShouldThrowExceptionMessage() {
		String input = "add task";
		logic.executeCommand(ContentBox.PENDING, input);
		logic.executeCommand(ContentBox.PENDING, "done 1");
		logic.executeCommand(ContentBox.PENDING, "view archive");
		LogicException expected = new LogicException(LogicException.MSG_ERROR_DONE_INVALID);
		LogicException actual = logic.executeCommand(ContentBox.ACTION, "done 1").getException();
		assertEquals(expected, actual);
	}
	
	@Test
	public void searchingWithTwoCharactersOrLessShouldPerformWholeWordSearchOnly() {
		String input = "add of mice and men";
		Task task1 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		input = "add fof ofo";
		Task task2 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		logic.executeCommand(ContentBox.PENDING, "search of");
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(task1); // task2 should not be in the search results
		ArrayList<Task> actual = logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION);
		assertEquals(expected, actual);
	}
	
	@Test
	public void searchingWithThreeCharactersOrMoreShouldPerformSubstringSearchAndLevenshteinSearch() {
		String input = "add band";
		Task task1 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		input = "add hind";
		Task task2 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		logic.executeCommand(ContentBox.PENDING, "search and");
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(task1); // task2 should not be in the search results
		ArrayList<Task> actual = logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION);
		assertEquals(expected, actual);
		
		logic.executeCommand(ContentBox.PENDING, "search hand");
		expected.add(task2);
		sortListReversed(expected);
		actual = logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION);
		assertEquals(expected, actual);
	}
	
	@Test
	public void viewingPriorityShouldOnlyShowAllPendingAndExpiredTasksWithThatPriority() {
		String input = "add task";
		Task task1 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		input = "add task on 31 dec !!";
		Task task2 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		input = "add task from today to tmr !!!";
		Task task3 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		input = "add task4 !!";
		Task task4 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		logic.executeCommand(ContentBox.PENDING, "view medium"); // Should only display task2 and task4
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(task2);
		expected.add(task4);
		sortListReversed(expected);
		ArrayList<Task> actual = logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION);
		assertEquals(expected, actual);
	}
	
	// This test is currently dependent on the order of the lists, which in turn depends on the compareTo() method
	// in Task.java. Until the sorting method is finalized, this test may occasionally fail.
	@Test
	public void updatingTaskPriorityByIndexShouldNotAffectAnyOtherTasks() {
		String input = "add task1";
		Task task1 = parser.parseInput(input).getTask(); // Should go into PENDING and FLOATING lists
		logic.executeCommand(ContentBox.PENDING, input);

		input = "add task2";
		Task task2 = parser.parseInput(input).getTask(); // Should go into PENDING and FLOATING lists
		logic.executeCommand(ContentBox.PENDING, input);
		
		logic.executeCommand(ContentBox.PENDING, "set 2 !!"); // Should only modify task2
		
		ArrayList<Task> pendingList = logic.getAllTaskLists().get(LogicMemory.INDEX_PENDING);
		ArrayList<Task> floatingList = logic.getAllTaskLists().get(LogicMemory.INDEX_FLOATING);
		assertTrue(pendingList.get(0).getPriority() == 2);
		assertTrue(pendingList.get(1).getPriority() == 1);
		assertTrue(floatingList.get(0).getPriority() == 2);
		assertTrue(floatingList.get(1).getPriority() == 1);
	}
	
	@Test
	public void savingShouldSaveAllTaskAndTagDataToDisk() {
		String input = "add task #ayy #lmao";
		Task task1 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime);
		input = "add task on " + deadline + " #lmao #420";
		Task task2 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		String startDate = deadline;
		String endDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK);
		input = "add task from " + startDate + " to " + endDate + " #ayy #memes #lmao";
		Task task3 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		logic.executeCommand(ContentBox.PENDING, "save");
		
		logic = new Logic(); // To simulate exiting and reloading the software
		
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_PENDING).add(task1);
		expected.get(LogicMemory.INDEX_PENDING).add(task2);
		expected.get(LogicMemory.INDEX_PENDING).add(task3);
		expected.get(LogicMemory.INDEX_FLOATING).add(task1);
		expected.get(LogicMemory.INDEX_THIS_WEEK).add(task2);
		expected.get(LogicMemory.INDEX_THIS_WEEK).add(task3);
		expected.get(LogicMemory.INDEX_DEADLINE).add(task2);
		expected.get(LogicMemory.INDEX_EVENT).add(task3);
		sortListsReversed(expected);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
		
		ArrayList<TagCategory> expected2 = new ArrayList<TagCategory>();
		TagCategory tag1 = new TagCategory("ayy");
		tag1.increaseCount();
		TagCategory tag2 = new TagCategory("lmao");
		tag2.increaseCount();
		tag2.increaseCount();
		TagCategory tag3 = new TagCategory("420");
		TagCategory tag4 = new TagCategory("memes");
		expected2.add(tag1);
		expected2.add(tag2);
		expected2.add(tag3);
		expected2.add(tag4);
		Collections.sort(expected2);
		ArrayList<TagCategory> actual2 = logic.getTagCategoryList();
		assertEquals(expected2, actual2);
	}
	
	// A pending deadline task should be added to this week list if its deadline falls within this week and it is not
	// expired.
	// A pending event task should be added to this week list if it is not expired, and its start date or end date falls
	// within this week, or the current time is between the start date and end date.
	@Test
	public void testUpdateThisWeekListScenarios() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime); 
		String input = "add task on " + deadline;
		Task task1 = parser.parseInput(input).getTask(); // Unexpired, this week
		logic.executeCommand(ContentBox.PENDING, input);
		
		deadline = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY); 
		input = "add task on " + deadline;
		Task task2 = parser.parseInput(input).getTask(); // Expired
		logic.executeCommand(ContentBox.PENDING, input);
		
		String startDate = timeConverter.getDate(currTime - NUM_SECONDS_1_WEEK);
		String endDate = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY); 
		input = "add task from " + startDate + " to " + endDate;
		Task task3 = parser.parseInput(input).getTask(); // Expired
		logic.executeCommand(ContentBox.PENDING, input);
		
		startDate = timeConverter.getDate(currTime - NUM_SECONDS_1_WEEK);
		endDate = timeConverter.getDate(currTime + NUM_SECONDS_BUFFER_TIME); 
		input = "add task from " + startDate + " to " + endDate;
		Task task4 = parser.parseInput(input).getTask(); // Unexpired, this week
		logic.executeCommand(ContentBox.PENDING, input);
		
		startDate = timeConverter.getDate(currTime + NUM_SECONDS_BUFFER_TIME);
		endDate = timeConverter.getDate(currTime + NUM_SECONDS_1_DAY); 
		input = "add task from " + startDate + " to " + endDate;
		Task task5 = parser.parseInput(input).getTask(); // Unexpired, this week
		logic.executeCommand(ContentBox.PENDING, input);
		
		startDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK);
		endDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK + NUM_SECONDS_1_DAY); 
		input = "add task from " + startDate + " to " + endDate;
		Task task6 = parser.parseInput(input).getTask(); // Unexpired, not this week
		logic.executeCommand(ContentBox.PENDING, input);
		
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(task1);
		expected.add(task4);
		expected.add(task5);
		sortListReversed(expected);
		ArrayList<Task> actual = logic.getAllTaskLists().get(LogicMemory.INDEX_THIS_WEEK);
		assertEquals(expected, actual);
	}
	
	@Test
	public void addingExpiredTaskShouldUpdateExpiredListAndTagCategoryList() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY);
		String input = "add task on " + deadline + " #ayy #lmao";
		Task task1 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		String startDate = timeConverter.getDate(currTime - NUM_SECONDS_1_WEEK);
		String endDate = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY);
		input = "add task from " + startDate + " to " + endDate + " #lmao #420";
		Task task2 = parser.parseInput(input).getTask();
		logic.executeCommand(ContentBox.PENDING, input);
		
		ArrayList<ArrayList<Task>> expected = getEmptyLists();
		expected.get(LogicMemory.INDEX_EXPIRED).add(task1);
		expected.get(LogicMemory.INDEX_EXPIRED).add(task2);
		sortListsReversed(expected);
		ArrayList<ArrayList<Task>> actual = logic.getAllTaskLists();
		assertEquals(expected, actual);
		
		ArrayList<TagCategory> expected2 = new ArrayList<TagCategory>();
		TagCategory tag1 = new TagCategory("ayy");
		TagCategory tag2 = new TagCategory("lmao");
		tag2.increaseCount();
		TagCategory tag3 = new TagCategory("420");
		expected2.add(tag1);
		expected2.add(tag2);
		expected2.add(tag3);
		Collections.sort(expected2);
		ArrayList<TagCategory> actual2 = logic.getTagCategoryList();
		assertEquals(expected2, actual2);
	}
	
	@Test
	public void addingExpiredTaskShouldThrowTheCorrectException() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY);
		String input = "add task on " + deadline + " #ayy #lmao";
		LogicException expected1 = logic.executeCommand(ContentBox.PENDING, input).getException();
		
		String startDate = timeConverter.getDate(currTime - NUM_SECONDS_1_WEEK);
		String endDate = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY);
		input = "add task from " + startDate + " to " + endDate + " #lmao #420";
		Task task2 = parser.parseInput(input).getTask();
		LogicException expected2 = logic.executeCommand(ContentBox.PENDING, input).getException();
		
		LogicException actual = new LogicException(LogicException.MSG_SUCCESS_ADD_EXPIRED);
		assertEquals(expected1, actual);
		assertEquals(expected2, actual);
	}
	
	@Test
	public void updatingToExpiredTaskShouldThrowTheCorrectException() {
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime);
		String input = "add task on " + deadline;
		logic.executeCommand(ContentBox.PENDING, input);

		input = "view deadlines";
		logic.executeCommand(ContentBox.PENDING, input);
		
		deadline = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY);
		input = "set 1 [" + deadline + "]";
		LogicException expected = logic.executeCommand(ContentBox.ACTION, input).getException();
		LogicException actual = new LogicException(LogicException.MSG_SUCCESS_UPDATE_EXPIRED);
		assertEquals(expected, actual);
	}
	
	@Test
	public void viewTodayShouldOnlyShowTodaysDeadlineAndEventTasks() {
		String input = "add task";
		Task task1 = parser.parseInput(input).getTask(); // Should not be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime); // Today
		input = "add task on " + deadline;
		Task task2 = parser.parseInput(input).getTask(); // Should be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		deadline = timeConverter.getDate(currTime + NUM_SECONDS_1_DAY); // Tmr
		input = "add task on " + deadline;
		Task task3 = parser.parseInput(input).getTask(); // Should not be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		deadline = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY); // Yesterday
		input = "add task on " + deadline;
		Task task4 = parser.parseInput(input).getTask(); // Should not be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		String startDate = timeConverter.getDate(currTime - NUM_SECONDS_1_WEEK);
		String endDate = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY);
		input = "add task from " + startDate + " to " + endDate;
		Task task5 = parser.parseInput(input).getTask(); // Should not be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		endDate = timeConverter.getDate(currTime);
		input = "add task from " + startDate + " to " + endDate;
		Task task6 = parser.parseInput(input).getTask(); // Should be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		endDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK);
		input = "add task from " + startDate + " to " + endDate;
		Task task7 = parser.parseInput(input).getTask(); // Should be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		startDate = timeConverter.getDate(currTime);
		input = "add task from " + startDate + " to " + endDate;
		Task task8 = parser.parseInput(input).getTask(); // Should be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		startDate = timeConverter.getDate(currTime + NUM_SECONDS_1_DAY);
		input = "add task from " + startDate + " to " + endDate;
		Task task9 = parser.parseInput(input).getTask(); // Should not be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		logic.executeCommand(ContentBox.PENDING, "view today");
		
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(task2);
		expected.add(task6);
		expected.add(task7);
		expected.add(task8);
		sortListReversed(expected);
		ArrayList<Task> actual = logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION);
		assertEquals(expected, actual);
	}
	
	@Test
	public void viewTmrShouldOnlyShowTmrsDeadlineAndEventTasks() {
		String input = "add task";
		Task task1 = parser.parseInput(input).getTask(); // Should not be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		long currTime = timeConverter.getCurrTime();
		String deadline = timeConverter.getDate(currTime); // Today
		input = "add task on " + deadline;
		Task task2 = parser.parseInput(input).getTask(); // Should not be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		deadline = timeConverter.getDate(currTime + NUM_SECONDS_1_DAY); // Tmr
		input = "add task on " + deadline;
		Task task3 = parser.parseInput(input).getTask(); // Should be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		deadline = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY); // Yesterday
		input = "add task on " + deadline;
		Task task4 = parser.parseInput(input).getTask(); // Should not be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		String startDate = timeConverter.getDate(currTime - NUM_SECONDS_1_WEEK);
		String endDate = timeConverter.getDate(currTime - NUM_SECONDS_1_DAY);
		input = "add task from " + startDate + " to " + endDate;
		Task task5 = parser.parseInput(input).getTask(); // Should not be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		endDate = timeConverter.getDate(currTime);
		input = "add task from " + startDate + " to " + endDate;
		Task task6 = parser.parseInput(input).getTask(); // Should not be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		endDate = timeConverter.getDate(currTime + NUM_SECONDS_1_WEEK);
		input = "add task from " + startDate + " to " + endDate;
		Task task7 = parser.parseInput(input).getTask(); // Should be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		startDate = timeConverter.getDate(currTime);
		input = "add task from " + startDate + " to " + endDate;
		Task task8 = parser.parseInput(input).getTask(); // Should be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		startDate = timeConverter.getDate(currTime + NUM_SECONDS_1_DAY);
		input = "add task from " + startDate + " to " + endDate;
		Task task9 = parser.parseInput(input).getTask(); // Should be shown
		logic.executeCommand(ContentBox.PENDING, input);
		
		logic.executeCommand(ContentBox.PENDING, "view tomorrow");
		
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(task3);
		expected.add(task7);
		expected.add(task8);
		expected.add(task9);
		sortListReversed(expected);
		ArrayList<Task> actual = logic.getAllTaskLists().get(LogicMemory.INDEX_ACTION);
		assertEquals(expected, actual);
	}
}
```
