# A0121618M
###### taskey\src\taskey\logic\History.java
``` java
 * This class is used by Logic for the undo and redo commands.
 * Every time the task lists are updated, they are pushed onto the taskStack.
 * At the same time, the tag list is also pushed onto the tagStack.
 * 
 * The undo command pops the most recently added task and tag data from the main stack
 * and pushes them onto the redo stack, to be held there until new data is added to History
 * (whereupon the redo stack is cleared), or the user invokes the redo command.
 * 
 * This class's redo method does the reverse of the undo routine: 
 * it pops the previously "undone" data from the redo stack and pushes them back onto the main stack.
 * Logic can then peek at the main stack to get the data for the redo command.
 */
class History {
	// The main History stack
	private ArrayDeque<ArrayList<ArrayList<Task>>> taskStack;
	private ArrayDeque<ArrayList<TagCategory>> tagStack;
	
	// The redo stack that temporarily holds data popped from the main stack
	private ArrayDeque<ArrayList<ArrayList<Task>>> redoTaskStack;
	private ArrayDeque<ArrayList<TagCategory>> redoTagStack;

	History() {
		taskStack = new ArrayDeque<ArrayList<ArrayList<Task>>>();
		tagStack = new ArrayDeque<ArrayList<TagCategory>>();
		
		redoTaskStack = new ArrayDeque<ArrayList<ArrayList<Task>>>();
		redoTagStack = new ArrayDeque<ArrayList<TagCategory>>();
	}

	boolean taskStackIsEmpty() {
		return taskStack.isEmpty();
	}
	
	boolean tagStackIsEmpty() {
		return tagStack.isEmpty();
	}

	/*========*
	 * Adders *
	 *========*/
	/**
```
###### taskey\src\taskey\logic\History.java
``` java
	 * This method pops the last undid task lists and tag list from their respective redo stacks,
	 * and pushes them back onto the main history stacks.
	 * Logic can then peek at the main stack to redo the previously undid command.
	 * @return false if there is nothing to redo; true if successful
	 */
	boolean redo() {	
		try {
			ArrayList<ArrayList<Task>> undidTasks = redoTaskStack.pop();
			ArrayList<TagCategory> undidTags = redoTagStack.pop();
			taskStack.push(undidTasks);
			tagStack.push(undidTags);
		} catch (NoSuchElementException e) {
			return false;
		}
		return true;
	}
	
	/**
	 * Clear history's stacks. This is done after Logic loads from a new directory.
	 * Logic must call its updateHistory() method immediately after History is cleared,
	 * to ensure that History isn't left empty.
	 */
	void clear() {
		taskStack.clear();
		tagStack.clear();
		redoTaskStack.clear();
		redoTagStack.clear();
	}
}
```
###### taskey\src\taskey\logic\LogicMemory.java
``` java
	 * @throws LogicException if the directory could not be created or is invalid; an error occurred while moving files; or
	 * 						  savefiles already exist in the given directory (this is a signal for Logic to load these files)
	 */
	void changeSaveDirectory(String pathName) throws LogicException {
		try {
			storage.setDirectory(pathName, true); //true to move files
		} catch (FileAlreadyExistsException fae) { //new directory contains existing tasks data files
			try {
				storage.setDirectory(pathName, false); //prepare Storage to load from the new directory
			} catch (Exception e) { //pathName has already been verified at this point, so nothing should be thrown here
				throw new LogicException(LogicException.MSG_ERROR_SETDIR);
			}
			initializeTaskLists(); //load from the new directory
			initializeTagCategoryList();
			
			// The following exception message signals that LogicMemory has loaded from the new directory.
			// This is to tell Logic to clear History's stacks and add the newly loaded lists to History.
			throw new LogicException(LogicException.MSG_SUCCESS_SETDIR_LOAD);
			
		} catch (InvalidPathException e) { //path contains invalid characters
			throw new LogicException(e.getMessage());
			
		} catch (NotDirectoryException e) { //path goes to a file and not a directory
			throw new LogicException("The given path is not a directory: " + e.getMessage());
			
		} catch (AccessDeniedException e) { //access denied when creating a directory or writing a file
			throw new LogicException("Access denied to " +
									Paths.get((e.getOtherFile() == null) ? e.getFile() : e.getOtherFile()).getParent());
			
		} catch (FileSystemException e) { //reserved/illegal filename or nonexistent root drive letter
			throw new LogicException(e.getMessage());
			
		} catch (IOException ioe) { //any other IO error while creating a directory or writing a file
			throw new LogicException(ioe.getMessage());
			
		} catch (Exception e) { //unknown exception
			throw new LogicException(LogicException.MSG_ERROR_SETDIR);
		}
	}
	
	/**
```
###### taskey\src\taskey\storage\DataVerifier.java
``` java
 * This class is used by StorageReader to check the validity of the task and tag lists read from file,
 * in case the user makes mistakes while editing them.
 * It also checks whether the date(s) in the files have been edited and sets them accordingly.
 */
class DataVerifier {
	TimeConverter timeConverter = new TimeConverter();
	
	DataVerifier() {
	}
	
	@SuppressWarnings("serial")
	class InvalidTaskException extends Exception {
	}
	@SuppressWarnings("serial")
	class InvalidTagException extends Exception {
	}

	/**
	 * Sanity check for when reading a tasklist. Checks that all Task objects in a given list are valid.
	 * The only field that needs to be checked to prevent program from crashing is the task type.
	 * @param tasklist the tasklist to be checked
	 * @throws InvalidTaskException when the taskType is null or invalid
	 */
	void verifyTasks(ArrayList<Task> tasklist) throws InvalidTaskException {
		for (Task task : tasklist) {
			if (task.getTaskType() == null) {
				throw new InvalidTaskException();
			} else if (! (task.getTaskType().equalsIgnoreCase("FLOATING")
					|| task.getTaskType().equalsIgnoreCase("DEADLINE") 
					|| task.getTaskType().equalsIgnoreCase("EVENT")) ) {
				throw new InvalidTaskException();
			}
			//TODO check and count tags
		}
	}
	
	/**
	 * Sanity check for when reading a taglist. Checks that all tag objects in the given list are valid.
	 * The tag name cannot be null or it will cause UI to crash due to NullPointerException.
	 * @param taglist the tag list to be checked
	 * @throws InvalidTagException if any tagName field is null
	 */
	void verifyTags(ArrayList<TagCategory> taglist) throws InvalidTagException {
		for (TagCategory tag : taglist) {
			if (tag.getTagName() == null) {
				throw new InvalidTagException();
			}
			//TODO update tags
		}
	}

	/**
	 * Checks whether any Task in the given tasklist has had their dates/times changed 
	 * by the user editing the JSON files. If so, then the Task's epoch date(s) will be modified
	 * to match the human-readable time. This assumes that any user editing the files would be
	 * changing the human-readable dates, and not the epoch dates.
	 * The reason this check needs to be done is that Taskey only uses epoch time in its
	 * internal implementation; without this check, human readable dates would be ignored.
	 * @param tasklist the list of tasks to be checked
	 */
	void checkDates(ArrayList<Task> tasklist) {
		String humanTime;
		long epochTime;

		for (Task task : tasklist) {
			String taskType = task.getTaskType();

			switch (taskType.toUpperCase()) {
				case "DEADLINE":
					humanTime = task.getDeadlineFull(); //HH:mm by default in Taskey (or up to HH:mm:ss if user-edited)
					epochTime = task.getDeadlineEpoch(); //the original time with precision in seconds

					if (timeWasEdited(humanTime, epochTime)) {
						epochTime = getEpochTime(humanTime, epochTime);
						task.setDeadline(epochTime);
					}
					break;

				case "EVENT":
					// Check start time of event
					humanTime = task.getStartDateFull();
					epochTime = task.getStartDateEpoch();
					if (timeWasEdited(humanTime, epochTime)) {
						epochTime = getEpochTime(humanTime, epochTime);
						task.setStartDate(epochTime);
					}

					// Check end time of event
					humanTime = task.getEndDateFull();
					epochTime = task.getEndDateEpoch(); 
					if (timeWasEdited(humanTime, epochTime)) {
						epochTime = getEpochTime(humanTime, epochTime);
						task.setEndDate(epochTime);
					}
					break;
			}
		}
	}

	/**
	 * Returns true if the given human and epoch times are NOT equivalent.
	 * I.e. this means that one of them has been edited by the user.
	 * Assume that the one edited by the user is the human time.
	 * @param humanTime user-editable human time in HH:mm (or HH:mm:ss)
	 * @param epochTime in seconds. Hence the precision will be >= that of human time.
	 * @return true if not equal (edited); false if equal (unedited)
	 */
	private boolean timeWasEdited(String humanTime, long epochTime) {
		if (! humanTime.equals(timeConverter.toHumanTime(epochTime)) ) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Attempts to convert the given human time to its epoch equivalent.
	 * If failed, the given epochTime will be returned instead.
	 * @param humanTime user-editable human time in HH:mm (or HH:mm:ss)
	 * @param epochTime this will always have a precision in seconds 
	 * @return the epoch time converted from the given human time;
	 * 		   otherwise, if there is a parse error, the given epochTime will be returned instead
	 */
	private long getEpochTime(String humanTime, long epochTime) {
		System.out.println();
		System.out.println("{Storage} A date was edited. Converting:");
		System.out.println("[BEFORE] " + new Date(epochTime * 1000));

		long convertedEpoch;
		try {
			String[] tokens = humanTime.split(":"); 
			if (tokens.length == 2) {
				// Time was given in HH:mm format, but HH:mm:ss is needed for TimeConverter
				convertedEpoch = timeConverter.toEpochTime(humanTime + ":00");
			} else if (tokens.length == 3) {
				// Time is in HH:mm:ss format
				convertedEpoch = timeConverter.toEpochTime(humanTime);
			} else {
				throw new ParseException("Wrong human date format", 0);
			}
		} catch (ParseException e) {
			e.printStackTrace();
			System.err.println("{Storage} Invalid user-edited date");
			return epochTime;
		}

		System.out.println("[AFTER]  " + new Date(convertedEpoch * 1000));
		return convertedEpoch;
	}

}
```
###### taskey\src\taskey\storage\DirectoryManager.java
``` java
 * This class provides two methods to Storage for managing its directory:
 *  - createDirectory(File)
 *  - changeDirectory(File, boolean, File)
 */
class DirectoryManager {
	// For remembering the directories created during runtime,
	// so that DirectoryManager can delete them when they are no longer needed
	private HashSet<File> directoriesCreated = new HashSet<File>();
	private StorageWriter storageWriter = new StorageWriter();

	DirectoryManager() {
	}

	/**
	 * Quietly creates the full directory path of the given abstract pathname and also checks that it is valid.
	 * @param dir directory to be created
	 * @return true if the directory was successfully created or already exists;
	 * 		   false if mkdirs() failed or dir exists but is not a directory
	 */
	boolean createDirectory(File dir) {
		if (!dir.exists()) {
			if (dir.mkdirs() == true) {
				directoriesCreated.add(dir);
				return true;
			} else { //mkdirs() failed
				return false;
			}
		} else if (dir.isDirectory()) { //dir already exists && is a directory
			return true;
		} else { //dir exists but is not a directory
			return false;
		}
	}

	/**
	 * <p> This method does the following in sequence:
	 * <br>1. Checks the validity of the new directory
	 * <br>2. If the given boolean argument is true, taskey files in the current directory will be moved to the new one.
	 *		  However, if the new directory contains existing task file(s), this method will signal Logic to load them.
	 * <br>3. Delete the old directory, if it is empty and was created by Taskey during runtime.
	 * <br>4. Saves the new directory to the directory config file.
	 * 
	 * <p>Post-conditions:
	 * <br>- Creates the directory if it does not exist yet.
	 * <br>- If requested, taskey savefiles from the current directory will be moved to the new one, 
	 * 		 provided that the new directory does not contain pre-existing task file(s).
	 * <br>- The old folder will be deleted if it was created during runtime and is currently empty.
	 * <br>- The new directory setting will be saved to a persistent config file in "user.dir".
	 * <br>- Storage's directory will not be updated if any exceptions are thrown.
	 * 
	 * @param pathname can be absolute, or relative to "user.dir"
	 * @param shouldMove <code>true</code> if the move operation should be performed; 
	 * 					 <code>false</code> to update Storage's directory without moving the files (see FileAlreadyExistsException).
	 * 
	 * @throws InvalidPathException when the path string cannot be converted to a Path because it contains invalid characters.
	 *
	 * @throws NotDirectoryException when the path points to a normal file and not a directory.
	 * 
	 * @throws AccessDeniedException if creating a new directory or writing to an existing one was denied by the Windows file system.
	 * 
	 * @throws FileSystemException if the path contains a reserved/illegal filename or the root directory doesn't exist.
	 * 
	 * @throws FileAlreadyExistsException if the new directory already contains at least one tasklist file.
	 *		   This is a signal for Logic to call Storage.setDirectory(pathname, false) and then load from the new directory.
	 *		   (Passing in false will update Storage's directory and bypass FileAlreadyExistsException.)
	 * 
	 * @throws IOException any other IO error not covered above, when creating a new directory, writing to it, or moving files.
	 * 		   Note that moving is not an atomic operation, so it is possible that some files will have been moved halfway.
	 */
	File changeDirectory(File currDir, boolean shouldMove, File newDir) throws InvalidPathException, NotDirectoryException, 
																			   AccessDeniedException, FileSystemException, 
																			   FileAlreadyExistsException, IOException {
		createDirectoryLoudly(newDir);
		checkCanWriteToDirectory(newDir);

		if (shouldMove) {
			try {
				moveFiles(currDir, newDir);
			} catch (FileAlreadyExistsException e) {
				System.out.println("{Storage} Load from directory | " + newDir.getPath());
				throw e; //signal Logic to load the existing task files
			}
		}
		deleteCurrDir(currDir); //delete the old folder if it's currently empty and was created by Taskey during runtime

		if (shouldSaveNewDir(newDir, currDir)) {
			storageWriter.saveDirectoryConfigFile(newDir, FILENAME_DIRCONFIG);
		}

		return newDir;
	}

	/**
	 * This method attempts to create the full directory path of the given abstract pathname and throws exceptions when it fails.
	 * All known exceptions are enumerated in the throws clause of this method just for documentation purposes;
	 * except for InvalidPathException, the other exceptions are actually subclasses of IOException.
	 * @param dir directory to be created
	 * @throws InvalidPathException if dir contains illegal characters, e.g. * or ?
	 * @throws NotDirectoryException if dir points to a normal file and not a folder
	 * @throws AccessDeniedException if creation of dir was denied, e.g. trying to create a folder in c:\\program files
	 * @throws FileSystemException if dir contains an illegal filename in Windows, e.g. reserved words such as CON or PRN
	 * @throws IOException for any other reason not covered by the above exceptions
	 */
	private void createDirectoryLoudly(File dir) throws InvalidPathException, NotDirectoryException, 
														AccessDeniedException, FileSystemException,
														IOException {
		Path path = dir.toPath(); //throws InvalidPathException for illegal characters
		try {
			if (!dir.exists()) {
				Files.createDirectories(path);
				directoriesCreated.add(dir);
			} else {
				Files.createDirectories(path);
			}
		} catch (FileAlreadyExistsException e) { //dir exists but is not a directory
			throw new NotDirectoryException(dir.getPath());
		} catch (AccessDeniedException e) { //WindowsFileSystemProvider denied creation of dir
			throw e;
		} catch (FileSystemException e) { //illegal or reserved filename
			throw e;
		} catch (IOException e) { //whatever else
			e.printStackTrace();
			throw e;
		}
	}

	/**
	 * Checks whether a file can be written to the given directory.
	 * @param dir directory in which the test file will be created
	 * @throws AccessDeniedException if the test file cannot be created
	 * @throws IOException test file already exists or some other reason
	 */
	private void checkCanWriteToDirectory(File dir) throws AccessDeniedException, IOException {
		try {
			File testFile = new File(dir, "DeleteMe.Taskey");
			testFile.delete();
			Files.createFile(testFile.toPath());
			testFile.delete();
		} catch (AccessDeniedException e) {
			throw e;
		} catch (FileAlreadyExistsException e) { //test file already exists
			System.err.println(e.getMessage());
		} catch (IOException e) { //whatever else
			e.printStackTrace();
			throw e;
		}
	}

	/**
	 * Moves the taskey savefiles from the given source to destination directory.
	 * This method has no effect if srcDir and destDir are the same.
	 * Files are moved only if destDir does not contain any tasklist savefiles.
	 * @param srcDir the source directory
	 * @param destDir the destination diectory
	 * @returns true if all the files were moved successfully; false if no files were moved
	 * @throws IOException thrown by the Files.move method
	 * @throws FileAlreadyExistsException if tasklist files already exist in destDir
	 */
	private boolean moveFiles(File srcDir, File destDir) throws IOException, FileAlreadyExistsException {
		// Skip the move if srcDir and destDir are the same
		if (srcDir.getAbsolutePath().equalsIgnoreCase(destDir.getAbsolutePath())) {
			return false;
		}

		// If destDir contains pre-existing task file(s)
		// we do not want to inadvertently overwrite them, so we skip the move
		if (containsExistingTaskFilesIn(destDir)) {
			throw new FileAlreadyExistsException("Load from directory");
		}

		boolean wasMoved = false;
		for (File srcFile : srcDir.listFiles()) {
			if (Arrays.asList(Storage.FILENAMES).contains(srcFile.getName())) {
				Path srcPath = srcFile.toPath();
				Path destPath = destDir.toPath().resolve(srcFile.getName());

				try {
					Files.move(srcPath, destPath, StandardCopyOption.REPLACE_EXISTING);
					wasMoved = true;
				} catch (IOException e) {
					e.printStackTrace();
					throw e;
				}
			}
		}

		if (wasMoved) {
			System.out.println("{Storage} Files moved");
		}
		return wasMoved;
	}

	/**
	 * Checks if the given directory contains any tasklist savefile(s).
	 * @param dir directory to check
	 * @return true if any tasklist file was found; false otherwise
	 */
	private boolean containsExistingTaskFilesIn(File dir) {
		//EnumSet<TasklistEnum> set = EnumSet.noneOf(TasklistEnum.class);
		for (String filename : dir.list()) {
			TasklistEnum listType = TasklistEnum.enumOf(filename);
			if (TasklistEnum.savedLists.contains(listType)) {
				return true;
				//set.add(listType);
			}
		}
		return false;

		/*//Not used - For checking that dir contains ALL tasklists
		if (set.equals(TasklistEnum.savedLists)) {
			return true; //all tasklist files are present in dir
		} else {
			return false;//at least one tasklist file is missing
		}
		*/
	}

	/**
	 * Deletes the current Storage directory if it was created during runtime and is currently empty.
	 * This method should only be used in the changeDirectory method.
	 * @param currDir the old directory to be deleted before setting the new one
	 */
	private void deleteCurrDir(File currDir) {
		if (directoriesCreated.contains(currDir) && (currDir.list().length == 0)) {
			try {
				Files.delete(currDir.toPath());
				directoriesCreated.remove(currDir);
				System.out.println("{Storage} Old directory deleted | " + currDir.getPath());
			} catch (Exception e) {
				System.err.println("{Storage} Could not delete old directory | " + currDir.getPath());
			}
		}
	}

	/**
	 * Checks whether the abstract pathname given by dir should be saved to the directory config file.
	 * @param newDir the candidate directory to be saved
	 * @param currDir the old directory that is used for comparison
	 * @return true if dir is different from the current directory;
	 * 		   false if dir is the default directory or is the same as the current directory
	 */
	private boolean shouldSaveNewDir(File newDir, File currDir) {
		// If dir is equal to the default directory, we can delete the config file
		// since Storage does not need it to remember it.
		if (newDir.getAbsolutePath().equalsIgnoreCase(DEFAULT_DIRECTORY.getAbsolutePath())) {
			File configFile = new File(FILENAME_DIRCONFIG);
			try {
				Files.deleteIfExists(configFile.toPath());
				return false;
			} catch (IOException e) {
				e.printStackTrace();
				return false;
				//return true; //(?)since delete failed, return true to save it(?)
			}
		}

		// Check that dir is different from the current directory
		if (! newDir.getAbsolutePath().equalsIgnoreCase(currDir.getAbsolutePath()) ) {
			return true;
		} else {
			return false;
		}
	}
}
```
###### taskey\src\taskey\storage\Storage.java
``` java
 * This class exposes public methods for:
 * - Saving/loading task lists
 * - Saving/loading tags
 * - Setting the Storage directory
 */
public class Storage {
	private StorageReader storageReader;
	private StorageWriter storageWriter;
	private DirectoryManager directoryManager;
	private File directory;

	public static final File DEFAULT_DIRECTORY = new File("Taskey savefiles"); //public for unit test
	public static final String FILENAME_TAGS = "TAGS.taskey";
	public static final String FILENAME_DIRCONFIG = "directory_setting.taskeyconfig";
	public static final int NUM_TASKLISTS_FROM_LOGIC = taskey.logic.LogicMemory.NUM_TASK_LISTS;
	
	public static final String[] FILENAMES;
	// This array contains all the savefile names used in storage
	static {
		FILENAMES = new String[TasklistEnum.savedLists.size() + 1];
		int i = 0;
		for (TasklistEnum listType : TasklistEnum.savedLists) {
			FILENAMES[i++] = listType.filename();
		}
		FILENAMES[i] = FILENAME_TAGS;
	}

	/**
	 * This is an enum of all the task lists that are handled by Storage, together with their filenames.
	 * That is, these are the task lists that need to be returned from Storage to Logic during load.
	 * However, not all of these task lists are saved to file:
	 * Only lists in the EnumSet savedLists are actually written to file; the rest are derived from the PENDING list.
	 * The index refers to the index of each list in the list of lists (the "superlist") from Logic.
	 * In the superlist from Logic, index 0 (THIS_WEEK list) and 7 (ACTION list) are not handled by Storage
	 */
	public enum TasklistEnum {
		PENDING		("PENDING.taskey", 1),
		EXPIRED		("EXPIRED.taskey", 2),
		GENERAL		("GENERAL.taskey", 3),	//not saved
		DEADLINE	("DEADLINE.taskey", 4),	//not saved
		EVENT		("EVENT.taskey", 5),	//not saved
		COMPLETED	("ARCHIVE.taskey", 6);

		static final EnumSet<TasklistEnum> savedLists = EnumSet.of(PENDING, EXPIRED, COMPLETED);
		static final int size = TasklistEnum.values().length;

		private final String filename;
		private final int index;

		TasklistEnum(String filename, int index) {
			this.filename = filename;
			this.index = index;
		}

		public static int size() {
			return size;
		}

		public String filename() {
			return filename;
		}

		public int index() {
			return index;
		}

		/**
		 * Returns the enum type corresponding to the given index i,
		 * or null if the given index does not appear in TaskListEnum.
		 */
		public static TasklistEnum enumOf(int i) {
			for (TasklistEnum enumType : TasklistEnum.values()) {
				if (enumType.index == i) {
					return enumType;
				}
			}
			return null;
		}

		/**
		 * Returns the enum type corresponding to the given filename string,
		 * or null if the given filename does not exist in TaskListEnum.
		 */
		public static TasklistEnum enumOf(String fileName) {
			for (TasklistEnum enumType : TasklistEnum.values()) {
				if (enumType.filename.equals(fileName)) {
					return enumType;
				}
			}
			return null;
		}
	}


	/**
	 * Storage constructor and initializer.
	 * Attempts to load and set the last used directory.
	 * If none was found, DEFAULT_DIRECTORY will be set instead.
	 * Post-condition: all the fields of Storage have been instantiated.
	 */
	public Storage() {
		storageReader = new StorageReader();
		storageWriter = new StorageWriter();
		directoryManager = new DirectoryManager();

		File loadedDirectory = storageReader.loadDirectoryConfigFile(FILENAME_DIRCONFIG);
		if (loadedDirectory != null) {
			if (directoryManager.createDirectory(loadedDirectory) == true) {
				directory = loadedDirectory;
				System.out.println("{Storage} Directory loaded | " + directory.getAbsolutePath());
			} else { //loaded directory was invalid or could not be created
				directoryManager.createDirectory(DEFAULT_DIRECTORY);
				directory = DEFAULT_DIRECTORY;
			}
		} else { //directory config file was not found
			directoryManager.createDirectory(DEFAULT_DIRECTORY);
			directory = DEFAULT_DIRECTORY;
		}
	}


	/*=====================*
	 * Load/Save tasklists *
	 *=====================*/
	/**
	 * Returns the list of task lists loaded from Storage.
	 * Logic calls this on program startup, or when the user loads from a directory using the setdir command.
	 * <p>Post-conditions:
	 * <br>- The lists in the returned superlist are in the same order as the enum constants in TasklistEnum.
	 * <br>- These lists do not include the THIS_WEEK and ACTION list.
	 * <br>- If any single list was not found, or is invalid, an empty list is added in its place.
	 * @return the list of tasklists read from disk, some or all of which may be empty
	 */
	public ArrayList<ArrayList<Task>> loadAllTasklists() {
		ArrayList<ArrayList<Task>> superlist = new ArrayList<ArrayList<Task>>();

		for (TasklistEnum listType : TasklistEnum.values()) {
			File src = new File(directory, listType.filename());
			ArrayList<Task> loadedList = storageReader.loadTasklist(src, listType);
			superlist.add(loadedList);
		}
		return superlist;
	}

	/**
	 * Saves the PENDING, EXPIRED and COMPLETED lists of the given superlist to file.
	 * If any of the above lists are empty, instead of saving an empty list, the file will be deleted instead.
	 * These savefiles are mutually exclusive hence any one of them can be safely deleted.
	 * <p>Pre-conditions:
	 * <br>- Starting from index 1, the lists in the given superlist
	 * 		 must be in the same order as the enum constants in TasklistEnum.
	 * <br>- Index 0 is reserved for the THIS_WEEK list and is not saved to disk because it is time-dependent.
	 * <br>- Index 7 is reserved for the ACTION list and is not saved to disk because it is session-dependent.
	 * <br>- The GENERAL, DEADLINE and EVENT lists are not saved because they can be derived from the PENDING list.
	 * @param superlist the list of tasklists to be saved
	 * @throws IOException when FileWriter fails to write any single list to file
	 */
	public void saveAllTasklists(ArrayList<ArrayList<Task>> superlist) throws IOException {
		assert (superlist.size() == NUM_TASKLISTS_FROM_LOGIC);

		for (TasklistEnum listType : TasklistEnum.savedLists) {
			File dest = new File(directory, listType.filename());
			ArrayList<Task> listToSave = superlist.get(listType.index());
			try {
				storageWriter.saveTasklist(listToSave, dest);
			} catch (FileNotFoundException e) {
				directoryManager.createDirectory(directory);  //in case user deletes the directory during runtime
				storageWriter.saveTasklist(listToSave, dest); //recreate the directory and try again
			}
		}
	}


	/*================*
	 * Load/Save tags *
	 *================*/
	/**
	 * Returns the ArrayList of Tags loaded from Storage.
	 * An empty ArrayList is returned if the tags file was not found.
	 * @return the list of user-defined tags
	 */
	public ArrayList<TagCategory> loadTaglist() {
		File src = new File(directory, FILENAME_TAGS);
		return storageReader.loadTaglist(src);
	}

	/**
	 * Saves the given ArrayList of Tags to Storage.
	 * If the list is empty, instead of saving an empty list, the file will be deleted instead.
	 * @param tags the ArrayList containing the user-defined tags
	 * @throws IOException FileWriter failed
	 */
	public void saveTaglist(ArrayList<TagCategory> tags) throws IOException {
		assert (tags != null);
		File dest = new File(directory, FILENAME_TAGS);
		storageWriter.saveTaglist(tags, dest);
	}


	/*===============*
	 * Set Directory *
	 *===============*/
	/**
	 * Has the same effect as calling {@link #setDirectory(File, boolean) setDirectory(pathname, true)}
	 */
	public void setDirectory(String pathname) throws InvalidPathException, IOException {
		setDirectory(pathname, true);
	}


	/**
	 * Changes Storage's directory to the given pathname string.
	 * See {@link DirectoryManager#changeDirectory(File, boolean, File)}
	 * @param pathname path of the new directory
	 * @param shouldMove <code>true</code> if the move operation should be performed; 
	 * 					 <code>false</code> to set Storage's directory without moving the files.
	 */
	public void setDirectory(String pathname, boolean shouldMove) throws InvalidPathException, NotDirectoryException, 
																		 AccessDeniedException, FileSystemException, 
																		 FileAlreadyExistsException, IOException {
		File newDir = new File(pathname);
		directory = directoryManager.changeDirectory(directory, shouldMove, newDir);
		System.out.println("{Storage} Directory set | " + directory.getPath());
	}


	/*=============*
	 * For testing *
	 *=============*/
	/*
	public static void main(String args[]) throws Exception {
		Storage storage = new Storage();
		storage.setDirectory("con"); //invalid
		ArrayList<ArrayList<Task>> loadedLists = storage.loadAllTasklists();
		print(loadedLists);
	}

	private static void print(ArrayList<ArrayList<Task>> lists) {
		int i=1;
		for (ArrayList<Task> list : lists) {
			System.out.println(TasklistEnum.enumOf(i++) + " LIST");
			for (Task t : list) {
				System.out.println(t);
			}
		}
		System.out.println("end print");
	}
	*/
}
```
###### taskey\src\taskey\storage\StorageReader.java
``` java
 * This class provides methods to Storage for 
 * reading tasklists, taglists and abstract paths from their JSON files.
 * It also uses DataVerifier to perform input validation on the Task and 
 * TagCategory objects read from file.
 * This class is public so that it is visible to taskey.junit.StorageTest
 */
public class StorageReader {
	DataVerifier verifier = new DataVerifier();

	/**
	 * These three lists are derived from the PENDING list.
	 * They are not read from, or written to, disk.
	 */
	enum DerivedList {
		GENERAL_TASKLIST (new ArrayList<Task>()),
		DEADLINE_TASKLIST (new ArrayList<Task>()),
		EVENT_TASKLIST (new ArrayList<Task>());

		private ArrayList<Task> tasklist;

		private DerivedList(ArrayList<Task> list) {
			tasklist = list;
		}

		private void add(Task t) {
			tasklist.add(t);
		}

		private ArrayList<Task> get() {
			return tasklist;
		}

		private static void clearAllLists() {
			for (DerivedList list : DerivedList.values()) {
				list.get().clear();
			}
		}
	}

	/**
	 * Generic read method.
	 * Deserializes the JSON file specified by src into an object of the specified type.
	 * @param src JSON file to be read
	 * @param typeToken represents the generic type T of the desired object; 
	 * 		  this is obtained from the Gson TypeToken class
	 * @return An object of type T generated from the JSON file.
	 * @throws FileNotFoundException if FileReader constructor fails due to it being unable 
	 * 		   to open the file for reading. This could be because the file doesn't exist or access was denied.
	 * @throws JsonParseException fromJson throws JsonIOException, JsonSyntaxException
	 */
	private <T> T readFromFile(File src, TypeToken<T> typeToken) throws FileNotFoundException, 
																		JsonParseException {
		FileReader reader = new FileReader(src);
		Gson gson = new Gson();
		T object;
		try {
			object = gson.fromJson(reader, typeToken.getType());
		} catch (JsonParseException e) {
			throw e;
		} finally {
			try {
				reader.close(); //must close the stream to allow deleting/moving of files
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		if (object == null) {
			throw new JsonParseException("fromJson returned null due to EOF i.e. file was empty");
		}
		return object;
	}

	/*============*
	 * Load tasks *
	 *============*/
	/**
	 * Returns the ArrayList of Task objects read from the File src.
	 * The GENERAL/DEADLINE/EVENT lists are not read from file;
	 * instead, they are derived from the PENDING list.
	 * <p>Pre-condition:
	 * <br>- the PENDING list must be read before the derived lists, 
	 * 		 so that the derived lists in the enum are populated first.
	 * @param src the source file to be read from
	 * @param tasklistType the TasklistEnum constant passed from Storage
	 * @return the tasklist read from file or an empty tasklist if file was not found/is invalid
	 */
	ArrayList<Task> loadTasklist(File src, TasklistEnum tasklistType) {
		ArrayList<Task> tasklist;
		switch (tasklistType) {
			default: //default case is just to avoid compilation error
			case PENDING:
			case EXPIRED:
			case COMPLETED:
				try {
					tasklist = readFromFile(src, new TypeToken<ArrayList<Task>>() {});
					verifier.verifyTasks(tasklist);
					verifier.checkDates(tasklist);
				} catch (InvalidTaskException | JsonParseException e) {
					e.printStackTrace();
					System.err.println("{Storage} Invalid tasklist: " + src.getName());
					renameBadFile(src);
					tasklist = new ArrayList<Task>(); //return empty list
				} catch (FileNotFoundException e) {
					tasklist = new ArrayList<Task>();
				}

				if (tasklistType == PENDING) {
					// Generate the GENERAL, DEADLINE and EVENT lists from the PENDING list
					getDerivedLists(tasklist);
				}
				break;

			case GENERAL:
				return GENERAL_TASKLIST.get();
			case DEADLINE:
				return DEADLINE_TASKLIST.get();
			case EVENT:
				return EVENT_TASKLIST.get();
		}
		return tasklist;
	}

	/**
	 * Renames the given file, which could be invalid due to a malformed JSON or invalid tasks.
	 * This is done so that if the user makes a mistake while editing the task files,
	 * they can still recover it, instead of losing them when they get overwritten 
	 * the next time the user saves (which happens on program close!).
	 * @param src abstract path of the bad file
	 */
	private void renameBadFile(File src) {
		try {
			Files.move(src.toPath(), src.toPath().resolveSibling("INVALID." + src.getName()), 
					StandardCopyOption.REPLACE_EXISTING);
		} catch (IOException e) {
			System.err.println("{Storage} Could not rename bad file");
			e.printStackTrace();
		}
	}

	/**
	 * Derives the GENERAL, DEADLINE, and EVENT tasklists from the PENDING list.
	 * Post-condition: the tasklists in the enum DerivedList are all populated
	 * @param pendingList the PENDING list
	 */
	private void getDerivedLists(ArrayList<Task> pendingList) {
		DerivedList.clearAllLists(); //erase the previous data, if any
		for (Task task : pendingList) {
			switch (task.getTaskType().toUpperCase()) {
				case "FLOATING":
					GENERAL_TASKLIST.add(task);
					break;
				case "DEADLINE":
					DEADLINE_TASKLIST.add(task);
					break;
				case "EVENT":
					EVENT_TASKLIST.add(task);
					break;
			}
		}
	}

	/*===========*
	 * Load tags *
	 *===========*/
	/**
	 * Returns an ArrayList of Tags read from the File src.
	 * An empty ArrayList is returned if src was not found.
	 * @param src source file to be read
	 * @return the taglist read from file or an empty taglist if file was not found/is invalid
	 */
	ArrayList<TagCategory> loadTaglist(File src) {
		ArrayList<TagCategory> tags;
		try {
			tags = readFromFile(src, new TypeToken<ArrayList<TagCategory>>() {});
			verifier.verifyTags(tags);
		} catch (JsonParseException | InvalidTagException e) {
			e.printStackTrace();
			System.err.println("{Storage} Invalid taglist: " + src.getName());
			renameBadFile(src);
			tags = new ArrayList<TagCategory>(); //return empty list
		} catch (FileNotFoundException e) {
			tags = new ArrayList<TagCategory>();
		}
		return tags;
	}

	/*================*
	 * Load directory *
	 *================*/
	/**
	 * Tries to read the last-saved directory from the config file located in System.getProperty("user.dir").
	 * @param filename name of the config file to be read
	 * @return the File representing the last-saved directory, or null if it was not found
	 */
	public File loadDirectoryConfigFile(String filename) {
		File src = new File(filename);
		try {
			//FIXME: buggyPath will somehow always have user.dir prepended to its absolute path
			File buggyPath = readFromFile(src, new TypeToken<File>() {});
			File fixedPath = new File(buggyPath.getPath()); //kludge solution
			return fixedPath;
		} catch (FileNotFoundException e) {
			return null;
		}
	}
}
```
###### taskey\src\taskey\storage\StorageWriter.java
``` java
 * This class provides methods to classes in the storage package
 * for writing tasklists, taglists and abstract paths to file in the JSON format.
 * This class is public so that it is visible to taskey.junit.StorageTest
 */
public class StorageWriter {
	/**
	 * Generic write method.
	 * Serializes the given object of the specified type into its equivalent JSON representation.
	 * @param dest the abstract path of the JSON file to be written
	 * @param object of type T to be serialized
	 * @param typeToken represents the generic type T of the given object;
	 * 		  this is obtained from the Gson TypeToken class
	 * @throws IOException thrown by FileWriter
	 */
	private <T> void writeToFile(File dest, T object, TypeToken<T> typeToken) throws IOException {
		FileWriter writer = new FileWriter(dest);
		Gson gson = new GsonBuilder().setPrettyPrinting().serializeNulls().create();
		String jsonOutput = gson.toJson(object, typeToken.getType());
		writer.write(jsonOutput);
		writer.close();
	}

	/*============*
	 * Save tasks *
	 *============*/
	/**
	 * Writes an ArrayList of Task objects to the File dest.
	 * The file will be created if it doesn't exist; otherwise the existing file will be overwritten.
	 * Only non-empty tasklists are saved.
	 * If the given tasklist is empty, its respective file will be deleted.
	 * @param tasks the tasklist to be saved
	 * @param dest the destination file to be written to
	 * @throws IOException thrown by FileWriter
	 */
	void saveTasklist(ArrayList<Task> tasks, File dest) throws IOException {
		try {
			if (!tasks.isEmpty()) {
				writeToFile(dest, tasks, new TypeToken<ArrayList<Task>>() {});
			} else {
				dest.delete(); //can safely delete empty tasklist
			}
		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		}
	}

	/*===========*
	 * Save tags *
	 *===========*/
	/**
	 * Saves the given ArrayList of tag objects to the File dest.
	 * The file will be created if it doesn't exist; otherwise the existing file will be overwritten.
	 * Only non-empty taglists are saved.
	 * If the given taglist is empty, its respective file will be deleted.
	 * @param tags the taglist to be saved
	 * @param dest the destination file to be written to
	 * @throws IOException thrown by FileWriter
	 */
	void saveTaglist(ArrayList<TagCategory> tags, File dest) throws IOException {
		try {
			if (!tags.isEmpty()) {
				writeToFile(dest, tags, new TypeToken<ArrayList<TagCategory>>() {});
			} else { //can safely delete empty taglist
				dest.delete();
			}
		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		}
	}

	/*================*
	 * Save directory *
	 *================*/
	/**
	 * Writes the given abstract path to a config file located in System.getProperty("user.dir").
	 * @param dir the File object representing the directory path to be saved
	 * @param filename name of the destination file
	 */
	public void saveDirectoryConfigFile(File dir, String filename) {
		File dest = new File(filename);
		try {
			writeToFile(dest, dir.getCanonicalFile(), new TypeToken<File>() {});
		} catch (IOException e) {
			e.printStackTrace();
			System.err.println("{Storage} Error saving new directory");
		}
	}
}
```
###### taskey\src\taskey\ui\content\views\UiHelpView.java
``` java
	 * This method sets up the the main help menu and then the pages within each sub-menu.
	 */
	private void setUpHelpView() {
		ArrayList<Pair<String, String>> mainMenuOptions = new ArrayList<Pair<String, String>>();
		// In the following key-value pairs, key is the option in the main menu and value is the description
		mainMenuOptions.add(new Pair<String, String>("Help main menu", "Use Page Up/Down and Enter to select.\n"
				+ "Press Enter in any submenu to return to the main menu"));
		mainMenuOptions.add(new Pair<String, String>("Add", "How to add tasks"));
		mainMenuOptions.add(new Pair<String, String>("Delete", "How to delete tasks"));
		mainMenuOptions.add(new Pair<String, String>("Set", "How to edit tasks"));
		mainMenuOptions.add(new Pair<String, String>("Done", "How to complete tasks"));
		mainMenuOptions.add(new Pair<String, String>("Search", "How to search for tasks"));
		mainMenuOptions.add(new Pair<String, String>("Undo", "How to undo your last action"));
		mainMenuOptions.add(new Pair<String, String>("Tags", "How to add tasks with tags"));
		mainMenuOptions.add(new Pair<String, String>("View", "How to filter pending tasks by type"));
		addMainMenu(mainMenuOptions);
		
		ArrayList<EnumSet<ImageID>> helpImageSets_byCategory = new ArrayList<EnumSet<ImageID>>();
		helpImageSets_byCategory.add(ImageID.getHelpImageSet_Add());
		helpImageSets_byCategory.add(ImageID.getHelpImageSet_Del());
		helpImageSets_byCategory.add(ImageID.getHelpImageSet_Edit());
		helpImageSets_byCategory.add(ImageID.getHelpImageSet_Done());
		helpImageSets_byCategory.add(ImageID.getHelpImageSet_Search());
		helpImageSets_byCategory.add(ImageID.getHelpImageSet_Undo());
		helpImageSets_byCategory.add(ImageID.getHelpImageSet_Tag());
		helpImageSets_byCategory.add(ImageID.getHelpImageSet_View());
		
		for (EnumSet<ImageID> helpImageSet : helpImageSets_byCategory) {
			ArrayList<Pair<ImageID, String>> subMenuPages = new ArrayList<Pair<ImageID, String>>();
			for (ImageID imageID : helpImageSet) {
				//Each page in a submenu consists of an image and its caption
				subMenuPages.add(new Pair<ImageID, String>(imageID, imageID.getCaption()));
			}
			addMenu(subMenuPages);
		}
	}

	/**
```
###### taskey\src\taskey\ui\utility\UiImageManager.java
``` java
	 * This class enumerates all the images used in the GUI.
	 * It encapsulates the filenames of each image, and in particular, the captions associated with each help image.
	 * For convenience, static EnumSets for each category of help image are provided;
	 * these can be accessed through public getter methods.
	 */
	public enum ImageID {
		WINDOW_ICON		("windowIcon.png"),
		CROSS_DEFAULT	("crossDefault.png"),
		CROSS_SELECT	("crossSelect.png"),
		MINUS_DEFAULT	("minusDefault.png"),
		MINUS_SELECT	("minusSelect.png"),
		URGENT_MARK		("urgentMark.png"),
		FLOATING		("floating.png"),
		DEADLINE		("deadline.png"),
		EVENT			("event.png"),
		
		// Help images
		ADD1_FLOAT			("add1_Float.png", "Type: add <task name> to add a general task"),
		ADD2_DEADLINE_TMR	("add2_DeadlineTmr.png", "Type: add <task name> on/by <date> to add a deadline."),
		ADD3_DEADLINE_DATE	("add3_DeadlineDate.png", "<date> can also be a calendar date in (D)D MMM (YYYY) format"),
		ADD4_EVENT			("add4_Event.png", "Type: add <task name> from <date> to <date> to add an event.\n Press Enter to return"),
		
		DELETE1_ID	("delete1_ID.png", "Type: del <ID> to delete a task; ID is shown on the left."),
		DELETE2		("delete2.png", "That's it! Press Enter to return"),
		
		SET1_NONE		("set1_none.png", "Type: set <ID> [none] to remove a task's date(s)"),
		SET2_NONE		("set2_none.png", "The task has been changed to a general task"),
		SET3_DEADLINE	("set3_deadline.png", "Type: set <ID> [date] to set a task to have one date"),
		SET4_DEADLINE	("set4_deadline.png", "The task has been changed to a deadline"),
		SET5_NAME		("set5_name.png", "Type: set \"Name\" to change a task's name"),
		SET6_EVENT		("set6_event.png", "Type: set [start date, end date] to set an event"),
		SET7_BOTH		("set7_both.png", "Type: set \"Name\" [date] to change both the name and date at the same time. Press Enter to return"),
		
		DONE1	("done1.png", "Type: done <ID> to move a task to the archive"),
		DONE2	("done2.png", "That's it! Press Enter to return"),
		
		SEARCH1	("search1.png", "Type: search <phrase> to search for a task"),
		SEARCH2	("search2.png",  "Search results will be shown in the Action tab.\n Press Enter to return"),
		
		UNDO1	("undo1.png", "Type: undo to revert any changes made to your tasks"),
		UNDO2	("undo2.png", "That's it! Press Enter to return"),
		
		TAG1	("tag1.png", "When adding a task, type #<tag> at the end to tag it"),
		TAG2	("tag2.png", "The number of tags will be shown in the left pane"),
		TAG3	("tag3.png", "Type: view #<tag> to view all tasks with the given tag.\n Press Enter to return"),
		
		VIEW_BASIC		("view1_basic.png", "You can filter the pending tab by task type: general, deadlines and events"),
		VIEW_GENERAL	("view2_general.png", "Type: view general, to view pending general tasks"),
		VIEW_DEADLINE	("view3_deadlines.png", "Type: view deadlines, to view pending deadlines"),
		VIEW_EVENT		("view4_events.png", "Type: view events to view pending events.\n Press Enter to return");
		
		private static EnumSet<ImageID> helpImages = EnumSet.range(ADD1_FLOAT, VIEW_EVENT);
		private static EnumSet<ImageID> helpImages_Add = EnumSet.range(ADD1_FLOAT, ADD4_EVENT);
		private static EnumSet<ImageID> helpImages_Del = EnumSet.range(DELETE1_ID, DELETE2);
		private static EnumSet<ImageID> helpImages_Edit = EnumSet.range(SET1_NONE, SET7_BOTH);
		private static EnumSet<ImageID> helpImages_Done  = EnumSet.range(DONE1, DONE2);
		private static EnumSet<ImageID> helpImages_Search = EnumSet.range(SEARCH1, SEARCH2);
		private static EnumSet<ImageID> helpImages_Undo = EnumSet.range(UNDO1, UNDO2);
		private static EnumSet<ImageID> helpImages_Tag = EnumSet.range(TAG1, TAG3);
		private static EnumSet<ImageID> helpImages_View = EnumSet.range(VIEW_BASIC, VIEW_EVENT);
		
		private final String filename;
		private final String caption;
		
		// Constructor for the UI element images
		private ImageID(String filename) {
			this.filename = filename;
			this.caption = "";
		}
		
		// Constructor for the help images
		private ImageID(String filename, String helpText) {
			this.filename = filename;
			this.caption = helpText;
		}
		
		public String getCaption() {
			return caption;
		}
		
		public static EnumSet<ImageID> getHelpImageSet_Add() {
			return helpImages_Add;
		}
		public static EnumSet<ImageID> getHelpImageSet_Del() {
			return helpImages_Del;
		}
		public static EnumSet<ImageID> getHelpImageSet_Edit() {
			return helpImages_Edit;
		}
		public static EnumSet<ImageID> getHelpImageSet_Done() {
			return helpImages_Done;
		}
		public static EnumSet<ImageID> getHelpImageSet_Search() {
			return helpImages_Search;
		}
		public static EnumSet<ImageID> getHelpImageSet_Undo() {
			return helpImages_Undo;
		}
		public static EnumSet<ImageID> getHelpImageSet_Tag() {
			return helpImages_Tag;
		}
		public static EnumSet<ImageID> getHelpImageSet_View() {
			return helpImages_View;
		}
	}

```
###### taskey\src\taskey\ui\utility\UiImageManager.java
``` java
	 */
	private void loadHelpMenuImages() {
		for (ImageID helpImageID : ImageID.helpImages) {
			myImageContainer.put(helpImageID, 
					new Image(getClass().getResourceAsStream(helpFolder + helpImageID.filename)));
		}
	}
	
	/**
```
###### taskey\test\taskey\junit\StorageTest.java
``` java
 * Unit test for the Storage package/component.
 */
public class StorageTest {
	private static Storage storage = new Storage();
	private static File testDir = new File(Storage.DEFAULT_DIRECTORY, "temp_test");
	private static File originalDirConfigFile; //to hold the existing directory config file until end of tests

	/**
	 * Enum of all the task lists that are passed from Logic to Storage.
	 * taskListsFromStorage is the set of lists that are returned from Storage to Logic on load.
	 * derivedLists is the set of lists that are derived from the pending list instead of being loaded from disk.
	 */
	enum TaskList {
		THIS_WEEK	(new ArrayList<Task>()), //ignored by Storage
		PENDING 	(new ArrayList<Task>()), //saved to disk
		EXPIRED 	(new ArrayList<Task>()), //saved to disk
		FLOATING 	(new ArrayList<Task>()), //derived from pending list
		DEADLINE 	(new ArrayList<Task>()), //derived from pending list
		EVENT 		(new ArrayList<Task>()), //derived from pending list
		COMPLETED 	(new ArrayList<Task>()), //saved to disk
		ACTION		(new ArrayList<Task>()); //ignored by Storage

		//static EnumSet<TaskList> derivedLists = EnumSet.of(EVENT, DEADLINE, FLOATING);
		static EnumSet<TaskList> taskListsFromStorage = EnumSet.range(PENDING, COMPLETED);
		static TimeConverter timeConverter = new TimeConverter();

		private ArrayList<Task> tasklist;
		TaskList(ArrayList<Task> list) {
			tasklist = list;
		}

		void add(Task task) {
			tasklist.add(task);
		}

		ArrayList<Task> get() {
			return tasklist;
		}

		static void clearAllLists() {
			for (TaskList listType : TaskList.values()) {
				listType.tasklist.clear();
			}
		}

		/**
		 * Returns the list of tasklists currently in this enum.
		 */
		static ArrayList<ArrayList<Task>> getSuperlist() {
			ArrayList<ArrayList<Task>> superlist = new ArrayList<ArrayList<Task>>();
			for (TaskList tasklist : TaskList.values()) {
				superlist.add(tasklist.get());
			}
			return superlist;
		}

		/**
		 * Populate the lists in this enum with dummy task lists.
		 */
		static void populateLists() {
			for (TaskList list : TaskList.values()) {
				Task task = new Task();

				switch (list) {
					case PENDING:
						task.setTaskName("Float");
						task.setTaskType("FLOATING");
						task.setTaskTags(new ArrayList<String>(Arrays.asList(("tag"))));
						FLOATING.add(task);
						PENDING.add(task);
						
						task = new Task();
						task.setTaskName("Deadline");
						task.setTaskType("DEADLINE");
						task.setDeadline(timeConverter.getCurrTime());
						DEADLINE.add(task);
						PENDING.add(task);
						
						task = new Task();
						task.setTaskName("Event");
						task.setTaskType("EVENT");
						task.setStartDate(timeConverter.getCurrTime());
						task.setEndDate(timeConverter.getCurrTime());
						EVENT.add(task);
						PENDING.add(task);
						break;

					case EXPIRED:
						task.setTaskName("Expired task");
						task.setTaskType("FLOATING");
						EXPIRED.add(task);
						break;
						
					case COMPLETED:
						task.setTaskName("Completed task");
						task.setTaskType("FLOATING");
						COMPLETED.add(task);
						break;
						
					case THIS_WEEK: //ignored by Storage
						THIS_WEEK.add(task);
						break;
						
					case ACTION: //ignored by Storage
						ACTION.add(task);
						break;
						
					case DEADLINE: //these lists have already been added
					case EVENT:
					case FLOATING:
						break;
				}
			}
		}
	}

	/**
	 * Load the original directory config file (if present) into memory before the running the test.
	 * Otherwise, the file will be lost when overwritten during testing.
	 * @throws IOException
	 */
	@BeforeClass
	public static void setUpBeforeClass() throws IOException {
		originalDirConfigFile = new StorageReader().loadDirectoryConfigFile(Storage.FILENAME_DIRCONFIG);
		if (originalDirConfigFile == null) {
			System.out.println("[StorageTest] No existing directory config file");
		} else {
			System.out.println("[StorageTest] Existing directory config file found");
		}
		storage.setDirectory(testDir.getAbsolutePath(), false); //don't move savefiles to the test folder
	}

	/**
	 * Deletes files created during the test, the test directory, 
	 * and reverts the directory config file back to the original one (if present).
	 * @throws IOException
	 */
	@AfterClass
	public static void tearDownAfterClass() throws IOException {
		// Delete savefiles
		for (File file : testDir.listFiles()) {
			if (Arrays.asList(Storage.FILENAMES).contains(file.getName())) {
				File testfile = new File(testDir, file.getName());
				Files.delete(testfile.toPath());
			}
		}
		System.out.println("[StorageTest] All taskey test savefiles deleted");

		// Delete the test directory
		Files.deleteIfExists(testDir.toPath());
		System.out.println("[StorageTest] Test folder deleted");

		// Revert back to previous config file
		if (originalDirConfigFile != null) {
			System.out.println("[StorageTest] Reverting back to original directory");
			new StorageWriter().saveDirectoryConfigFile(originalDirConfigFile, Storage.FILENAME_DIRCONFIG);
		} else {
			// Else if there was no pre-existing config file, delete the one created in the test
			File testDirConfigFile = new File(Storage.FILENAME_DIRCONFIG);
			Files.delete(testDirConfigFile.toPath());
			System.out.println("[StorageTest] Test config file deleted");
		}
	}


	/*===========================*
	 * Test directory management *
	 *===========================*/
	/**
	 * Tests the exceptions thrown by DirectoryManager's changeDirectory method.
	 * @throws IOException
	 */
	@Test
	public void testSetDirectoryExceptions() throws IOException {
		try {
			storage.setDirectory("\\/:*?\"<>|");
			fail("InvalidPathException not thrown for invalid characters *");
		} catch (InvalidPathException e) {
		}

		try {
			storage.setDirectory(Storage.FILENAME_DIRCONFIG); //path to a file, not a directory
			fail("NotDirectoryException not thrown for paths that point to a file");
		} catch (NotDirectoryException e) {
		}

		try {
			storage.setDirectory(System.getenv("ProgramFiles") + "\\taskey_fubar"); //e.g. c:\program files\taskey_fubar
			fail("AccessDeniedException not thrown when creating folder in restricted directory");
		} catch (AccessDeniedException e) {
		}

		try {
			storage.setDirectory(Paths.get(System.getenv("ProgramFiles")).getRoot().toString()); //e.g. c:\
			fail("AccessDeniedException not thrown when creating files in restricted directory");
		} catch (AccessDeniedException e) {
		}

		try {
			storage.setDirectory("con");
			fail("FileSystemException not thrown for reserved filename");
		} catch (FileSystemException e) {
		}

		try {
			// Generate and save all task lists to the test directory
			TaskList.clearAllLists();
			TaskList.populateLists();
			storage.saveAllTasklists(TaskList.getSuperlist());

			// Change the storage directory (without moving files from the test directory)
			storage.setDirectory(Storage.DEFAULT_DIRECTORY.getAbsolutePath(), false);

			// Change back to the test directory and invoke DirectoryManager's moveFiles method, 
			// which will throw FileAlreadyExistsException
			storage.setDirectory(testDir.getAbsolutePath(), true);

			fail("FileAlreadyExistsException not thrown");
		} catch (FileAlreadyExistsException e) {
			storage.setDirectory(testDir.getAbsolutePath(), false); //revert back to the test directory to continue testing
		}
	}

	/**
	 * Tests the moving of files by calling setDirectory(dest, true)
	 * for an empty directory dest.
	 * @throws IOException
	 */
	@Test
	public void testMoveFiles() throws IOException {
		File dest = new File(testDir, "moved");
		// Move the files
		storage.setDirectory(dest.getAbsolutePath(), true);
		for (String filename : dest.list()) {
			assertTrue(Arrays.asList(Storage.FILENAMES).contains(filename));
		}
		// Move them back
		storage.setDirectory(testDir.getAbsolutePath(), true);
	}

	/*================*
	 * Test tasklists *
	 *================*/
	/**
	 * Tests the saving and subsequent loading of task lists
	 * @throws IOException
	 */
	@Test
	public void saveAndLoadTasklists() throws IOException {
		TaskList.clearAllLists();
		TaskList.populateLists();

		ArrayList<ArrayList<Task>> expectedList = new ArrayList<ArrayList<Task>>();	 
		for (TaskList list : taskListsFromStorage) {
			expectedList.add(list.get());
		}

		storage.saveAllTasklists(TaskList.getSuperlist());
		ArrayList<ArrayList<Task>> loadedList = storage.loadAllTasklists();

		assertEquals("Loaded tasklist must be size 6", TasklistEnum.size(), loadedList.size());
		assertTrue(expectedList.equals(loadedList)); 				//test Task's equals method
		assertEquals(toString(expectedList), toString(loadedList)); //test Task's toString method

		//System.out.println("\n" + toString(expectedList));
		//System.out.println(toString(loadedList));
	}


	/*===========*
	 * Test tags *
	 *===========*/
	/**
	 * Tests the saving and subsequent loading of tags
	 * @throws IOException
	 */
	@Test
	public void saveAndLoadTags() throws IOException {
		ArrayList<TagCategory> expectedList = createTaglist();
		storage.saveTaglist(expectedList);
		ArrayList<TagCategory> loadedList = storage.loadTaglist();

		assertNotEquals("taglist should not be empty", 0, loadedList.size());
		assertTrue(expectedList.equals(loadedList));
		assertEquals(toString(expectedList), toString(loadedList));
	}

	private static ArrayList<TagCategory> createTaglist() {
		ArrayList<TagCategory> tags = new ArrayList<TagCategory>();
		for (int i=0; i<3; i++) {
			tags.add(new TagCategory("TestTag_" + i + " "));
		}
		return tags;
	}


	/*==================*
	 * toString methods *
	 *==================*/
	private static String toString(List<ArrayList<Task>> superlist) { //note: type erasure
		String str = "";
		for (ArrayList<Task> list : superlist) {
			for (Task task : list) {
				str += task.toString();
			}
		}
		return str;
	}

	private static String toString(ArrayList<TagCategory> tags) {
		String str = "";
		for (TagCategory tag : tags) {
			str += tag.getTagName();
		}
		return str;
	}
}
```
