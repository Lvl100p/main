# A0125419H
###### \taskey\bin\taskey\ui\css\alertStyles.css
``` css
/* Note: Affects all scroll panes */
.root {
	-fx-background-color: rgba(0,0,0,0.0);
}
.scroll-pane {
	 -fx-background-color: transparent;
}

.scroll-pane > .viewport { /* Needed to color scroll pane's view port */
 	 -fx-background-color: transparent;
}

.alertBox {
	-fx-background-color: 
        radial-gradient(center 50% -50%, radius 200%, #FFFFFF 50%, #EEEEEE 50%);
    -fx-padding: 3px;
    -fx-effect: dropshadow(  gaussian  , rgba(0,0,0,0.6) , 5, 0.0 , 0 , 3 );
}
```
###### \taskey\bin\taskey\ui\css\defaultStyle.css
``` css
/* Note: Affects all scroll panes */
.scroll-pane {
}

.scroll-pane > .viewport { /* Needed to color scroll pane's view port */
   -fx-background-color: #e7e7e7;
}

.text-field {
    -fx-prompt-text-fill: #2d3956;
}
.text-field:focused {
}

/* Bound to fx:id */
#main {
	-fx-background-color: #616a7f;
}

#dateLabel {
	-fx-text-fill: #e7e7e7; 
    -fx-font-smoothing-type: gray;
    -fx-font-weight: bold;
    -fx-font-family: 'Montserrat';
}

#categoryLabel {
    -fx-font-smoothing-type: gray;
    -fx-font-family: 'Montserrat';
}

#dragBar {
	-fx-background-color: #2d3956;
}

#notification {
	-fx-text-fill: #e7e7e7;
	-fx-font-weight: bold;
}

/* Switchable styles */

.inputNormal {
	-fx-background-color: #e7e7e7;
	-fx-text-fill: #2d3956;
}

.inputError {
    -fx-background-color: red, #e7e7e7;
    -fx-background-insets: 0, 2px;
}

.inputCorrect {
    -fx-background-color: #0000ff, #e7e7e7;
    -fx-background-insets: 0, 2px;
}


.prompt {
	-fx-padding: 6px;
	-fx-background-color: #2d3956, #e7e7e7;
    -fx-background-insets: 0px, 4px;
    -fx-text-fill: #2d3956;
}

.promptSelect {
	-fx-padding: 6px;
	-fx-background-color: #2d3956, #2d3956;
    -fx-background-insets: 0px, 4px;
    -fx-text-fill: #e7e7e7;
}

.textCategory { 
	-fx-font-size: 12px;
	-fx-fill: #e7e7e7;
}

.textDefault { 
	-fx-fill: #e7e7e7;
}

/* Boxes */
.categoryBox {
	-fx-background-color: #455372;
}

.defaultBox {
	-fx-background-color: #2d3956;
}

.highlightBox {
	-fx-background-color: #234187;

}

/* Pagination */
.pagination .pagination-control {
    -fx-background-color: #e7e7e7;    
}
.pagination .pagination-control .bullet-button {
    -fx-background-color: transparent, #e7e7e7, #2d3956, #e7e7e7, #e7e7e7;
}
 
.pagination .pagination-control .bullet-button:selected {   
    -fx-background-color: transparent, #e7e7e7, #2d3956, #e7e7e7, #2d3956;
}
 
.pagination .pagination-control .left-arrow, .right-arrow{
    -fx-background-color: #e7e7e7, #2d3956;
}

.helpSelector {
	-fx-padding: 5px;
	-fx-background-color: #2d3956;
}

```
###### \taskey\bin\taskey\ui\css\defaultTab.css
``` css
/*Note: Affects all Tab Panes / Tabs */

.tab-pane .tab-header-area .tab-header-background {
    -fx-opacity: 0;
}

.tab-pane
{
    -fx-tab-min-width: 110px;
    -fx-tab-min-height: 30px;
}

.tab{
    -fx-background-color: #2d3956;
}
.tab .tab-label { 
    -fx-alignment: CENTER;
    -fx-text-fill: #e7e7e7;
    -fx-font-size: 17px;
    -fx-font-smoothing-type: gray;
    -fx-font-family: 'Montserrat';
}

.tab-pane .tab:selected
{
    -fx-background-color: #e7e7e7;
}

.tab:selected .tab-label { 
    -fx-alignment: CENTER;
    -fx-text-fill: #2d3956;
}
```
###### \taskey\bin\taskey\ui\css\lightStyle.css
``` css
/* Note: Affects all scroll panes */
.scroll-pane {
}

.scroll-pane > .viewport { /* Needed to color scroll pane's view port */
   -fx-background-color: #ebf4fb;
}

.text-field {
    -fx-prompt-text-fill: #206ba4;
}
.text-field:focused {
}

/* Bound to fx:id */
#main {
	-fx-background-color: #bbdaef;
}

#dateLabel {
	-fx-text-fill: #206ba4; 
    -fx-font-smoothing-type: gray;
    -fx-font-weight: bold;
    -fx-font-family: 'Montserrat';
}

#categoryLabel {
    -fx-font-smoothing-type: gray;
    -fx-font-family: 'Montserrat';
}

#dragBar {
	-fx-background-color: #206ba4;
}

#notification {
	-fx-text-fill: #206ba4;
	-fx-font-weight: bold;
}

/* Switchable styles */
.inputNormal {
	-fx-background-color: #ebf4fb;
	-fx-text-fill: #206ba4;
}
.inputError {
    -fx-background-color: red, #ebf4fb;
	-fx-background-insets: 0, 2px;
}

.inputCorrect {
    -fx-background-color: #0000ff, #ebf4fb;
    -fx-background-insets: 0, 2px;
}

.prompt {
	-fx-padding: 6px;
	-fx-background-color: #206ba4, #ebf4fb;
    -fx-background-insets: 0px, 4px;
    -fx-text-fill: #206ba4;
}

.promptSelect {
	-fx-padding: 6px;
	-fx-background-color: #206ba4, #206ba4;
    -fx-background-insets: 0px, 4px;
    -fx-text-fill: #ebf4fb;
}

.textCategory { 
	-fx-font-size: 12px;
	-fx-fill: #ebf4fb;
}

.textDefault { 
	-fx-fill: #ebf4fb;
}

/* Boxes */
.categoryBox {
	-fx-background-color: #206ba4;
}

.defaultBox {
	-fx-background-color: #206ba4;
}

.highlightBox {
	-fx-background-color: #8cbadb;

}

/* Pagination */
.pagination .pagination-control {
    -fx-background-color: #ebf4fb;    
}
.pagination .pagination-control .bullet-button {
    -fx-background-color: transparent, #ebf4fb, #206ba4, #ebf4fb, #ebf4fb;
}
 
.pagination .pagination-control .bullet-button:selected {   
    -fx-background-color: transparent, #ebf4fb, #206ba4, #ebf4fb, #206ba4;
}
 
.pagination .pagination-control .left-arrow, .right-arrow{
    -fx-background-color: #ebf4fb, #206ba4;
}

.helpSelector {
    -fx-padding: 5px;
	-fx-background-color: #206ba4;
}

```
###### \taskey\bin\taskey\ui\css\lightTab.css
``` css
/*Note: Affects all Tab Panes / Tabs */

.tab-pane .tab-header-area .tab-header-background {
    -fx-opacity: 0;
}

.tab-pane
{
    -fx-tab-min-width: 110px;
    -fx-tab-min-height: 30px;
}

.tab{
    -fx-background-color: #206ba4;
}
.tab .tab-label { 
    -fx-alignment: CENTER;
    -fx-text-fill: #ebf4fb;
    -fx-font-size: 17px;
    -fx-font-smoothing-type: gray;
    -fx-font-family: 'Montserrat';
}

.tab-pane .tab:selected
{
    -fx-background-color: #ebf4fb;
}

.tab:selected .tab-label { 
    -fx-alignment: CENTER;
    -fx-text-fill: #206ba4;
}
```
###### \taskey\bin\taskey\ui\css\sharedStyles.css
``` css
/* Switchable Text styles */
/* Mostly for text objects under UiTextConfig */
/* For default objects like Labels etc, need to add StyleClass manually */
@font-face {
    font-family: Montserrat;
    src: url('../fonts/Montserrat-Regular.ttf');
}

@font-face {
    font-family: Montserrat-Bold;
    src: url('../fonts/Montserrat-Bold.ttf');
}
.textAll {
	-fx-font-size: 15px;
	-fx-font-family: 'Montserrat';
	-fx-font-smoothing-type: gray;
}
.textRed {
	-fx-fill: red;
	-fx-font-weight: bold;
}

.textBlue { 
	-fx-fill: blue;
}

.textBlack { 
	-fx-fill: black;
}

#expiredIcon {
	-fx-font-size: 14px;
	-fx-text-fill: white;
	-fx-background-color: red;
	-fx-padding: 4px;
	-fx-font-family: 'Montserrat';
	-fx-font-weight: bold;
}
```
###### \taskey\src\taskey\constants\Triplet.java
``` java
 * This class is used to implement triplet generic
 * http://stackoverflow.com/questions/6010843/java-how-to-store-data-triple-in-a-list
 */

public class Triplet<T, U, V>
{
   private T a;
   private U b;
   private V c;

   public Triplet(T a, U b, V c)
   {
    this.a = a;
    this.b = b;
    this.c = c;
   }

   public T getA(){ return a;}
   public U getB(){ return b;}
   public V getC(){ return c;}
}
```
###### \taskey\src\taskey\constants\UiConstants.java
``` java
 * This file contains all the constants for UI
 * 
 * @author JunWei
 *
 */

public class UiConstants {

	// Initialization in UiMain
	public static final String PROGRAM_NAME = "Taskey";
	public static final String FXML_PATH = "layout.fxml";
	public static final String FXML_ALERT_PATH = "alert.fxml";
	public static final String FXML_LOAD_FAIL = "Fxml file not found";
	public static final Dimension WINDOW_MIN_SIZE = new Dimension(370,285); // half of original window size
	
	// Content Boxes
	public enum ContentBox {
		THIS_WEEK(0), PENDING(1), EXPIRED(2), ACTION(3), CATEGORY(4);
		private final int value;

		private ContentBox(int value) {
			this.value = value;
		}

		public int getValue() {
			return value;
		}

		public static ContentBox fromInteger(int x) {
			switch (x) {
			case 0:
				return THIS_WEEK;
			case 1:
				return PENDING;
			case 2:
				return EXPIRED;
			case 3:
				return ACTION;
			case 4:
				return CATEGORY;
			}
			return null;
		}
	}
	
	// For action tab
	public enum ActionMode {
		LIST, HELP;
	}
	public static final String ACTION_MODE_INVALID = "Mode invalid For ActionFormatter";
	
	// Grid settings
	public static final UiGridSettings GRID_SETTINGS_DEFAULT = new UiGridSettings(1, 1, 3, 5, 98);
	public static final UiGridSettings GRID_SETTINGS_ENTRY_PANE = new UiGridSettings(0, 0, 0, 80, 20);
	public static final UiGridSettings GRID_SETTINGS_ACTION_HELP = new UiGridSettings(0, 20, 10, 25, 75);
	public static final UiGridSettings GRID_SETTINGS_ACTION_HELP_MENU = new UiGridSettings(0, 20, 0, 100);
	public static final UiGridSettings GRID_SETTINGS_CATEGORY = new UiGridSettings(0, 1,0, 15,65,25);
	public static final UiGridSettings GRID_SETTINGS_SINGLE_CELL = new UiGridSettings(0, 0, 0, 100);
	public static final UiGridSettings GRID_SETTINGS_ALERT = new UiGridSettings(0, 20, 0, 100);
	public static final UiGridSettings GRID_SETTINGS_ALERT_ENTRY_PANE = new UiGridSettings(0, 0, 0, 10, 75,15);
	
	// Resources 
	// Note that getResourceByStream uses relative Package directory. 
	// In this case, images has to be a sub package of utility for a runnable JAR to work
	public static final String UI_IMAGE_PATH_OFFSET = "images/";
	public static final String UI_IMAGE_HELP_PATH_OFFSET = "help/";
	public static final String UI_CSS_PATH_OFFSET = "css/";
	
	// Use of TextFlow for text, setting style of TextFlow only affects the container
	// every Text node has to have its own style (with other options besides Color)
	public static final String STYLE_TEXT_ALL = "textAll";
	public static final String STYLE_TEXT_DEFAULT = "textDefault";
	public static final String STYLE_TEXT_BLACK = "textBlack";
	public static final String STYLE_TEXT_RED = "textRed";
	public static final String STYLE_TEXT_BLUE = "textBlue";
	public static final String STYLE_TEXT_CATEGORY = "textCategory";
	public static final String STYLE_CATEGORY_BOX = "categoryBox";
	public static final String STYLE_DEFAULT_BOX = "defaultBox";
	public static final String STYLE_HIGHLIGHT_BOX = "highlightBox";
	public static final String STYLE_HELP_MENU_SELECTOR = "helpSelector";
	public static final String STYLE_PROMPT_DEFAULT = "prompt";
	public static final String STYLE_PROMPT_SELECTED = "promptSelect";
	public static final String STYLE_INPUT_NORMAL = "inputNormal";
	public static final String STYLE_INPUT_ERROR = "inputError";
	public static final String STYLE_INPUT_CORRECT = "inputCorrect";
	public static final String STYLE_ALERT_BOX = "alertBox";
	
	public static final ArrayList<String> STYLE_UI_DEFAULT = new ArrayList<String>(
			Arrays.asList("sharedStyles.css", "defaultStyle.css", "defaultTab.css" ));
	public static final ArrayList<String> STYLE_UI_LIGHT = new ArrayList<String>(
			Arrays.asList("sharedStyles.css", "lightStyle.css", "lightTab.css" ));
	public static final ArrayList<String> STYLE_UI_ALERT_WINDOW = new ArrayList<String>(
			Arrays.asList("sharedStyles.css", "alertStyles.css"));
	public static final String STYLE_SHEETS_LOAD_FAIL = " loading style sheets";
	
	// Tray
	public static final String TRAY_SHOW_OPTION = "Show Taskey";
	public static final String TRAY_CLOSE_OPTION = "Close Program";
	public static final String TRAY_CLOSE_NO_SAVE_OPTION = "Close Without Saving";
	public static final String TRAY_IMAGE_PATH = "utility/images/windowIcon.png";
	public static final String TRAY_IMAGE_LOAD_FAIL = "Failed to load tray icon";
	public static final String MINIMIZE_MESSAGE_HEADER = "Taskey has been minimized.";
	public static final String MINIMIZE_MESSAGE_BODY = "Taskey will continue running in the background, click to resume planning your tasks.";
	
	// Alert Window
	public static final int MAX_ALERTS = 10; 
	public static final float ALERTS_OPACITY = 0.8f;
	public static final int[] HOUR_MARKS = { 1, 3, 5, 12 };
	
	// Others
	public static final DateFormat CLOCK_DATE_FORMAT = new SimpleDateFormat("dd MMM yyyy");
	public static final int UPDATE_SERVICE_INTERVAL = 300000; // in milliseconds (5 minutes)
	public static final int DEFAULT_ANIM_DURATION = 1000; // How long to play an animation
	public static final int DEFAULT_FADE_START_DELAY = 2000; 
	public static final int DEFAULT_SHAKE_DISTANCE = 10;
	public static final int DEFAULT_SHAKE_INTERVAL = 100;
	public static final int MAX_INPUT_HISTORY = 5; // number of inputs to remember for uicontroller
	public static final int ENTRIES_PER_PAGE_DEFAULT = 5;
	public static final int ENTRIES_PER_PAGE_HELP_MENU = 6;
	public static final int WINDOW_RESIZE_PICK_BOUNDS = 10;
}
```
###### \taskey\src\taskey\logger\TaskeyLog.java
``` java
 * This class implements a simple logging instance for Taskey
 * @author Junwei
 *
 */

public class TaskeyLog {
	public enum LogSystems {
		UI(0), LOGIC(1), PARSER(2), STORAGE(3);
		private int index;
		private LogSystems(int index) {
			this.index = index;
		}	
		public int getIndex() {
			return index;
		}
	};
	
	private static final String defaultLocation = "logs/";
	private static TaskeyLog instance = null;	
	private ArrayList<Logger> myLoggers;
	private static final int MAX_BYTES = 100000;
	private TaskeyLog() {
		myLoggers = new ArrayList<Logger>();
		// add loggers
		createLogger(UiMain.class.getName());
		createLogger(Logic.class.getName());
		createLogger(Parser.class.getName());
		createLogger(Storage.class.getName());
	}
	public static TaskeyLog getInstance() {
		if ( instance == null) {
			instance = new TaskeyLog();
		}
		return instance;
	}
	public void createLogger(String className) {
		Logger newLogger = Logger.getLogger(className);
		newLogger.setLevel(Level.ALL);
		myLoggers.add(newLogger);
	}
	
	public Logger getLogger( LogSystems system ) {
		return myLoggers.get(system.getIndex());
	}
	
	/**
	 * This method adds a handler to a logger variable, which makes any log() call
	 * pass on the msg to each handler.
	 * Count is the number of files to use for logging for this handler, note that logs are not appended but overwritten
	 * Note: Log files are found in main directory under logs folder
	 * @param system : LogSystems enum
	 * @param fileName
	 * @param count
	 */
	public void addHandler( LogSystems system , String fileName, int count ) {
		Logger theLogger = myLoggers.get(system.getIndex());
		int byteCount = MAX_BYTES;
		Handler handler = null; 
		try {
			handler = new FileHandler(defaultLocation + fileName, byteCount,count); 
			SimpleFormatter formatter = new SimpleFormatter();
			handler.setFormatter(formatter);
			theLogger.addHandler(handler); // if handle
		} catch (NoSuchFileException e) {
			System.out.println(fileName + " not found");
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		theLogger.setLevel(Level.ALL); // default to show all levels
	}
	
	// Log through all levels provided
	public void log( LogSystems system, String msg, Level ...levelOfLogging) {
		Logger theLogger = myLoggers.get(system.getIndex());
		for ( Level l : levelOfLogging) {
			theLogger.log(l,msg);	
		}
	}
	
	public void removeHandlers(LogSystems system) {
		Logger theLogger = myLoggers.get(system.getIndex());
		Handler [] handlers = theLogger.getHandlers();
		for (Handler h : handlers) {
			h.close();
			theLogger.removeHandler(h);
		}
	}
}
```
###### \taskey\src\taskey\ui\content\UiActionFormatter.java
``` java
 * This class is responsible to formatting the Action Content box
 * It provides additional functions like the help menu
 * 
 * @author junwei
 * 
 */

public class UiActionFormatter extends UiFormatter {
	private UiTaskView taskView;
	private UiHelpView helpView;
	private UiPagination currentView;

	public UiActionFormatter(ScrollPane thePane) {
		super(thePane);	
		taskView = new UiTaskView(UiConstants.ENTRIES_PER_PAGE_DEFAULT);
		helpView = new UiHelpView();
		mainPane.setFitToHeight(true);
	}

	@Override
	public void processArrowKey(KeyEvent event) {
		if ( currentView != null ) {
			currentView.processKey(event);
		}
	}
	
	@Override
	public void processPageUpAndDown(KeyEvent event) {
		if ( currentView != null ) {
			currentView.processKey(event);
		}
	}

	@Override
	public int processDeleteKey() {	
		if ( currentView == taskView.getView() ) {
			return currentView.getSelection() + 1; // add one as selection is from 0
		}
		return -1;
	}
	@Override
	public int processEnterKey() {
		if ( currentView != taskView.getView() ) {
			helpView.processEnterKey();
			currentView = helpView.getView();
			mainPane.setContent(currentView.getPagination());
		} 
		return 0;
	}
	
	/**
	 * Update content mode 
	 *
	 * @param mode - the mode of display
	 */
	public void updateMode(ActionMode mode) {
		switch ( mode ) {
			case HELP: 
				helpView.resetView();
				currentView = helpView.getView();
				mainPane.setContent(currentView.getPagination());				
				break;
			case LIST:
				currentView = taskView.getView();
				mainPane.setContent(currentView.getPagination());
				break;
			default:
				System.out.println(UiConstants.ACTION_MODE_INVALID);
		}
	}
	
	@Override
	public void format(ArrayList<Task> myTaskList) {
		assert(myTaskList != null);	
		taskView.getView().clear();
		int totalPages = (int) Math.ceil(myTaskList.size()/1.0/
										 UiConstants.ENTRIES_PER_PAGE_DEFAULT); // convert to double	
		taskView.createPaginationGrids(mainPane,myTaskList,totalPages);
	}

	@Override
	public void cleanUp() {
		helpView.clear();
		taskView.clear();
	}
}
```
###### \taskey\src\taskey\ui\content\UiCategoryFormatter.java
``` java
 * This class is responsible for formatting the Category box
 * 
 * @author junwei
 * 
 */

public class UiCategoryFormatter extends UiFormatter {

	public UiCategoryFormatter(ScrollPane thePane) {
		super(thePane);
		setGrid(gridHelper.setUpGrid(UiConstants.GRID_SETTINGS_CATEGORY));
		mainPane.setContent(currentGrid);
	}

	public void updateCategories(ArrayList<Triplet<Color, String, Integer>> categoryList) {
		clearCurrentGridContents();
		UiTextBuilder myBuilder = new UiTextBuilder();
		myBuilder.addMarker(0,UiConstants.STYLE_TEXT_CATEGORY);
		
		for ( int i = 0; i < categoryList.size(); i ++ ) {
			// add Rect
			gridHelper.createStyledCell(0, i, "", currentGrid);
			gridHelper.createScaledRectInCell(0, i, categoryList.get(i).getA(), currentGrid);
			// add tag name
			gridHelper.createStyledCell(1, i, UiConstants.STYLE_CATEGORY_BOX, currentGrid);
			gridHelper.addTextFlowToCell(1,i,myBuilder.build(categoryList.get(i).getB()),
															 TextAlignment.LEFT,currentGrid);
			// add tag numbers
			gridHelper.createStyledCell(2, i, UiConstants.STYLE_CATEGORY_BOX, currentGrid);
			gridHelper.addTextFlowToCell(2,i,myBuilder.build("" + categoryList.get(i).getC()),
															 TextAlignment.CENTER,currentGrid);
		}
	}
	
	// Unused as category does not take in inputs or uses tasks 
	@Override
	public void processArrowKey(KeyEvent event) {
	}

	@Override
	public void processPageUpAndDown(KeyEvent event) {	
	}
	
	@Override
	public int processDeleteKey() {
		return -1;
	}

	@Override
	public int processEnterKey() {
		return 0;
	}

	@Override
	public void format(ArrayList<Task> myTaskList) {
	}
	
	@Override
	public void cleanUp() {
		clearCurrentGridContents();
	}
}
```
###### \taskey\src\taskey\ui\content\UiContentManager.java
``` java
 * This class acts as the manager for all tab content display related operations
 * It does the main job of setting up the UiFormatters, and redirecting input from UiController.
 *
 * @author JunWei
 * 
 */

public class UiContentManager {
	// for each content box
	private ArrayList<UiFormatter> myFormatters = new ArrayList<UiFormatter>(); 

	/**
	 * Sets up the UiFormatters for each pane
	 *
	 * @param pane - the pane
	 * @param contentID - the content id
	 */
	public void setUpContentBox(ScrollPane pane, ContentBox contentID) {
		assert(pane != null);
		UiFormatter myFormatter;
		switch (contentID) {
		case ACTION:
			myFormatter = new UiActionFormatter(pane);
			break;
		case CATEGORY:
			myFormatter = new UiCategoryFormatter(pane);
			break;
		default:
			myFormatter = new UiDefaultFormatter(pane);
			break;
		}
		myFormatters.add(myFormatter);
		
		TaskeyLog.getInstance().log(LogSystems.UI, contentID.toString() + " tab has been added to ContentManager...", Level.ALL);
	}

	/**
	 * Generic update Content Box method, which would just call format on the formatters
	 * the format is handled differently by different formatters
	 *
	 * @param myTaskList - list of tasks
	 * @param contentID - id of content box
	 */
	public void updateContentBox(ArrayList<Task> myTaskList, ContentBox contentID) {
		assert(myTaskList != null);
		UiFormatter myFormatter = myFormatters.get(contentID.getValue());
		myFormatter.format(myTaskList);
	}
	
	/**
	 * Update display mode of action content box
	 *
	 * @param mode - LIST, HELP
	 */
	public void setActionMode(ActionMode mode) {
		int arrayIndex = ContentBox.ACTION.getValue();
		UiActionFormatter myFormatter = (UiActionFormatter) myFormatters.get(arrayIndex);
		myFormatter.updateMode(mode);
	}
	
	/**
	 * Update category content box.
	 *
	 * @param myCategoryList - the category list
	 * @param categoryNums - the category nums
	 * @param categoryColors - the category colors
	 */
	public void updateCategoryContentBox(ArrayList<Triplet<Color,String,Integer>> categoryList) {
		assert(categoryList != null);
		int arrayIndex = ContentBox.CATEGORY.getValue();
		UiCategoryFormatter myFormatter = (UiCategoryFormatter) myFormatters.get(arrayIndex);
		myFormatter.updateCategories(categoryList);
	}

	public void cleanUp() {
		for ( int i = 0; i < myFormatters.size(); i ++ ) {
			myFormatters.get(i).cleanUp();
		}
		myFormatters.clear();
	}
	
	//----------------------- Inputs Redirection -----------------------
	public void processArrowKey(KeyEvent event, ContentBox currentContent) {
		assert(event != null);
		UiFormatter myFormatter = myFormatters.get(currentContent.getValue());
		myFormatter.processArrowKey(event);
	}

	public void processPageUpAndDown(KeyEvent event, ContentBox currentContent) {
		assert(event != null);
		UiFormatter myFormatter = myFormatters.get(currentContent.getValue());
		myFormatter.processPageUpAndDown(event);
	}
	
	public int processDelete(ContentBox currentContent) {
		UiFormatter myFormatter = myFormatters.get(currentContent.getValue());
		return myFormatter.processDeleteKey();
	}

	public void processEnter(ContentBox currentContent) {
		UiFormatter myFormatter = myFormatters.get(currentContent.getValue());
		myFormatter.processEnterKey();
	}
}
```
###### \taskey\src\taskey\ui\content\UiDefaultFormatter.java
``` java
 * This class is responsible for formatting the Default content box
 * The default box is used by this week, pending, expired
 * 
 * @author junwei
 */

public class UiDefaultFormatter extends UiFormatter {
	private UiTaskView myTaskView;
	private ArrayList<Task> prevList = null;
	
	public UiDefaultFormatter(ScrollPane thePane) {
		super(thePane);
		myTaskView = new UiTaskView(UiConstants.ENTRIES_PER_PAGE_DEFAULT);
		
		mainPane.setContent(myTaskView.getView().getPagination());
		mainPane.setFitToHeight(true);
		
		createPromptNoTasks();
	}

	@Override
	public int processEnterKey() {
		return 0;
	}
	
	@Override
	public void processArrowKey(KeyEvent event) {
		myTaskView.getView().processKey(event);
		
	}

	@Override
	public int processDeleteKey() {
		return myTaskView.getView().getSelection() + 1;
	}
	
	@Override
	public void processPageUpAndDown(KeyEvent event) {
		myTaskView.getView().processKey(event);	
	}
	
	@Override
	public void format(ArrayList<Task> myTaskList) {
		assert(myTaskList != null);			
		if ( myTaskList.size() == 0 ) {	
			mainPane.setContent(currentGrid);	
		} else {
			mainPane.setContent(myTaskView.getView().getPagination());
			myTaskView.clear();
			int totalPages = (int) Math.ceil(myTaskList.size()/1.0/
											 UiConstants.ENTRIES_PER_PAGE_DEFAULT); // convert to double	
			myTaskView.createPaginationGrids(mainPane,myTaskList,totalPages);

			updateSelection(myTaskList);		
		}
	}
	
	private void updateSelection(ArrayList<Task> myTaskList) {
		ArrayList<Task> cloned = cloneList(myTaskList); // as list is going to be changed
		if ( prevList != null ) { 
			int index = 0;
			if ( myTaskList.size() >= prevList.size()) {
				index = findIndexOfModifiedTask(prevList,cloned);	// modification of a task
				if ( index == -1) {
					// no op as lists are the same
				} else {
					myTaskView.getView().selectInPage(index/UiConstants.ENTRIES_PER_PAGE_DEFAULT, 
							  index%UiConstants.ENTRIES_PER_PAGE_DEFAULT); 
				}
			}
		} 
		prevList = myTaskList; // note that myTaskList is cloned from Logic
	}
	
	private ArrayList<Task> cloneList(ArrayList<Task> toClone) {
		ArrayList<Task> cloneList = new ArrayList<Task>();
		for ( int i = 0; i < toClone.size(); i ++ ) {
			cloneList.add(new Task(toClone.get(i)));
		}
		return cloneList;
	}
	
	/**
	 * This method finds the index of the modified task to select in a page
	 * Note that this method changes the currentList passed in
	 * @param prevList
	 * @param currentList
	 * @return index
	 */
	private int findIndexOfModifiedTask(ArrayList<Task> prevList, ArrayList<Task> currentList) {
		int initialSize = currentList.size();
		for ( int i = 0; i < prevList.size(); i++) {
			Task task = prevList.get(i);
			int indexOfTask = currentList.indexOf(task); 
			if ( indexOfTask != -1 ) {
				currentList.set(indexOfTask, null); // we pick out elements, but retain the array
			}
		}
		for ( int i = 0; i < currentList.size(); i++ )  {
			if ( currentList.get(i) != null ) { // return first mismatch
				return i;
			}
		}
		currentList.removeAll(Collections.singleton(null));
		if ( currentList.size() == 0) { // all tasks match
			return -1;
		} else {
			return initialSize; // return newly added task
		}	
	}
	
	private void createPromptNoTasks() {
		// create prompt in absence of tasks
		setGrid(gridHelper.setUpGrid(UiConstants.GRID_SETTINGS_SINGLE_CELL));
		RowConstraints row = new RowConstraints();
		row.setPercentHeight(100);
		currentGrid.getRowConstraints().add(row);
		gridHelper.createStyledCell(0, 0, "", currentGrid);
		gridHelper.createLabelInCell(0, 0, "No tasks in window, add some tasks to get started!", "", currentGrid);
	}

	@Override
	public void cleanUp() {
		myTaskView.clear();
		clearCurrentGridContents();
	}	
}
```
###### \taskey\src\taskey\ui\content\UiFormatter.java
``` java
 * This class contains a default grid-based formatter for the content panes.
 * It provides some basic variables or methods that can be used
 * It is extended by specialized classes to provide extended functionalities
 * 
 * @author Junwei
 *
 */

public abstract class UiFormatter {
	
	protected ScrollPane mainPane;
	protected GridPane currentGrid;
	protected UiGridHelper gridHelper;

	public UiFormatter(ScrollPane thePane) {
		mainPane = thePane;
		mainPane.setFitToWidth(true);
		gridHelper = new UiGridHelper(UiConstants.STYLE_DEFAULT_BOX);
	}
	
	// Abstract methods that are handled by extended classes
	public abstract void format(ArrayList<Task> myTaskList);
	public abstract void processArrowKey(KeyEvent event);
	public abstract void processPageUpAndDown(KeyEvent event);
	public abstract int processDeleteKey();
	public abstract int processEnterKey();
	public abstract void cleanUp();

	/**
	 * Sets the current grid variable only, note needs mainPane.setContent() for effect
	 *
	 * @param newGrid - the new grid
	 */
	protected void setGrid(GridPane newGrid) {
		assert(newGrid != null);
		currentGrid = newGrid;
	}
	
	protected void clearCurrentGridContents() {
		assert(currentGrid != null);
		Node node = null;
		if (currentGrid.isGridLinesVisible()) {
			node = currentGrid.getChildren().get(0); // retain grid lines
		}
		currentGrid.getChildren().clear();
		if (currentGrid.isGridLinesVisible()) {
			currentGrid.getChildren().add(0, node);
		}
	}
}
```
###### \taskey\src\taskey\ui\content\views\UiHelpView.java
``` java
 * This class is used mainly to separate help menu from UiActionFormatter,
 * in order to make UiActionFormatter cleaner
 * 
 * @author junwei
 */

public class UiHelpView {
	
	private UiGridHelper gridHelper;
	private UiPagination helpView;
	private ArrayList<UiPagination> commandViews;
	private UiPagination currentView;
	private int imageWidth = 333;
	
	public UiHelpView() {
		gridHelper = new UiGridHelper("");
		helpView = new UiPagination(UiConstants.STYLE_HELP_MENU_SELECTOR);
		commandViews = new ArrayList<UiPagination>();
		setUpHelpView();
		currentView = helpView;
	}
	
	public void processEnterKey() {
		if ( currentView == helpView ) {
			currentView = commandViews.get(helpView.getSelection());
		} else {
			currentView = helpView;
		}
	}
	
	public void resetView() {
		currentView = helpView;
	}
	
	public UiPagination getView() {
		return currentView;
	}
	
	/**
```
###### \taskey\src\taskey\ui\content\views\UiHelpView.java
``` java
	 */
	private void addMainMenu(ArrayList<Pair<String, String>> mainMenuOptions) {
		int numCommmands = mainMenuOptions.size();
		int totalPages = (int) Math.ceil(numCommmands/1.0/UiConstants.ENTRIES_PER_PAGE_HELP_MENU); // convert to double	
		int entryNo = 0;
		for ( int i = 0; i < totalPages; i++ ) {
			GridPane newGrid = gridHelper.setUpGrid(UiConstants.GRID_SETTINGS_ACTION_HELP);
			ArrayList<StackPane> menuElements = new ArrayList<StackPane>();
			//newGrid.setGridLinesVisible(true);
			for ( int j = 0; j < UiConstants.ENTRIES_PER_PAGE_HELP_MENU; j ++ ) {
				if ( entryNo >= numCommmands ) {
					break;
				}
				String optionText = mainMenuOptions.get(entryNo).getKey();
				Label current = gridHelper.createLabelInCell(0, j, optionText, UiConstants.STYLE_PROMPT_SELECTED, newGrid);
				GridPane.setFillWidth(current.getParent(), false);
				GridPane.setFillHeight(current.getParent(), false);
				GridPane.setHalignment(current.getParent(), HPos.CENTER);
				if ( entryNo > 0 ) {
					menuElements.add(gridHelper.getWrapperAtCell(0,j,newGrid));
				}
				UiTextBuilder myBuilder = new UiTextBuilder();
				myBuilder.addMarker(0, UiConstants.STYLE_PROMPT_SELECTED);
				
				String descriptionText = mainMenuOptions.get(entryNo).getValue();
				gridHelper.createStyledCell(1, j, "", newGrid);
				gridHelper.addTextFlowToCell(1, j, myBuilder.build(descriptionText),TextAlignment.LEFT, newGrid);
				GridPane.setHalignment(current.getParent(), HPos.CENTER);
				entryNo++;
			}
			helpView.addGridToPagination(newGrid,menuElements);
		}	
		helpView.initializeDisplay(totalPages); // update UI and bind call back
	}
	
	private void addMenu(ArrayList<Pair<ImageID, String>> helpPages) {
		UiPagination menu = new UiPagination("");
		commandViews.add(menu);
		int totalPages = helpPages.size(); 
		for ( int i = 0 ; i < totalPages; i++ ) {
			GridPane newGrid = gridHelper.setUpGrid(UiConstants.GRID_SETTINGS_ACTION_HELP_MENU);
			
			ImageID imageID = helpPages.get(i).getKey();
			gridHelper.createImageInCell(0, 0, UiImageManager.getInstance().getImage(imageID), imageWidth, 0, newGrid);
			UiTextBuilder myBuilder = new UiTextBuilder();
			myBuilder.addMarker(0, UiConstants.STYLE_TEXT_DEFAULT);
			
			String helpText = helpPages.get(i).getValue();
			gridHelper.createStyledCell(0, 1, UiConstants.STYLE_HIGHLIGHT_BOX, newGrid);
			gridHelper.addTextFlowToCell(0, 1, myBuilder.build(helpText),TextAlignment.CENTER, newGrid);
			menu.addGridToPagination(newGrid,new ArrayList<StackPane>()); // no interactions	
		}
		menu.initializeDisplay(totalPages); // update UI and bind call back
	}
	
	public void clear() {
		for ( int i = 0 ; i < commandViews.size(); i ++ ) {
			commandViews.get(i).clear();
		}
		helpView.clear();
	}
}
```
###### \taskey\src\taskey\ui\content\views\UiPagination.java
``` java
 * This class is used to provide pagination support with extensions.
 * Such as selecting of elements
 * It is used in almost all of the tab contents of the UiFormatters
 * 
 * @author junwei
 * 
 */

public class UiPagination {
	private Pagination myPages;
	private ArrayList<GridPane> myGrids;
	private ArrayList<ArrayList<StackPane>> totalEntries; // track for key events
	private int currentPage;
	private int selectionInPage;
	private int currentSelection; // against total number of entries
	private String selectionStyle;
	private StackPane selectedPane = null;
	private boolean isSettingUp; // this is for preventing reset of uiPagination to page 0
	private ScrollPane scrollPane = null; // such that scrollbar will move with selection
	
	public UiPagination(String _selectionStyle) {
		selectionStyle = _selectionStyle;
		myPages = new Pagination(); 
		myGrids = new ArrayList<GridPane>();	
		totalEntries = new ArrayList<ArrayList<StackPane>>();
		currentSelection = 0;
		selectionInPage = 0;
		isSettingUp = true;
		
		disableKeyInputs();
	}
	
	public Pagination getPagination() {
		return myPages;
	}
	
	private void disableKeyInputs() {
		// so that the default pagination arrows wont affect the manual key input calls
		myPages.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
			public void handle(KeyEvent event) {
				event.consume();
			}
		});
	}

	/**
	 * Initialize and sets up the display for Pagination with totalPages.
	 * Then binds the method for create pages
	 * @param totalPages - the total pages
	 */
	public void initializeDisplay( int totalPages ) {	
		if ( totalPages == 0 ) {// for formatting
			myPages.setPageCount(1);
			myPages.setMaxPageIndicatorCount(1);
		} else {
			myPages.setPageCount(totalPages);
			myPages.setMaxPageIndicatorCount(totalPages);
		}
		myPages.getStyleClass().add(Pagination.STYLE_CLASS_BULLET);
		
		myPages.setPageFactory(new Callback<Integer, Node>() {
            @Override
            public Node call(Integer pageIndex) {
                return createPage(pageIndex);
            }
        });
		isSettingUp = false;
	}
	
	public int getSelection() { 
		if ( totalEntries.size() == 0 ) {
			return -1;
		}
		return currentSelection;
	}
	
	private void setCurrentToSelectionInPage() {  // map current selection to the selection in a page
		int currentIndex = 0; 
		for ( int i = 0; i < totalEntries.size(); i++ ) {
			if ( i != currentPage ) {
				currentIndex += totalEntries.get(i).size();
			} else {
				selectionInPage = Math.max(selectionInPage,0);
				selectionInPage = Math.min(selectionInPage,totalEntries.get(i).size()-1);
				currentIndex += selectionInPage;
				break;
			}
		}
		currentSelection = currentIndex;
	}
	
	public void selectInPage(int pageTo, int selection) { // select an entry in a page
		if ( pageTo < 0 || pageTo >= totalEntries.size() ) {
			return;
		}
		selectionInPage = selection;
		currentPage = pageTo;
		myPages.setCurrentPageIndex(currentPage); // go to the target page where item resides
		setCurrentToSelectionInPage();
		
		ArrayList<StackPane> pageContent = totalEntries.get(currentPage);
		if ( pageContent.size() == 0 ) { // no elements in page
			return;
		}
		// remove previous selection's style
		if ( selectedPane != null ) {
			selectedPane.getStyleClass().remove(selectionStyle);
		}	
		selectedPane = (StackPane) pageContent.get(selectionInPage);
		selectedPane.getStyleClass().add(selectionStyle);		
		
		adjustScrollPaneToSelection(); 
	}
	
	/**
	 * Process key, for the selection to be handled
	 * Needs to be called by the UiFormatters in order to interact with the page
	 *
	 * @param - event the event
	 */
	public void processKey(KeyEvent event) {
		if ( totalEntries.size() == 0 ) {
			return;
		}
		if ( event.getCode() == KeyCode.PAGE_DOWN) {
			if ( selectionInPage + 1 > totalEntries.get(currentPage).size()-1) { // do page switch
				selectInPage(currentPage+1,0);
			} else {
				selectInPage(currentPage,selectionInPage+1);
			}
		} else if ( event.getCode() == KeyCode.PAGE_UP) {
			if ( selectionInPage - 1 < 0 && currentPage >= 1 ) { // there exists a previous page
				int prevPageSize = totalEntries.get(currentPage-1).size(); // go previous
				selectInPage(currentPage-1, prevPageSize-1);
			} else {
				selectInPage(currentPage,selectionInPage-1);
			}
		} else if ( event.getCode() == KeyCode.RIGHT) {
			selectInPage(currentPage+1,selectionInPage);
		} else if ( event.getCode() == KeyCode.LEFT) {
			selectInPage(currentPage-1,selectionInPage);
		}
		
	}	

	/**
	 * Adds the grid to pagination, and provides an arraylist of stackpanes
	 * Which will be handled by UiPagination to do selection
	 *
	 * @param theGrid - the grid
	 * @param pageEntries - the page entries
	 */
	public void addGridToPagination(GridPane theGrid, ArrayList<StackPane> pageEntries) {
		totalEntries.add(pageEntries);
		myGrids.add(theGrid);	
	}
	
	/**
	 * Creates the page.
	 * Note this method creates the whole page by default, therefore we keep an arraylist of grids instead
	 * @param pageIndex the page index
	 * @return the grid pane
	 */
	private GridPane createPage(int pageIndex) {
		if ( pageIndex >= myGrids.size() ) {
			return null; // grid has not been initialized
		} 
		if ( isSettingUp == true ) { // workaround for pagination index resetting to 0 on setPageFactory
			// leave current Page active
		} else {
			currentPage = pageIndex;
		}
		if ( currentPage > myGrids.size()-1) { // on deletion of task
			int lastPage = myGrids.size()-1;
			currentPage = lastPage;
			selectionInPage = totalEntries.get(lastPage).size()-1;
		}
		selectInPage(currentPage,selectionInPage);
		return myGrids.get(currentPage);
    }	
	
	public void clear() {
		isSettingUp = true;
		myGrids.clear();
		totalEntries.clear();
		selectedPane = null;
	}

	public void setScrollPane(ScrollPane mainPane) {
		scrollPane = mainPane;
	}
	
	private void adjustScrollPaneToSelection() {
		if ( scrollPane == null ) {
			return;
		}

		// crude shifting of layout
		// Since layout bounds are updated internally, and not at this point in time
		scrollPane.vvalueProperty().bind(
				selectedPane.layoutYProperty().
				subtract(selectedPane.getLayoutY() + 
						 scrollPane.getViewportBounds().getMaxY() > 
						 selectedPane.layoutBoundsProperty().getValue().getMaxY() ? 
						 scrollPane.getViewportBounds().getMaxY() - 
						 selectedPane.layoutBoundsProperty().getValue().getMaxY() : 0));
	}
}
```
###### \taskey\src\taskey\ui\content\views\UiTaskView.java
``` java
 * This class is used to separate out the displaying of the task list
 * as DefaultFormatter, ActionFormatter both use it
 * 
 * @author junwei
 * 
 */

public class UiTaskView {
	private static final int stackPanePadding = 4;
	
	private UiPagination taskView;
	private int entriesPerPage;
	private UiGridHelper gridHelper;

	public UiTaskView(int _entriesPerPage) {
		entriesPerPage = _entriesPerPage;
		gridHelper = new UiGridHelper(UiConstants.STYLE_DEFAULT_BOX);
		taskView = new UiPagination(UiConstants.STYLE_HIGHLIGHT_BOX);
	}
	
	public UiPagination getView() {
		return taskView;
	}
	
	public void createPaginationGrids(ScrollPane mainPane, ArrayList<Task> myTaskList, int totalPages) {
		int entryNo = 0;
		ArrayList<Pair<Integer,Integer>> overlappingPairs = getIndexesOfOverlappingEvents(myTaskList);
		
		for ( int i = 0; i < totalPages; i ++ ) {
			GridPane newGrid = gridHelper.setUpGrid(UiConstants.GRID_SETTINGS_DEFAULT);
			ArrayList<StackPane> pageEntries = new ArrayList<StackPane>();
			for ( int j = 0; j < entriesPerPage; j ++ ) {
				if ( entryNo >= myTaskList.size() ) {
					break;
				}
				StackPane entryPane = gridHelper.createStyledCell(1, j, UiConstants.STYLE_DEFAULT_BOX, newGrid);
				// another grid within the pane for formatting while keeping a common styling pane
				GridPane paneGrid = gridHelper.setUpGrid(UiConstants.GRID_SETTINGS_ENTRY_PANE); 
				entryPane.getChildren().add(paneGrid);
				
				Task theTask = myTaskList.get(entryNo);
				addTaskID(theTask, entryNo, j, newGrid); // add to main grid
				addTaskDescription(theTask,paneGrid);
				addImage(theTask,paneGrid);
				checkOverlaps(overlappingPairs, entryNo, paneGrid); // Mark overlapping tasks
				
				entryNo++;	
				pageEntries.add(entryPane);
			}
			taskView.addGridToPagination(newGrid,pageEntries);
		}
		taskView.setScrollPane(mainPane);
		taskView.initializeDisplay(totalPages); // update UI and bind call back
		
	}
	
	private void addTaskID(Task theTask, int id, int row, GridPane theGrid) {
		assert(theTask != null);
		UiTextBuilder myBuilder = new UiTextBuilder();
		myBuilder.addMarker(0, UiConstants.STYLE_TEXT_DEFAULT);
		String line = "" + (id + 1);
		Color theColor = null;
		switch ( theTask.getPriority()) {
			case 3: theColor = Color.RED;
					break;
			case 2: theColor = Color.web("#e87301",1.0);
					break;
			default:
					theColor = Color.GREEN;
		}
		gridHelper.createStyledCell(0, row, "", theGrid);
		gridHelper.createScaledRectInCell(0, row, theColor, theGrid);
		gridHelper.addTextFlowToCell(0, row, myBuilder.build(line),TextAlignment.CENTER, theGrid);	
	}
		
	private void addTaskDescription(Task theTask, GridPane newGrid) {
		assert(theTask != null);
		assert(theTask.getTaskType() != null);
		
		UiTextBuilder myBuilder = new UiTextBuilder();
		myBuilder.addMarkers(UiConstants.STYLE_TEXT_DEFAULT);
		String line = "";
		line += "Name: "; 
		line += theTask.getTaskName() + "\n";
		switch ( theTask.getTaskType() ) {
			case "EVENT": 
				String [] timings = theTask.getEventTime();
				line += "from ";
				line += timings[0] + " to " + timings[1];
				break;
	 		case "DEADLINE":
				line += "by ";	
				line += "" + theTask.getDeadline();
				break;
			default:
				break;
		}
		line += "\n";
		if ( theTask.getTaskTags() != null ) {
			line += "Tags: ";
			ArrayList<String> tags = theTask.getTaskTags();
			for ( int i = 0; i < tags.size()-1 ; i++ ) {
				line += "#" + tags.get(i) + " ";
			}
			line += "#" + tags.get(tags.size()-1);
		} 
		StackPane pane = gridHelper.createStyledCell(0, 0, "", newGrid);
		pane.setPadding(new Insets(stackPanePadding));
		gridHelper.addTextFlowToCell(0, 0, myBuilder.build(line),TextAlignment.LEFT, newGrid);
	}
	
	private void addImage(Task theTask, GridPane newGrid) { 
		assert(theTask.getTaskType() != null);
		ImageID imgID;
		switch ( theTask.getTaskType() ) {
			case "EVENT":
				imgID = ImageID.EVENT;
				break;
			case "DEADLINE":
				imgID = ImageID.DEADLINE;
				break;
			default:
				imgID = ImageID.FLOATING;
				break;
		}
		gridHelper.createStyledCell(1, 0, "", newGrid);
		gridHelper.createImageInCell(1,0,UiImageManager.getInstance().getImage(imgID),30,30,newGrid);
	}
	
	private void addOverlapIcon(GridPane newGrid ) {
		ImageView img = gridHelper.createImageInCell(1,0,
				UiImageManager.getInstance().getImage(ImageID.URGENT_MARK),15,15,newGrid);
		StackPane.setAlignment(img, Pos.TOP_RIGHT);
	}
	
	private void checkOverlaps(ArrayList<Pair<Integer, Integer>> overlappingPairs, int entryNo, GridPane paneGrid) {
		for ( int k = 0; k < overlappingPairs.size(); k ++ ) {
			if ( overlappingPairs.get(k).getKey() == entryNo 
				 || overlappingPairs.get(k).getValue() == entryNo) {
				addOverlapIcon(paneGrid);
				break;
			}
		}
	}

	/**
	 * This method provides an efficient method to check overlap of 2 ranges
	 * http://stackoverflow.com/questions/325933/determine-whether-two-date-ranges-overlap
	 * Assumes start date is <= end date for both events
	 * @param firstEvent
	 * @param secondEvent
	 * @return
	 */
	private boolean isOverlapping ( Task firstEvent, Task secondEvent) {
		return (firstEvent.getStartDateEpoch() <= secondEvent.getEndDateEpoch())  &&  
				(firstEvent.getEndDateEpoch() >= secondEvent.getStartDateEpoch());
	}
	
	private ArrayList<Pair<Integer,Integer>> getIndexesOfOverlappingEvents(ArrayList<Task> taskList) {
		ArrayList<Pair<Integer,Integer>> indexPairs = new ArrayList<Pair<Integer,Integer>>();
		ArrayList<Pair<Integer,Task>> events = new ArrayList<Pair<Integer,Task>>();
		for ( int i = 0; i < taskList.size(); i ++ ) {
			if ( taskList.get(i).getTaskType().equals("EVENT")) {
				events.add(new Pair<Integer,Task>(i,taskList.get(i)));  // original index in task list
			}
		}
		if ( events.size() > 0 ) {
			for ( int i = 0; i < events.size(); i ++ ) {
				for ( int j = i+1; j < events.size(); j ++) {
					if ( isOverlapping(events.get(i).getValue(), events.get(j).getValue())) {
						indexPairs.add(new Pair<Integer,Integer>(events.get(i).getKey(),events.get(j).getKey()));
					}
				}
			}
		}
		return indexPairs;
	}
	
	public void clear() {
		taskView.clear();
	}
}
```
###### \taskey\src\taskey\ui\css\alertStyles.css
``` css
/* Note: Affects all scroll panes */
.root {
	-fx-background-color: rgba(0,0,0,0.0);
}
.scroll-pane {
	 -fx-background-color: transparent;
}

.scroll-pane > .viewport { /* Needed to color scroll pane's view port */
 	 -fx-background-color: transparent;
}

.alertBox {
	-fx-background-color: 
        radial-gradient(center 50% -50%, radius 200%, #FFFFFF 50%, #EEEEEE 50%);
    -fx-padding: 3px;
    -fx-effect: dropshadow(  gaussian  , rgba(0,0,0,0.6) , 5, 0.0 , 0 , 3 );
}
```
###### \taskey\src\taskey\ui\css\defaultStyle.css
``` css
/* Note: Affects all scroll panes */
.scroll-pane {
}

.scroll-pane > .viewport { /* Needed to color scroll pane's view port */
   -fx-background-color: #e7e7e7;
}

.text-field {
    -fx-prompt-text-fill: #2d3956;
}
.text-field:focused {
}

/* Bound to fx:id */
#main {
	-fx-background-color: #616a7f;
}

#dateLabel {
	-fx-text-fill: #e7e7e7; 
    -fx-font-smoothing-type: gray;
    -fx-font-weight: bold;
    -fx-font-family: 'Montserrat';
}

#categoryLabel {
    -fx-font-smoothing-type: gray;
    -fx-font-family: 'Montserrat';
}

#dragBar {
	-fx-background-color: #2d3956;
}

#notification {
	-fx-text-fill: #e7e7e7;
	-fx-font-weight: bold;
}

/* Switchable styles */

.inputNormal {
	-fx-background-color: #e7e7e7;
	-fx-text-fill: #2d3956;
}

.inputError {
    -fx-background-color: red, #e7e7e7;
    -fx-background-insets: 0, 2px;
}

.inputCorrect {
    -fx-background-color: #0000ff, #e7e7e7;
    -fx-background-insets: 0, 2px;
}


.prompt {
	-fx-padding: 6px;
	-fx-background-color: #2d3956, #e7e7e7;
    -fx-background-insets: 0px, 4px;
    -fx-text-fill: #2d3956;
}

.promptSelect {
	-fx-padding: 6px;
	-fx-background-color: #2d3956, #2d3956;
    -fx-background-insets: 0px, 4px;
    -fx-text-fill: #e7e7e7;
}

.textCategory { 
	-fx-font-size: 12px;
	-fx-fill: #e7e7e7;
}

.textDefault { 
	-fx-fill: #e7e7e7;
}

/* Boxes */
.categoryBox {
	-fx-background-color: #455372;
}

.defaultBox {
	-fx-background-color: #2d3956;
}

.highlightBox {
	-fx-background-color: #234187;

}

/* Pagination */
.pagination .pagination-control {
    -fx-background-color: #e7e7e7;    
}
.pagination .pagination-control .bullet-button {
    -fx-background-color: transparent, #e7e7e7, #2d3956, #e7e7e7, #e7e7e7;
}
 
.pagination .pagination-control .bullet-button:selected {   
    -fx-background-color: transparent, #e7e7e7, #2d3956, #e7e7e7, #2d3956;
}
 
.pagination .pagination-control .left-arrow, .right-arrow{
    -fx-background-color: #e7e7e7, #2d3956;
}

.helpSelector {
	-fx-padding: 5px;
	-fx-background-color: #2d3956;
}

```
###### \taskey\src\taskey\ui\css\defaultTab.css
``` css
/*Note: Affects all Tab Panes / Tabs */

.tab-pane .tab-header-area .tab-header-background {
    -fx-opacity: 0;
}

.tab-pane
{
    -fx-tab-min-width: 110px;
    -fx-tab-min-height: 30px;
}

.tab{
    -fx-background-color: #2d3956;
}
.tab .tab-label { 
    -fx-alignment: CENTER;
    -fx-text-fill: #e7e7e7;
    -fx-font-size: 17px;
    -fx-font-smoothing-type: gray;
    -fx-font-family: 'Montserrat';
}

.tab-pane .tab:selected
{
    -fx-background-color: #e7e7e7;
}

.tab:selected .tab-label { 
    -fx-alignment: CENTER;
    -fx-text-fill: #2d3956;
}
```
###### \taskey\src\taskey\ui\css\lightStyle.css
``` css
/* Note: Affects all scroll panes */
.scroll-pane {
}

.scroll-pane > .viewport { /* Needed to color scroll pane's view port */
   -fx-background-color: #ebf4fb;
}

.text-field {
    -fx-prompt-text-fill: #206ba4;
}
.text-field:focused {
}

/* Bound to fx:id */
#main {
	-fx-background-color: #bbdaef;
}

#dateLabel {
	-fx-text-fill: #206ba4; 
    -fx-font-smoothing-type: gray;
    -fx-font-weight: bold;
    -fx-font-family: 'Montserrat';
}

#categoryLabel {
    -fx-font-smoothing-type: gray;
    -fx-font-family: 'Montserrat';
}

#dragBar {
	-fx-background-color: #206ba4;
}

#notification {
	-fx-text-fill: #206ba4;
	-fx-font-weight: bold;
}

/* Switchable styles */
.inputNormal {
	-fx-background-color: #ebf4fb;
	-fx-text-fill: #206ba4;
}
.inputError {
    -fx-background-color: red, #ebf4fb;
	-fx-background-insets: 0, 2px;
}

.inputCorrect {
    -fx-background-color: #0000ff, #ebf4fb;
    -fx-background-insets: 0, 2px;
}

.prompt {
	-fx-padding: 6px;
	-fx-background-color: #206ba4, #ebf4fb;
    -fx-background-insets: 0px, 4px;
    -fx-text-fill: #206ba4;
}

.promptSelect {
	-fx-padding: 6px;
	-fx-background-color: #206ba4, #206ba4;
    -fx-background-insets: 0px, 4px;
    -fx-text-fill: #ebf4fb;
}

.textCategory { 
	-fx-font-size: 12px;
	-fx-fill: #ebf4fb;
}

.textDefault { 
	-fx-fill: #ebf4fb;
}

/* Boxes */
.categoryBox {
	-fx-background-color: #206ba4;
}

.defaultBox {
	-fx-background-color: #206ba4;
}

.highlightBox {
	-fx-background-color: #8cbadb;

}

/* Pagination */
.pagination .pagination-control {
    -fx-background-color: #ebf4fb;    
}
.pagination .pagination-control .bullet-button {
    -fx-background-color: transparent, #ebf4fb, #206ba4, #ebf4fb, #ebf4fb;
}
 
.pagination .pagination-control .bullet-button:selected {   
    -fx-background-color: transparent, #ebf4fb, #206ba4, #ebf4fb, #206ba4;
}
 
.pagination .pagination-control .left-arrow, .right-arrow{
    -fx-background-color: #ebf4fb, #206ba4;
}

.helpSelector {
    -fx-padding: 5px;
	-fx-background-color: #206ba4;
}

```
###### \taskey\src\taskey\ui\css\lightTab.css
``` css
/*Note: Affects all Tab Panes / Tabs */

.tab-pane .tab-header-area .tab-header-background {
    -fx-opacity: 0;
}

.tab-pane
{
    -fx-tab-min-width: 110px;
    -fx-tab-min-height: 30px;
}

.tab{
    -fx-background-color: #206ba4;
}
.tab .tab-label { 
    -fx-alignment: CENTER;
    -fx-text-fill: #ebf4fb;
    -fx-font-size: 17px;
    -fx-font-smoothing-type: gray;
    -fx-font-family: 'Montserrat';
}

.tab-pane .tab:selected
{
    -fx-background-color: #ebf4fb;
}

.tab:selected .tab-label { 
    -fx-alignment: CENTER;
    -fx-text-fill: #206ba4;
}
```
###### \taskey\src\taskey\ui\css\sharedStyles.css
``` css
/* Switchable Text styles */
/* Mostly for text objects under UiTextConfig */
/* For default objects like Labels etc, need to add StyleClass manually */
@font-face {
    font-family: Montserrat;
    src: url('../fonts/Montserrat-Regular.ttf');
}

@font-face {
    font-family: Montserrat-Bold;
    src: url('../fonts/Montserrat-Bold.ttf');
}
.textAll {
	-fx-font-size: 15px;
	-fx-font-family: 'Montserrat';
	-fx-font-smoothing-type: gray;
}
.textRed {
	-fx-fill: red;
	-fx-font-weight: bold;
}

.textBlue { 
	-fx-fill: blue;
}

.textBlack { 
	-fx-fill: black;
}

#expiredIcon {
	-fx-font-size: 14px;
	-fx-text-fill: white;
	-fx-background-color: red;
	-fx-padding: 4px;
	-fx-font-family: 'Montserrat';
	-fx-font-weight: bold;
}
```
###### \taskey\src\taskey\ui\UiAlert.java
``` java
 * 
 * This class implements a alert object used by UiAlertController, 
 * which wraps an Task object in order to have additional information
 * @author Junwei
 *
 */
public class UiAlert {

	private Task theTask;
	private String alertMessage = "Stub";
	private static int stubID = 0; // used for key generated Alerts
	
	public UiAlert() {
		theTask = new Task();
		theTask.setTaskName(String.valueOf(stubID++));
		theTask.setTaskType("FLOATING");
	}
	
	public UiAlert(Task _theTask) {
		theTask = _theTask;
	}

	public Task getTask() {
		return theTask;
	}
	
	public void setMessage(String msg) {
		alertMessage = msg;
	}
	
	public String getMessage() {
		return alertMessage;
	}

	public TextFlow getTextFlow() {
		UiTextBuilder myBuilder = new UiTextBuilder();
		myBuilder.addMarker(0, UiConstants.STYLE_TEXT_DEFAULT);
		String line = "" + theTask.getTaskName() + "\n";
		myBuilder.addMarker(line.length(), UiConstants.STYLE_TEXT_RED);
		if ( theTask.getTaskType().equals("DEADLINE")) {
			line += theTask.getDeadline();
		} else if ( theTask.getTaskType().equals("EVENT")){
			line += theTask.getStartDate() + " to " + theTask.getEndDate();
		}
		myBuilder.addMarker(line.length(), UiConstants.STYLE_TEXT_BLUE);
		line += "\n" + alertMessage;
		return myBuilder.build(line);
	}
	
	public Color getColor() {
		Color theColor = null;
		switch ( theTask.getPriority()) { 
			case 2: theColor = Color.RED;
					break;
			case 1: theColor = Color.ORANGE;
					break;
			default:
					theColor = Color.GREEN;
		}
		return theColor;
	}
	
	@Override
	public boolean equals(Object obj) {
		if ( obj == null ) {
			return false;
		}
		UiAlert theAlert = (UiAlert) obj;
		if ( theAlert.getTask().equals(this.getTask())
			&& theAlert.getMessage().equals(this.getMessage())) {
			return true;
		} 
		return false;
	}
}
```
###### \taskey\src\taskey\ui\UiAlertsController.java
``` java
 * 
 * This class implements another Stage / window for displaying alerts
 * Note that this is separate from the main window, and hence
 * we are reusing some classes for formatting data
 * @author Junwei
 *
 */
public class UiAlertsController {

	@FXML
	private ScrollPane scrollPane;
	
	private GridPane displayGrid;
	private AnchorPane rootNode;
	private Stage stage;
	private UiGridHelper gridHelper = new UiGridHelper("");
	private ArrayList<UiAlert> currentAlerts = new ArrayList<UiAlert>();
	private ArrayList<UiAlert> alertHistory = new ArrayList<UiAlert>(); // dismissed alerts are not re-added
	
	//----- Used by UiTrayModule ------
	public Stage getStage() {
		return stage;
	}
		
	public void hide() {
		stage.hide();
	}

	public void show() {
		stage.show();		
		Rectangle2D primaryScreenBounds = Screen.getPrimary().getVisualBounds();
        stage.setX(primaryScreenBounds.getMaxX() - stage.getWidth());
        stage.setY(0);
        stage.setHeight(primaryScreenBounds.getHeight());      
        rootNode.setMinHeight(primaryScreenBounds.getHeight()); // resize anchorPane, scrollpane will resize to fit    
        rootNode.requestFocus();
	}
	//-------------------------------
	
	public void setUpStage(Region contentRootRegion) {
		TaskeyLog.getInstance().log(LogSystems.UI, "Setting up Alert Window...", Level.ALL);
		
		stage = new Stage();
        stage.initStyle(StageStyle.TRANSPARENT); 
		stage.setScene(new Scene(contentRootRegion));
		stage.getScene().setFill(null);
		
        rootNode = (AnchorPane) contentRootRegion;
        rootNode.setOpacity(UiConstants.ALERTS_OPACITY);
        
        setUpScene();
        addRootEventHandlers();

        TaskeyLog.getInstance().log(LogSystems.UI, "Alert Window has been set up...", Level.ALL);
	}
	
	private void setUpScene() {
		ObservableList<String> myStyleSheets = stage.getScene().getStylesheets();
        for ( int i = 0; i < UiConstants.STYLE_UI_ALERT_WINDOW.size(); i++ ) {
        	myStyleSheets.add(getClass().getResource(UiConstants.UI_CSS_PATH_OFFSET 
        										     + UiConstants.STYLE_UI_ALERT_WINDOW.get(i)).toExternalForm());
        }
        
        displayGrid = gridHelper.setUpGrid(UiConstants.GRID_SETTINGS_ALERT);
        displayGrid.setAlignment(Pos.BOTTOM_CENTER); // such that alerts appear from the bottom
        scrollPane.setContent(displayGrid);
        scrollPane.setFitToHeight(true);
        scrollPane.setFitToWidth(true);
        
        for ( int i = 0; i < UiConstants.MAX_ALERTS; i++ ) {  // used as an array
        	currentAlerts.add(null); 
        }
	}
	
	private void addRootEventHandlers() {
		rootNode.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>() {
			public void handle(KeyEvent event) {
				if (event.getCode() == KeyCode.F5) { // for testing purposes
					addEntry(new UiAlert());
				} else if (event.getCode() == KeyCode.W && event.isControlDown()) {
					hide();
				}
			}
		});
	}	
	
	private void addClickHandler(StackPane thePane) {
		assert(thePane != null);
		thePane.setOnMouseReleased(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent mouseEvent) {
				FadeTransition fade = UiAnimationManager.getInstance().createFadeTransition(thePane, 0,
						UiConstants.DEFAULT_ANIM_DURATION/2, 1.0, 0.0);
				fade.play();
				fade.setOnFinished(new EventHandler<ActionEvent>() {
					@Override
					public void handle(ActionEvent event) {
						StackPane wrapper = (StackPane) fade.getNode().getParent();
						int index = GridPane.getRowIndex(wrapper);
						removeEntry(index);
					}
				});
				thePane.setOnMouseReleased(null); // remove handler
			}
		});	
	}
	
	private void addStartAnimation(StackPane thePane) {
		assert(thePane != null);
		// animate within the grid, hence translation coordinates are 0.0
		TranslateTransition shift = UiAnimationManager.getInstance().createTranslateTransition(thePane, 
				new Pair<Double,Double>(stage.getWidth(), 0.0), 
				new Pair<Double,Double>(0.0, 0.0), UiConstants.DEFAULT_ANIM_DURATION/2);
		shift.play();
		shift.setOnFinished(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				ScaleTransition scale = UiAnimationManager.getInstance().
						createScaleTransition(thePane, 1.25f, 1.25f, 4, true, 
											  UiConstants.DEFAULT_ANIM_DURATION/5);
				scale.play();
			}
		});
	}
	
	private void addEntry(UiAlert newAlert) {
		assert(newAlert != null);
		if ( checkAlertExisted(newAlert) == true ) {
			return;
		}
		int gridIndex = findFirstFreeSlot();
		if ( gridIndex == -1 ) {
			return;
		} else {
			StackPane thePane = gridHelper.createStackPaneInCell(0, gridIndex, UiConstants.STYLE_ALERT_BOX, displayGrid);
			GridPane entryGrid = gridHelper.setUpGrid(UiConstants.GRID_SETTINGS_ALERT_ENTRY_PANE);
			gridHelper.createScaledRectInCell(0, 0, newAlert.getColor(), entryGrid);
			gridHelper.addTextFlowToCell(1, 0, newAlert.getTextFlow(),TextAlignment.LEFT, entryGrid);	
			gridHelper.createImageInCell(2, 0, UiImageManager.getInstance().getImage(ImageID.URGENT_MARK), 
										 15, 15, entryGrid);
			thePane.getChildren().add(entryGrid);
			
			addStartAnimation(thePane);
			addClickHandler(thePane);					
			currentAlerts.set(gridIndex, newAlert);	// set to array
		}
	}
	
	private boolean checkAlertExisted(UiAlert newAlert) {
		assert(newAlert != null);
		if ( currentAlerts.contains(newAlert)) {
			return true;
		} else if ( alertHistory.contains(newAlert)) {
			return true;
		}
		return false;
	}
	
	private int findFirstFreeSlot() {
		for ( int i = UiConstants.MAX_ALERTS-1; i >= 0; i -- ) { // search from the bottom of screen
			if ( currentAlerts.get(i) == null ) {
				return i;
			}
		}
		return -1;
	}
	
	private void removeEntry( int gridIndex ) {
		StackPane wrapper = gridHelper.getWrapperAtCell(0, gridIndex, displayGrid);
		displayGrid.getChildren().remove(wrapper); // free the slot	in the grid display
		alertHistory.add(currentAlerts.get(gridIndex)); 
		currentAlerts.set(gridIndex, null); 
		
		 // shift all entries down
		for ( int i = UiConstants.MAX_ALERTS-1; i >= 0; i -- ) {
			if ( currentAlerts.get(i) == null ) {
				int swapIndex = -1;
				UiAlert swapAlert = null;
				for ( int j = i-1; j >= 0; j -- ) {
					if ( currentAlerts.get(j) != null ) { // has an alert
						StackPane temp = gridHelper.getWrapperAtCell(0, j, displayGrid);
						displayGrid.getChildren().remove(temp);
						displayGrid.add(temp, 0, i); // move to empty slot
						swapIndex = j;
						swapAlert = currentAlerts.get(j);
						break;
					}	
				}
				if ( swapIndex != -1 ) {
					currentAlerts.set(swapIndex, null); // free slot of alert to be shifted down
					currentAlerts.set(i, swapAlert);
				}
			}	
		}
	}
	
	/**
	 * Convenience method for setting all alerts
	 * @param alertList
	 */
	public void setAllAlerts(ArrayList<UiAlert> alertList) { 
		assert(alertList != null);
		for ( int i = 0; i < UiConstants.MAX_ALERTS; i ++ ) {
			if ( alertList.contains(currentAlerts.get(i)) == false ) { // remove old / invalid alerts
				removeEntry(i);
			}
		}
		for ( int i = 0; i < alertList.size() ; i ++) {
			addEntry(alertList.get(i));
		}
	}
}
```
###### \taskey\src\taskey\ui\UiController.java
``` java
 * 
 * This class is the main class that handles all of the main window Ui nodes
 * UiController is the main interface between Ui and Logic
 * One sub interface would be UiUpdateService inside UiController
 * 
 * This class is responsible for handling all user keyboard / mouse inputs within the
 * main window, and delegates the actions to be handled into other classes if needed
 * 
 * @author JunWei
 * 
 */

public class UiController {

	@FXML
	private TabPane myTabs;
	@FXML
	private TextField input;
	@FXML
	private Label dateLabel;
	@FXML
	private StackPane dragBar;
	@FXML
	private ScrollPane categoryPane;
	@FXML
	private ImageView crossButton;
	@FXML
	private ImageView minusButton;
	@FXML
	private Label expiredIcon;
	@FXML
	private Label notification;
	
	private int mouseX, mouseY;
	private Stage stage;
	private Logic logic;
	private UiUpdateService updateService;
	private UiDropDown myDropDown;
	private UiContentManager myContentManager;
	private int currentTab;
	private ContentBox currentContent;
	private ArrayList<String> inputHistory;
	private int historyIterator;
	private Timeline shakeNotification; // animation

	//----- Used by UiTrayModule ------
	public Stage getStage() {
		return stage;
	}
	
	public void setUpUpdateService(UiAlertsController alertController) {
		updateService = new UiUpdateService(dateLabel,logic,alertController);
		updateService.start();
	}
	
	public void updateAlerts() {
		updateService.pollFromLogic();
	}
	//---------------------------------
	
	/**
	 * Performs the main setups for the controller
	 * including nodes and logic
	 *
	 * @param primaryStage the primary stage
	 * @param root the root
	 */
	public void setUpController(Stage primaryStage, Parent root) {
		assert(primaryStage != null);
		assert(root != null);
		TaskeyLog.getInstance().log(LogSystems.UI, "Setting up Main Controller...", Level.ALL);
		
		stage = primaryStage; // set up reference
		myDropDown = new UiDropDown();
		setUpContentBoxes();
		setUpTabDisplay();		
		setUpButtonStyles();
		setUpInput();
		registerEventHandlersToNodes(root);	
		setUpLogic();	

		TaskeyLog.getInstance().log(LogSystems.UI, "Main Controller has been set up...", Level.ALL);
	}
	
	/**
	 * Sets up nodes which need bounds.
	 * nodes or classes that need layout bounds are initialized here
	 * (Note that bounds are updated only when the node is shown)
	 */
	public void setUpNodesWhichNeedBounds() {
		assert(myDropDown != null);
		myDropDown.createMenu(stage, input);
	}

	private void setUpContentBoxes() {
		assert(myTabs != null);
		myContentManager = new UiContentManager();
		for (int i = 0; i < myTabs.getTabs().size(); i++) {
			AnchorPane tabContent = (AnchorPane) myTabs.getTabs().get(i).getContent();
			ScrollPane content = (ScrollPane) tabContent.getChildren().get(0);
			myContentManager.setUpContentBox(content, ContentBox.fromInteger(i)); // add scrollpanes
		}
		myContentManager.setUpContentBox(categoryPane,ContentBox.CATEGORY);
	}

	private void setUpTabDisplay() {
		currentTab = 0;
		input.requestFocus();
		displayTabContents(ContentBox.THIS_WEEK);
	}
	
	private void setUpButtonStyles() {
		crossButton.setImage(UiImageManager.getInstance().getImage(ImageID.CROSS_DEFAULT)); 
		minusButton.setImage(UiImageManager.getInstance().getImage(ImageID.MINUS_DEFAULT)); 
	}
	
	/**
	 * Sets up variables related to input, including feedbacks
	 */
	private void setUpInput() {
		input.getStyleClass().add(UiConstants.STYLE_TEXT_ALL);
		input.getStyleClass().add(UiConstants.STYLE_INPUT_NORMAL);		
		inputHistory = new ArrayList<String>();
		historyIterator = 0;
		shakeNotification = UiAnimationManager.getInstance().createShakeTransition(notification, 
																	   UiConstants.DEFAULT_SHAKE_DISTANCE, 
																	   UiConstants.DEFAULT_SHAKE_INTERVAL, 
																	   UiConstants.DEFAULT_ANIM_DURATION);
	}
	
	private void registerEventHandlersToNodes(Parent root) {
		registerInputEventHandler();
		registerRootEventHandler(root);
		registerDragHandler();
		registerButtonHandlers();
	}
	
	private void setUpLogic() {
		logic = new Logic();
		updateAllContents(logic.getTagCategoryList(),logic.getAllTaskLists());
	}
	
	private void displayTabContents(ContentBox toContent) {
		SingleSelectionModel<Tab> selectionModel = myTabs.getSelectionModel();
		selectionModel.select(toContent.getValue());
	}
	
	private ContentBox getCurrentContent() {
		currentContent = ContentBox.fromInteger(myTabs.getSelectionModel().getSelectedIndex());
		return currentContent;
	}
	
	/**
	 * Sets scene style sheets, input is assumed to be valid before calling
	 * this method, if input is invalid, prints an exception message
	 *
	 * @param styleSheets - style sheets to use for the display as an Array List
	 */
	public void setStyleSheets(ArrayList<String> styleSheets) {
		assert(styleSheets != null);
		ObservableList<String> myStyleSheets = stage.getScene().getStylesheets();
		myStyleSheets.clear();
		try {
			for (int i = 0; i < styleSheets.size(); i++) { // load all style sheets into list
				myStyleSheets.add(getClass().getResource(UiConstants.UI_CSS_PATH_OFFSET 
														 + styleSheets.get(i)).toExternalForm());
			}
		} catch (Exception excep) {
			System.out.println(excep + UiConstants.STYLE_SHEETS_LOAD_FAIL);
		}
	}
	
	private void handleFeedback( LogicFeedback feedback ) {
		assert(feedback != null);
		Exception statusCode = feedback.getException();
		if ( statusCode != null ) {
			notification.setText(statusCode.getMessage());	
			shakeNotification.playFromStart();
		}
		
		ArrayList<ArrayList<Task>> allLists = feedback.getTaskLists();	
		ProcessedObject processed = feedback.getPo();
		String command = processed.getCommand();
		switch (command) {		 // change display based on which command was processed
			case "ADD_DEADLINE": 
			case "ADD_EVENT":
			case "ADD_FLOATING":
				displayTabContents(ContentBox.PENDING);
				break;
			case "VIEW_BASIC":
				if ( processed.getViewType().get(0).equals("help")) {
					displayTabContents(ContentBox.ACTION);
					myContentManager.setActionMode(UiConstants.ActionMode.HELP);
					return; // don't need to update all
				}
			case "VIEW_TAGS":
			case "SEARCH":
				displayTabContents(ContentBox.ACTION);
				myContentManager.setActionMode(UiConstants.ActionMode.LIST);
				break;	
			case "ERROR":
				return;
			default:
				break;
		}
		// just update all displays, rather than splitting it into each switch case
		updateAllContents(logic.getTagCategoryList(),allLists); 
	}
	
	/**
	 * Create a header of fixed categories for the category list
	 * @param allLists - all the task lists
	 * @return categoryListHeader
	 */
	private ArrayList<Triplet<Color, String, Integer>> createCategoriesHeader(ArrayList<ArrayList<Task>> allLists) {
		ArrayList<Triplet<Color,String,Integer>> categoryListHeader = new ArrayList<Triplet<Color,String,Integer>>();
		ArrayList<Task> pendingList = allLists.get(LogicMemory.INDEX_PENDING);
		ArrayList<Task> expiredList = allLists.get(LogicMemory.INDEX_EXPIRED);
		
		int priorityNums[] = new int[3];
		for ( int i = 0; i < pendingList.size(); i++ ) {
			priorityNums[pendingList.get(i).getPriority()-1]++; // increase numbers for each priority
		}
		for ( int i = 0; i < expiredList.size(); i ++ ) {
			priorityNums[expiredList.get(i).getPriority()-1]++; // do the same for expired
		}
		
		categoryListHeader.add(new Triplet<Color,String,Integer>(Color.RED,"HIGH", priorityNums[2]));
		categoryListHeader.add(new Triplet<Color,String,Integer>(Color.web("#e87301",1.0),"MED", priorityNums[1]));
		categoryListHeader.add(new Triplet<Color,String,Integer>(Color.GREEN,"LOW", priorityNums[0]));
		
		categoryListHeader.add(new Triplet<Color,String,Integer>(Color.CADETBLUE,"General",
																 allLists.get(LogicMemory.INDEX_FLOATING).size()));
		categoryListHeader.add(new Triplet<Color,String,Integer>(Color.CADETBLUE,"Deadlines",
																 allLists.get(LogicMemory.INDEX_DEADLINE).size()));
		categoryListHeader.add(new Triplet<Color,String,Integer>(Color.CADETBLUE,"Events",
																 allLists.get(LogicMemory.INDEX_EVENT).size()));
		categoryListHeader.add(new Triplet<Color,String,Integer>(Color.CADETBLUE,"Archive",
																 allLists.get(LogicMemory.INDEX_COMPLETED).size()));
		
		return categoryListHeader;
	}
	
	private void updateAllContents(ArrayList<TagCategory> tagList, ArrayList<ArrayList<Task>> allLists) {
		ArrayList<Triplet<Color,String,Integer>> categoryList = createCategoriesHeader(allLists);
		// Add tags in addition to the default categories
		for ( int i = 0 ; i < tagList.size(); i++ ) {
			categoryList.add(new Triplet<Color,String,Integer>(Color.DIMGRAY,tagList.get(i).getTagName(), 
															   tagList.get(i).getNumTags()));
		}
		// update every box
		myContentManager.updateCategoryContentBox(categoryList);
		myContentManager.updateContentBox(allLists.get(LogicMemory.INDEX_THIS_WEEK), UiConstants.ContentBox.THIS_WEEK);
		myContentManager.updateContentBox(allLists.get(LogicMemory.INDEX_PENDING), UiConstants.ContentBox.PENDING);
		myContentManager.updateContentBox(allLists.get(LogicMemory.INDEX_EXPIRED), UiConstants.ContentBox.EXPIRED);	
		myContentManager.updateContentBox(allLists.get(LogicMemory.INDEX_ACTION), UiConstants.ContentBox.ACTION);	
		expiredIcon.setText(String.valueOf(allLists.get(LogicMemory.INDEX_EXPIRED).size()));
	}
	
	public void cleanUp() {
		updateService.restart();
		myContentManager.cleanUp();
		UiPopupManager.getInstance().cleanUp();
	}
	
	//----------------------------------- EVENT HANDLERS -----------------------------------------
	private void registerInputEventHandler() {
		assert(input != null);
		input.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>() {
			public void handle(KeyEvent event) {			
				input.getStyleClass().remove(UiConstants.STYLE_INPUT_ERROR); // remove any error styles
				input.getStyleClass().remove(UiConstants.STYLE_INPUT_CORRECT); // remove any correct styles
				
				if ( isInputChanged(event.getCode()) == true ) {
					processAutoComplete();
				}
				if (event.getCode() == KeyCode.ENTER) {	
					processEnter();
				}
			}
		});
	
		// to override default events such as shifting the caret / cursor position to the start and end
		input.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
			public void handle(KeyEvent event) {
				if (event.getCode().isArrowKey()) {
					if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN) { 
						// get previous / next input history
						setInputFromHistory(event.getCode());
						event.consume();
					}
				} else if (event.getCode() == KeyCode.TAB) {
					event.consume();
				}
			};
		});
	}

	private boolean isInputChanged(KeyCode code) {
		if ( code.isArrowKey() == false && 
			 code.isDigitKey() ||
			 code.isLetterKey() || 
			 code == KeyCode.BACK_SPACE ||
			 code == KeyCode.SPACE) {
			return true;
		}
		return false;
	}
	
	private void processAutoComplete() {	
		if ( input.getText().isEmpty()) {
			myDropDown.closeMenu();
			return;
		}
		ArrayList<String> suggestions = logic.autoCompleteLine(input.getText().trim(), getCurrentContent());		
		if ( suggestions == null ) {
			input.getStyleClass().add(UiConstants.STYLE_INPUT_ERROR); // invalid input
			myDropDown.closeMenu();
		} else {
			input.getStyleClass().add(UiConstants.STYLE_INPUT_CORRECT); 		
			if ( suggestions.size() == 0 ) { // no suggestions but input is valid
				myDropDown.closeMenu();
			} else {
				myDropDown.updateMenuItems(suggestions);
				myDropDown.updateMenu();
			}
		}
	}
	
	/**
	 * This method adds a selection from the drop down
	 * to the input Textfield
	 * @param selection
	 */
	private void addSelectionToInput(String selection) {
		String currentLine = input.getText().trim();
		if ( selection.contains(currentLine)) { 
			input.setText(selection + " ");
		} else {	
			// special case
			currentLine = currentLine.replace("[", "[ "); // add space for processing
			currentLine = currentLine.replace("[  ", "[ "); // bound it within 1 space
			currentLine = currentLine.replace("]", " ]");
			currentLine = currentLine.replace("  ]", " ]"); 
			
			String [] lineTokens = currentLine.split(" ");		
			// remove all tokens from input that appear in current selection
			for ( int i = lineTokens.length-1; i >= 0; i-- ) {			
				if ( selection.contains(lineTokens[i])) {		
					// replace last occurrence of token
					int index = currentLine.lastIndexOf(lineTokens[i]);
					currentLine =  currentLine.substring(0, index) + 
					currentLine.substring(index + lineTokens[i].length(),currentLine.length()); 
				} else {
					break;
				}
			}	
			currentLine = currentLine.trim();
			input.setText(currentLine + " " + selection + " ");
		}
		input.selectEnd();
		input.deselect();
	}
	
	private void processEnter() {
		String selection = myDropDown.getSelectedItem();
		if ( selection.isEmpty() == false ) { // add selected item into input text
			addSelectionToInput(selection);
			myDropDown.closeMenu();
		} else  {
			String line = input.getText();
			if ( line.isEmpty() == false ) { // we send to command to logic for processing						
				input.clear();	
				myDropDown.closeMenu();
				handleFeedback(logic.executeCommand(getCurrentContent(),line));
				
				inputHistory.add(line);
				if ( inputHistory.size() > UiConstants.MAX_INPUT_HISTORY ) {
					inputHistory.remove(0);
					inputHistory.trimToSize();
				}
				historyIterator = inputHistory.size(); // set to size instead of size()-1, for up key to work properly
			} else {
				myContentManager.processEnter(getCurrentContent());
			}
		}
	}
	
	/**
	 * This method sets the textfield input depending on up and down arrows,
	 * which mean previous and next respectively.
	 * 
	 * @param code - KeyCode up or down
	 */
	private void setInputFromHistory( KeyCode code ) {
		if (inputHistory.size() != 0) {
			String line;
			if (code == KeyCode.UP) {
				historyIterator = Math.max(historyIterator - 1, 0);
			} else if (code == KeyCode.DOWN) {
				historyIterator++; 
			}
			if ( historyIterator > inputHistory.size()-1) {
				historyIterator = inputHistory.size(); // out of bounds
				line = "";
			} else {
				line = inputHistory.get(historyIterator);
			}
			input.setText(line);
		} else if ( code == KeyCode.DOWN ){ // wipe on down
			input.setText("");
		}
		input.selectEnd();
		input.deselect();
	}

	/**
	 * This method is for key inputs anywhere in main window
	 *
	 * @param root - root object of scene
	 */
	private void registerRootEventHandler(Parent root) {
		root.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
			public void handle(KeyEvent event) {
				handleKeyPressInRoot(event);
			}
		});
		
		root.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>() {
			public void handle(KeyEvent event) {
				handleKeyReleaseInRoot(event);
			}
		});
	}
	
	private void handleKeyPressInRoot(KeyEvent event) {
		input.requestFocus(); // give focus to textfield on any inputs
		
		if (myDropDown.isMenuShowing()) {
			if (event.getCode().isArrowKey()) {	
				if ( event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN) {
					myDropDown.processArrowKey(event);
					event.consume(); // give input only to drop down
				} else {
					myDropDown.closeMenu();
				}
			}
		} else if (input.getText().isEmpty()) { // user not typing in command, do pagination
			if (event.getCode() == KeyCode.DELETE) {
				int id = myContentManager.processDelete(getCurrentContent());
				if (id != 0) {
					handleFeedback(logic.executeCommand(getCurrentContent(), "del " + id));
				}
			} else if ( event.getCode().isArrowKey()) {
				if  ( event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT) {
					myContentManager.processArrowKey(event, getCurrentContent());
				}
			}
		}
		if ( event.getCode() == KeyCode.PAGE_UP || event.getCode() == KeyCode.PAGE_DOWN) {
			myContentManager.processPageUpAndDown(event, getCurrentContent());
		}
	}
	
	private void handleKeyReleaseInRoot(KeyEvent event) {
		if (event.getCode() == KeyCode.TAB) {
			currentTab = myTabs.getSelectionModel().getSelectedIndex();
			currentTab = (currentTab + 1) % myTabs.getTabs().size();
			displayTabContents(ContentBox.fromInteger(currentTab));
			event.consume();
		} else if (event.getCode() == KeyCode.ESCAPE) {
			doSaveOnExit();
		} else if (event.isControlDown() && event.getCode() == KeyCode.W){ // minimize
			crossButton.setImage(UiImageManager.getInstance().getImage(ImageID.CROSS_DEFAULT));  
			stage.close();
		} else if (event.getCode() == KeyCode.F1) {
			myContentManager.setActionMode(ActionMode.HELP);
			displayTabContents(ContentBox.ACTION);
		} else if (event.getCode() == KeyCode.F2) {
			setStyleSheets(UiConstants.STYLE_UI_DEFAULT);
		} else if (event.getCode() == KeyCode.F3) {
			setStyleSheets(UiConstants.STYLE_UI_LIGHT);
		} else if ( event.getCode() == KeyCode.Z && event.isControlDown()) { // undo
			handleFeedback(logic.executeCommand(getCurrentContent(), "undo"));
		}
	}
	
	private void registerDragHandler() {
		assert(dragBar != null);
		dragBar.setOnMousePressed(new EventHandler<MouseEvent>() {
			@Override public void handle(MouseEvent mouseEvent) {
			    // record X,Y differences
				mouseX = (int) (stage.getX() - mouseEvent.getScreenX());
				mouseY = (int) (stage.getY() - mouseEvent.getScreenY());
		  }
		});
		dragBar.setOnMouseDragged(new EventHandler<MouseEvent>() {
			  @Override public void handle(MouseEvent mouseEvent) {
			  	stage.setX(mouseEvent.getScreenX() + mouseX);
			    stage.setY(mouseEvent.getScreenY() + mouseY);
			    myDropDown.closeMenu();
			  } 
		});
	}
	
	private void registerButtonHandlers() {
		assert(crossButton != null);
		assert(minusButton != null);	
		crossButton.setOnMousePressed(new EventHandler<MouseEvent>() {
			@Override public void handle(MouseEvent mouseEvent) {
				crossButton.setImage(UiImageManager.getInstance().getImage(ImageID.CROSS_SELECT));
		  }
		});
		crossButton.setOnMouseReleased(new EventHandler<MouseEvent>() {
			@Override public void handle(MouseEvent mouseEvent) {
				// 1st level intersect
				if ( mouseEvent.getPickResult().getIntersectedNode() == crossButton) {
					doSaveOnExit();
				} else {
					crossButton.setImage(UiImageManager.getInstance().getImage(ImageID.CROSS_DEFAULT));  
				}
			}
		});
		minusButton.setOnMousePressed(new EventHandler<MouseEvent>() {
			@Override public void handle(MouseEvent mouseEvent) {
				minusButton.setImage(UiImageManager.getInstance().getImage(ImageID.MINUS_SELECT));
		  }
		});
		minusButton.setOnMouseReleased(new EventHandler<MouseEvent>() {
			@Override public void handle(MouseEvent mouseEvent) {
				if ( mouseEvent.getPickResult().getIntersectedNode() == minusButton) {
					minusButton.setImage(UiImageManager.getInstance().getImage(ImageID.MINUS_DEFAULT)); 
					stage.close();
				} else {
					minusButton.setImage(UiImageManager.getInstance().getImage(ImageID.MINUS_DEFAULT)); 
				}
			}
		});
	}
	
	public void doSaveOnExit() {
		logic.executeCommand(getCurrentContent(), "save");
		System.exit(0);
	}
}
```
###### \taskey\src\taskey\ui\UiDropDown.java
``` java
 * This class implements the dropdown box used by AutoComplete
 * Note that the menu created is not within the main window,
 * but as a dropDown box implemented in a pop up
 * 
 * @author JunWei
 */

public class UiDropDown {
	private static final int TEXT_SIZE_FROM_CSS = 15; // these have to be referenced from sharedStyles.css
	private static final String FONT_NAME_FROM_CSS = "Montserrat";
	private static final int DROPDOWN_OFFSET = 10; // so dropdown doesn't cover text if window is too big
	
	private TextField inputBox;
	private Window mainWindow;
	private Popup myMenu = null;
	private FadeTransition fade;
	private StackPane selectedPane; // selected stack pane for styling
	private int currentSelection;
	private int currentItemSize;
	
	public void createMenu(Stage primaryStage, TextField input) {
		assert(input != null);
		assert(primaryStage != null);
		
		TaskeyLog.getInstance().log(LogSystems.UI, "Setting up Drop down Menu...", Level.ALL);
		
		// set up references
		inputBox = input; 
		mainWindow = primaryStage.getScene().getWindow();
		myMenu = UiPopupManager.getInstance().createPopupMenu();
		createFadeAnimation();
		currentItemSize = 0;
		currentSelection = -1;
		selectedPane = null;
		
		TaskeyLog.getInstance().log(LogSystems.UI, "Drop down menu has been set up...", Level.ALL);
	}

	private void createFadeAnimation() {
		fade = UiAnimationManager.getInstance().createFadeTransition(myMenu.getContent().get(0), 
				 UiConstants.DEFAULT_FADE_START_DELAY*5, 
				 UiConstants.DEFAULT_ANIM_DURATION, 1.0, 0.0);
		// create custom handler
		fade.setOnFinished(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				closeMenu();
			}
		});
	}
	
	public void updateMenuItems(ArrayList<String> items) {
		assert(items != null);
		currentItemSize = items.size(); 
		deSelect();
		if ( items.size() == 0 ) {		
			return;
		}
		int longestIndex = findIndexOfLongestItem(items);
		createStackPanes(items,longestIndex);
	}
	
	private int findIndexOfLongestItem(ArrayList<String> items) {
		int longestIndex = 0;
		// find longest text bounds
		Text longest = new Text(items.get(0));
		// setting font for Text recalculates layout bounds
		longest.setFont(Font.font(FONT_NAME_FROM_CSS, TEXT_SIZE_FROM_CSS));
		for ( int i = 1; i < items.size(); i++) {
			Text itemText = new Text(items.get(i));
			itemText.setFont(Font.font(FONT_NAME_FROM_CSS, TEXT_SIZE_FROM_CSS)); 
			if ( itemText.getLayoutBounds().getWidth() > longest.getLayoutBounds().getWidth() ) {
				longest = itemText;
				longestIndex = i;
			}
		}
		return longestIndex;
	}
	
	private void createStackPanes(ArrayList<String> items, int longestIndex) {
		VBox myContent = (VBox) myMenu.getContent().get(0);
		ObservableList<Node> menuItems = myContent.getChildren(); // list of stack panes
		menuItems.clear();
		
		StackPane longestPane = new StackPane();
		Label longestLabel = new Label(items.get(longestIndex)); 
		longestPane.getChildren().add(longestLabel);
		
		for (int i = 0; i < items.size(); i++) {
			if ( i == longestIndex ) {
				myContent.getChildren().add(longestPane);
			} else {
				StackPane myPane = new StackPane();
				Label myLabel = new Label(items.get(i));
				myPane.getChildren().add(myLabel);
				
				 // bind width (calculations delay till stage is shown)
				myLabel.prefWidthProperty().bind(longestPane.widthProperty());				
				myContent.getChildren().add(myPane);
			}
		}	
		// add styles
		for ( int i = 0; i < myContent.getChildren().size(); i ++ ) {
			StackPane currentPane = (StackPane) myContent.getChildren().get(i);
			Label currentLabel = (Label) currentPane.getChildren().get(0);
			currentLabel.getStyleClass().add(UiConstants.STYLE_TEXT_ALL);
			currentLabel.getStyleClass().add(UiConstants.STYLE_PROMPT_DEFAULT);
		}
	}
	
	/**
	 * Update menu, called to update position and correct the display issues.
	 */
	public void updateMenu() {
		if (mainWindow == null || myMenu == null) { // if not initialized yet and received input
			return;
		}
		String line = inputBox.getText();
		if (line.equals("")) {
			closeMenu();
		} else {
			refresh();  // fix display issues
			ShiftMenu();
		}
	}

	private void ShiftMenu() {
		assert(inputBox != null);
		double width = getWidthOfTextFieldInput(inputBox);
		Bounds bounds = inputBox.getBoundsInLocal();
		Bounds screenBounds = inputBox.localToScreen(bounds);
		UiPopupManager.getInstance().resize(myMenu);

		// restrict menu from stretching beyond the TextField
		myMenu.setAnchorX(Math.min(screenBounds.getMinX() + inputBox.getWidth() * UiPopupManager.getInstance().getXRatio(), 
								   screenBounds.getMinX() + width * UiPopupManager.getInstance().getXRatio()));
		myMenu.setAnchorY(screenBounds.getMinY() + inputBox.getHeight() * UiPopupManager.getInstance().getYRatio());
		myMenu.setAnchorX(myMenu.getAnchorX() + DROPDOWN_OFFSET * UiPopupManager.getInstance().getXRatio());
	}

	/**
	 * This method creates a Text object to approximate the bounds of a text
	 * field input.
	 *
	 * @param field - TextField to approximate from
	 * @return width
	 */
	private double getWidthOfTextFieldInput(TextField field) {
		assert(field != null);
		Text text = new Text(field.getText());
		text.setFont(Font.font(FONT_NAME_FROM_CSS, TEXT_SIZE_FROM_CSS)); 
		double width = text.getLayoutBounds().getWidth();
		return width;
	}
	
	public String getSelectedItem() {
		assert(myMenu.getContent().get(0) != null);
		if ( currentSelection == -1 ) {
			return "";
		}
		ObservableList<Node> menuItems = ((VBox)myMenu.getContent().get(0)).getChildren(); // list of stack panes
		StackPane myPane = (StackPane) menuItems.get(currentSelection);
		Label content = (Label)myPane.getChildren().get(0);
		return content.getText();
	}

	public void closeMenu() {
		assert(myMenu != null);
		myMenu.hide();
		currentItemSize = 0;
		deSelect();
	}
	
	public boolean isMenuShowing() {
		assert(myMenu != null);
		return myMenu.isShowing();
	}
	
	/**
	 * Most of the time after switching styles or setting visibility
	 * The popup window has some tears, probably because it renders separately from the main program
	 * This fixes that issue
	 */
	private void refresh() {
		assert(myMenu != null);
		assert(fade != null);
		myMenu.hide();
		restartFade();
		myMenu.show(mainWindow);
	}
	
	/**
	 * This method sets opacity full for the menu
	 */
	private void restartFade() {
		fade.stop();
		fade.getNode().setOpacity(1);
		fade.playFromStart();
	}
	
	private void deSelect() {
		if ( selectedPane != null ) {
			Label toStyle = (Label) selectedPane.getChildren().get(0);
			toStyle.getStyleClass().remove(UiConstants.STYLE_PROMPT_SELECTED);
			toStyle.getStyleClass().add(UiConstants.STYLE_PROMPT_DEFAULT);
			selectedPane = null;
			currentSelection = -1;
		}	
	}
	
	private void select(int selection) {
		VBox myContent = (VBox) myMenu.getContent().get(0);
		assert(selection >= 0 && selection < myContent.getChildren().size());

		deSelect(); // remove styles first if any
		
		// do selection
		currentSelection = selection;
		ObservableList<Node> menuItems = ((VBox)myMenu.getContent().get(0)).getChildren(); // list of stack panes
		selectedPane = (StackPane) menuItems.get(currentSelection);
		Label toStyle = (Label) selectedPane.getChildren().get(0);
		toStyle.getStyleClass().remove(UiConstants.STYLE_PROMPT_SELECTED);
		toStyle.getStyleClass().add(UiConstants.STYLE_PROMPT_SELECTED);
		restartFade();
	}
	
	public void processArrowKey(KeyEvent event) {
		assert(event != null);
		if ( currentItemSize == 0 ) {
			return;
		}
		if ( event.getCode() == KeyCode.DOWN) {
			select((currentSelection + 1) % currentItemSize);
		} else if ( event.getCode() == KeyCode.UP) {
			select((currentSelection - 1) < 0 ? currentItemSize - 1 : currentSelection - 1);
		}
	}
}
```
###### \taskey\src\taskey\ui\UiMain.java
``` java
 * This class is the main entry point for Taskey. 
 * It performs the main setups for the UI.
 *
 * @author JunWei
 */

public class UiMain extends Application {

	private UiAlertsController alertController;
	private UiController myController;
	private UiTrayModule trayModule;
	
	/**
	 * This method loads the .fxml file and returns a region object
	 *
	 * @param theController - the class to set as controller
	 * @param fileName - name of fxml file
	 */
	private Region loadFXML(Object theController, String fileName) {
		FXMLLoader myloader = new FXMLLoader(getClass().getResource(fileName));
		Region contentRootRegion = null;
		myloader.setController(theController);
		try {
			contentRootRegion = (Region) myloader.load();
		} catch (IOException e) {
			System.out.println(UiConstants.FXML_LOAD_FAIL);
		}
		return contentRootRegion;
	}
	
	/**
	 * This method is the main entry point for javafx, it performs initializations
	 * 
	 * @param primaryStage is passed from Application
	 */
	@Override
	public void start(Stage primaryStage) {
		TaskeyLog.getInstance().addHandler(LogSystems.UI, "UiLog.txt", 1);
		TaskeyLog.getInstance().log(LogSystems.UI, "Setting up the program UI...", Level.ALL);
		
		UiImageManager.getInstance().loadImages();
		myController = new UiController();
		alertController = new UiAlertsController();
		
		// set up main window
		Parent root = setUpResize(primaryStage, loadFXML(myController,UiConstants.FXML_PATH));
		setUpScene(primaryStage, root); // set up main scene
		// set up alert window
		alertController.setUpStage(loadFXML(alertController,UiConstants.FXML_ALERT_PATH));
		
		trayModule = new UiTrayModule();
		trayModule.initTrayVariables(primaryStage);
		trayModule.createLinkage(myController, alertController); 
		
		TaskeyLog.getInstance().log(LogSystems.UI, "UI has been set up...", Level.ALL);
	}
	
	/**
	 * This method setups the scene for resizing, by placing all the nodes inside a group object centered in a StackPane
	 * and setting its scale according to the size of the scene
	 * 
	 * Credits: http://gillius.org/blog/2013/02/javafx-window-scaling-on-resize.html
	 */
	private Region setUpResize(Stage primaryStage, Region contentRootRegion) {
		 //Set a default "standard" or "100%" resolution
	    double origW = UiConstants.WINDOW_MIN_SIZE.getWidth()*2;
	    double origH = UiConstants.WINDOW_MIN_SIZE.getHeight()*2;
		// If the Region containing the GUI does not already have a preferred
		// width and height, set it.
		// But, if it does, we can use that setting as the "standard"
		// resolution.
		if (contentRootRegion.getPrefWidth() == Region.USE_COMPUTED_SIZE)
			contentRootRegion.setPrefWidth(origW);
		else
			origW = contentRootRegion.getPrefWidth();

		if (contentRootRegion.getPrefHeight() == Region.USE_COMPUTED_SIZE)
			contentRootRegion.setPrefHeight(origH);
		else
			origH = contentRootRegion.getPrefHeight();

		// Wrap the resizable content in a non-resizable container (Group)
		Group group = new Group(contentRootRegion);
		// Place the Group in a StackPane, which will keep it centered
		StackPane rootPane = new StackPane();
		rootPane.getChildren().add(group);

		Scene newScene = new Scene(rootPane, origW, origH);
		primaryStage.setScene(newScene);
		// Bind the scene's width and height to the scaling parameters on the group
		group.scaleXProperty().bind(newScene.widthProperty().divide(origW));
		group.scaleYProperty().bind(newScene.heightProperty().divide(origH));

		// set event handlers / listeners
		UiResizeListener listener = new UiResizeListener(newScene, primaryStage);
		newScene.setOnMouseMoved(listener);
		newScene.setOnMousePressed(listener);
		newScene.setOnMouseDragged(listener);
		return contentRootRegion;
	}

	/**
	 * This method setups the main scene window, calls UiController to
	 * set up nodes
	 * 
	 * @param primaryStage - The main stage from start()
	 * @param root which is obtained after loading the .fxml file
	 *             
	 */
	private void setUpScene(Stage primaryStage, Parent root) {
		primaryStage.setTitle(UiConstants.PROGRAM_NAME);
		primaryStage.initStyle(StageStyle.UNDECORATED);
		primaryStage.getIcons().add(UiImageManager.getInstance().getImage(ImageID.WINDOW_ICON));

		myController.setUpController(primaryStage, root); // must be done after loading .fxml file
		myController.setStyleSheets(UiConstants.STYLE_UI_DEFAULT);
		primaryStage.show();
		myController.setUpNodesWhichNeedBounds(); // layout bounds of nodes are only updated on primaryStage.show()	
	}

	/**
	 * This method is overridden from Application to handle clean ups.
	 */
	@Override
	public void stop() {
		myController.cleanUp();
		UiImageManager.getInstance().cleanUp();
	}
	
	public static void main(String[] args) {
		launch(args); // calls the start() method
	}
}
```
###### \taskey\src\taskey\ui\UiResizeListener.java
``` java
 * 
 * This class implements a stage resizelistener
 * Adapted and modified from:  
 * https://geektortoise.wordpress.com/2014/02/07/how-to-programmatically-resize-the-stage-in-a-javafx-app/
 * 
 * @author JunWei
 */
class UiResizeListener implements EventHandler<MouseEvent> {
	
	private double dx, dy;
	private boolean resizeH = false, resizeV = false;
	private Scene scene;
	private Stage stage;
	private double aspectRatio;
	
	public UiResizeListener(Scene theScene, Stage theStage) {
		scene = theScene;
		stage = theStage;
		aspectRatio = UiConstants.WINDOW_MIN_SIZE.getWidth() / UiConstants.WINDOW_MIN_SIZE.getHeight();
	}
	
	@Override
	public void handle(MouseEvent t) {
		if (MouseEvent.MOUSE_MOVED.equals(t.getEventType())) {
			if (t.getX() > scene.getWidth() - UiConstants.WINDOW_RESIZE_PICK_BOUNDS && 
			    t.getY() > scene.getHeight() - UiConstants.WINDOW_RESIZE_PICK_BOUNDS) {
				scene.setCursor(Cursor.SE_RESIZE);
				resizeH = true;
				resizeV = true;
			} else {
				scene.setCursor(Cursor.DEFAULT);
				resizeH = false;
				resizeV = false;
			}
		} else if (MouseEvent.MOUSE_PRESSED.equals(t.getEventType())) {
			dx = stage.getWidth() - t.getX();
			dy = stage.getHeight() - t.getY();
		} else if (MouseEvent.MOUSE_DRAGGED.equals(t.getEventType())) {
			if (resizeH) {
				if ( t.getX() + dx >= UiConstants.WINDOW_MIN_SIZE.getWidth() ) {
					stage.setWidth(t.getX() + dx);		
				} else {
					stage.setWidth(UiConstants.WINDOW_MIN_SIZE.getWidth());
				}
			}
			if (resizeV) {
				if ( t.getY() + dy >= UiConstants.WINDOW_MIN_SIZE.getHeight() ) {
					stage.setHeight(t.getY() + dy);
				} else {
					stage.setHeight(UiConstants.WINDOW_MIN_SIZE.getHeight());
				}
			}
			if ( resizeH || resizeV ) {
				checkAspectRatio();
				UiPopupManager.getInstance().updateWindowRatios(stage);
			}
		}
	}

	/**
	 * This method ensures that the window will always stay in proportions
	 */
	private void checkAspectRatio() {
		double currentAspectRatio = stage.getWidth() / stage.getHeight();
		if ( currentAspectRatio < aspectRatio ) { // width is smaller in aspect
			stage.setWidth(stage.getWidth() * aspectRatio / currentAspectRatio);
		} else if ( currentAspectRatio > aspectRatio ) {
			stage.setHeight(stage.getHeight() * currentAspectRatio/ aspectRatio );
		}
	}
}
```
###### \taskey\src\taskey\ui\UiTrayModule.java
``` java
* This class implements a tray module for the program, adapted from 
* http://stackoverflow.com/questions/14626550/to-hide-javafx-fxml-or-javafx-swing-application-to-system-tray
* It also acts as the main interface between uiController and alertsController
* and performs all window close/open call backs
* @author alvaro, junwei
* 
*/

public class UiTrayModule {
	private SystemTray tray = null;
	private TrayIcon trayIcon;
	private UiController mainController;
	private UiAlertsController alertsController;
	
	/**
	 * This method creates the dependency link between the alertsController and the uiController
	 * @param myController - main Stage
	 * @param alertController - alerts Stage
	 */
	public void createLinkage(UiController _mainController, UiAlertsController _alertsController) {
		assert(_mainController != null);
		assert(_alertsController != null);
		
		Platform.setImplicitExit(false); // such that stage hide does not exit program
		
		mainController = _mainController;
		alertsController = _alertsController;
		
		Stage mainStage =  mainController.getStage();
		Stage alertsStage = alertsController.getStage();
		
		mainController.setUpUpdateService(alertsController); // starts update service with alertController
		registerMainControllerHandlers(mainStage,alertsStage);
		registerAlertsControllerHandlers(mainStage,alertsStage);
	}
	
	/**
	 * Register handlers that wait for stage open / close
	 * and perform the necessary functions
	 * @param mainStage
	 * @param alertStage
	 */
	private void registerMainControllerHandlers(Stage mainStage, Stage alertStage) {
		assert(mainStage != null);
		assert(alertStage != null);
		
		mainStage.setOnHidden(new EventHandler<WindowEvent>() {
			@Override
			public void handle(WindowEvent t) {	
				if ( tray != null ) {		
					try {
						tray.add(trayIcon); // do note that the same trayIcon cannot be added twice
					} catch (AWTException e) {
						e.printStackTrace();
					}
				}
				hide(mainStage);
				alertsController.show();
			}
		});
		
		mainStage.setOnShown(new EventHandler<WindowEvent>() {
			@Override
			public void handle(WindowEvent t) {
				if ( tray != null ) {
					tray.remove(trayIcon); 
				}
			}
		});
	}
	
	private void registerAlertsControllerHandlers(Stage mainStage, Stage alertsStage) {
		alertsStage.setOnHidden(new EventHandler<WindowEvent>() {
			@Override
			public void handle(WindowEvent t) {	
				alertsController.hide();
				mainStage.show();
			}
		});
		
		alertsStage.setOnShown(new EventHandler<WindowEvent>() {
			@Override
			public void handle(WindowEvent t) {
				mainController.updateAlerts();
			}
		});
	}
	
	public void initTrayVariables(final Stage stage) {
		TaskeyLog.getInstance().log(LogSystems.UI, "Setting up Tray...", Level.ALL);
		
		if (SystemTray.isSupported()) {
			// get the SystemTray instance
			tray = SystemTray.getSystemTray();
			
			// create a action listeners to listen for default action executed on
			// the tray icon
			ActionListener showListener = new ActionListener() {
				@Override
				public void actionPerformed(java.awt.event.ActionEvent e) {
					Platform.runLater(new Runnable() {
						@Override
						public void run() {
							alertsController.hide();
							stage.show();
						}
					});
				}
			};
			
			ActionListener closeNoSaveListener = new ActionListener() {
				@Override
				public void actionPerformed(java.awt.event.ActionEvent e) {
					System.exit(0);
				}
			};
			
			ActionListener closeListener = new ActionListener() {
				@Override
				public void actionPerformed(java.awt.event.ActionEvent e) {
					mainController.doSaveOnExit();
				}
			};
			
			createTrayIcon(tray,showListener,closeNoSaveListener,closeListener);
		}
		
		TaskeyLog.getInstance().log(LogSystems.UI, "Tray has been set up...", Level.ALL);
	}
	
	private void createTrayIcon(SystemTray tray, 
								ActionListener showListener,
								ActionListener closeNoSaveListener,
								ActionListener closeListener) {
		// create a popup menu
		PopupMenu popup = new PopupMenu();
		MenuItem showItem = new MenuItem(UiConstants.TRAY_SHOW_OPTION);
		showItem.addActionListener(showListener);
		popup.add(showItem);

		MenuItem closeNoSaveItem = new MenuItem(UiConstants.TRAY_CLOSE_NO_SAVE_OPTION);
		closeNoSaveItem.addActionListener(closeNoSaveListener);
		popup.add(closeNoSaveItem);
		
		MenuItem closeItem = new MenuItem(UiConstants.TRAY_CLOSE_OPTION);
		closeItem.addActionListener(closeListener);
		popup.add(closeItem);
		
		// construct a TrayIcon
		BufferedImage trayIconImage = null;
		try {
			trayIconImage = ImageIO.read(getClass().getResource(UiConstants.TRAY_IMAGE_PATH));
		} catch (IOException e1) {
			System.out.println(UiConstants.TRAY_IMAGE_LOAD_FAIL);
		}
		int trayIconWidth = new TrayIcon(trayIconImage).getSize().width;

		trayIcon = new TrayIcon(trayIconImage.getScaledInstance(trayIconWidth, -1, Image.SCALE_SMOOTH), 
																UiConstants.PROGRAM_NAME, popup);
		// set the TrayIcon click properties
		trayIcon.addActionListener(showListener);
	}

	private void showProgramIsMinimizedMsg() {
		trayIcon.displayMessage(UiConstants.MINIMIZE_MESSAGE_HEADER, UiConstants.MINIMIZE_MESSAGE_BODY, 
								TrayIcon.MessageType.INFO);
	}

	private void hide(final Stage stage) {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				if (SystemTray.isSupported()) {
					stage.hide();
					showProgramIsMinimizedMsg();
				} else {
					System.exit(0);
				}
			}
		});
	}
}
```
###### \taskey\src\taskey\ui\UiUpdateService.java
``` java
 * This class performs a background service, which updates the UI date
 * and performs polling of logic to update the Alerts window
 *
 * @author JunWei
 */

public class UiUpdateService extends ScheduledService<Void> {

	private UiAlertsController alertController;
	private Label dateLabelRef;
	private Logic logicRef; // logic reference

	public UiUpdateService(Label dateLabel, Logic logic, UiAlertsController _alertController) {
		assert(dateLabel != null);
		assert(logic != null);
		dateLabelRef = dateLabel;
		logicRef = logic;
		alertController = _alertController;
		this.setDelay(new Duration(0));
		this.setPeriod(new Duration(UiConstants.UPDATE_SERVICE_INTERVAL));
	}

	@Override
	protected Task<Void> createTask() {
		Task<Void> myTask = new Task<Void>() {
			@Override
			public Void call() {
				Calendar cal = Calendar.getInstance(); // need to get a new updated instance every time
				Platform.runLater(new Runnable() { // let main thread handle the update
					@Override
					public void run() {		
						dateLabelRef.setText(UiConstants.CLOCK_DATE_FORMAT.format(cal.getTime()));
						pollFromLogic();
					}
				});
				return null;
			}
		};
		return myTask;
	}
	
	/**
	 * This method polls task lists from logic and updates the Alert Window
	 */
	public void pollFromLogic() {
		ArrayList<ArrayList<taskey.messenger.Task>> allLists = logicRef.getAllTaskLists();
		ArrayList<UiAlert> alertList = new ArrayList<UiAlert>();
		
		ArrayList<taskey.messenger.Task> expiredList = allLists.get(LogicMemory.INDEX_EXPIRED);
		for ( int i = 0; i < expiredList.size(); i++ ) {
			alertList.add(createAlert(expiredList.get(i), "This has expired!"));
		}
		
		ArrayList<taskey.messenger.Task> pendingList = allLists.get(LogicMemory.INDEX_PENDING);		
		for ( int i = 0; i < pendingList.size(); i++ ) {
			taskey.messenger.Task currentTask = pendingList.get(i);
			checkTaskBounds(currentTask,alertList);
		}
		
		alertController.setAllAlerts(alertList);
	}

	/**
	 * This methods adds periodic reminders for events and deadlines
	 * Note that intervals that are closer have higher precedence over further ones
	 * such that if there is 3 hours left, > 3 hours are not added as alerts
	 * 
	 * @param currentTask
	 * @param alertList
	 */
	private void checkTaskBounds(taskey.messenger.Task currentTask, ArrayList<UiAlert> alertList) {
		assert(currentTask != null);
		int secondsInOneHour = 3600;
		long currTimeInSeconds = System.currentTimeMillis()/1000;
		ArrayList<Integer> checkIntervals = new ArrayList<Integer>();
		for (int index = 0; index < UiConstants.HOUR_MARKS.length; index++) {
			checkIntervals.add(UiConstants.HOUR_MARKS[index]);
		}
		
		for ( int i = 0; i < checkIntervals.size(); i ++ ) {
			int hoursBefore = checkIntervals.get(i);
			int secondsBefore = secondsInOneHour * hoursBefore;
			if ( currentTask.getTaskType().equals("DEADLINE")) {
				if ( currentTask.getDeadlineEpoch() - currTimeInSeconds < secondsBefore) {
					alertList.add(createAlert(currentTask, "Within " + getHourString(hoursBefore) + " Left!"));
					break;
				}
			} else if ( currentTask.getTaskType().equals("EVENT")) {
				// event has started
				if (currTimeInSeconds >= currentTask.getStartDateEpoch() && 
					currentTask.getEndDateEpoch() > currTimeInSeconds && 
					currentTask.getEndDateEpoch() - currTimeInSeconds < secondsBefore) {
					alertList.add(createAlert(currentTask,
							"Event Ending within " + getHourString(hoursBefore) + "!"));
					break;
				// event has not started
				} else if ( currentTask.getStartDateEpoch() > currTimeInSeconds && 
							currentTask.getStartDateEpoch() - currTimeInSeconds  < secondsBefore) {
					alertList.add(createAlert(currentTask,
							"Event Starting within " + getHourString(hoursBefore) + "!"));
					break;
				} 
			}
		}
	}

	private String getHourString( int hours ) {
		assert(hours >= 0);
		// with or without the 's' at the end
		if ( hours <= 1 ) {
			return hours + " Hour";
		} else {
			return hours + " Hours";
		}
	}
	
	private UiAlert createAlert(taskey.messenger.Task fromTask, String msg) {
		assert(fromTask != null);
		UiAlert myAlert = new UiAlert(fromTask);
		myAlert.setMessage(msg);
		return myAlert;
	}
}
```
###### \taskey\src\taskey\ui\utility\UiAnimationManager.java
``` java
 * This class provides modified abstractions for some basic animations in javafx
 * as well as custom ones.
 *
 * @author JunWei
 * 
 */

public class UiAnimationManager {
	
	private static UiAnimationManager instance = null;
	private UiAnimationManager(){
	}
	public static UiAnimationManager getInstance() {
		if ( instance == null ) {
			instance = new UiAnimationManager();
		}
		return instance;
	}
	
	/**
	 * This method creates fade transitions for a node.
	 *
	 * @param theNode - node object to place animation on
	 * @param startDelay - delay before animation starts
	 * @param animDuration - how long to play the animation
	 * @param fromAlpha - start opacity
	 * @param toAlpha - end opacity
	 * @return - FadeTransition object for custom handling
	 */
	public FadeTransition createFadeTransition(Node theNode, int startDelay, int animDuration, 
											   double fromAlpha, double toAlpha) {
		assert(theNode != null);
		FadeTransition ft = new FadeTransition(Duration.millis(animDuration), theNode);
		ft.setDelay(Duration.millis(startDelay));
		theNode.setOpacity(fromAlpha);
		ft.setFromValue(theNode.getOpacity());
		ft.setToValue(toAlpha);
		return ft;
	}
	
	/**
	 * Creates the translate transition.
	 *
	 * @param theNode - the node
	 * @param source - the source x y
	 * @param dest - the dest x y
	 * @param animDuration - the anim duration
	 * @return - the translate transition
	 */
	public TranslateTransition createTranslateTransition(Node theNode, Pair<Double,Double> source, 
														 Pair<Double,Double> dest, int animDuration) {
		assert(theNode != null);
		TranslateTransition shift = new TranslateTransition();
		shift.setFromX(source.getKey());
		shift.setFromY(source.getValue());
		shift.setToX(dest.getKey());
		shift.setToY(dest.getValue());
		shift.setDuration(Duration.millis(animDuration));
		shift.setNode(theNode);
		return shift;	
	}
	
	/**
	 * Creates the scale transition
	 * @param theNode - the node
	 * @param scaleByX - scale to X
	 * @param scaleByY - scale to Y
	 * @param cycleCount - Number times to animate to and from initial scale
	 * @param autoReverse - Reverse scaling animation on finish
	 * @param animDuration - the anim duration
	 * @return - the scale transition
	 */
	public ScaleTransition createScaleTransition(Node theNode, double scaleByX, double scaleByY, int cycleCount, 
												 boolean autoReverse, int animDuration) {
		assert(theNode != null);
		ScaleTransition scale = new ScaleTransition(Duration.millis(animDuration), theNode);
		scale.setByX(scaleByX);
		scale.setByY(scaleByY);
		scale.setCycleCount(cycleCount);
		scale.setAutoReverse(autoReverse);
		return scale;
	}
	
	
	/**
	 * This method creates a shaking animation on the X axis
	 * using an Interpolator
	 * It does this using a Timeline, which has frames to set the translation
	 * 
	 * @param theNode - the node
	 * @param xShift - distance to shift on X
	 * @param interval - to set new translation
	 * @param animDuration - anim duration
	 * @return - the timeline 
	 */
	public Timeline createShakeTransition(Node theNode, int xShift, int interval, int animDuration) {
		assert(theNode != null);
		Interpolator WEB_EASE = Interpolator.SPLINE(0.25, 0.1, 0.25, 1);
		int numShifts = animDuration / interval; // milliseconds
		Timeline animation = new Timeline();
		// first frame
		animation.getKeyFrames().add(new KeyFrame(Duration.millis(0), 
									 new KeyValue(theNode.translateXProperty(), 0, WEB_EASE)));
		for (int i = 1; i < numShifts - 1; i++) {
			animation.getKeyFrames().add(new KeyFrame(Duration.millis(i * interval),
					new KeyValue(theNode.translateXProperty(), xShift, WEB_EASE)));
			xShift *= -1;
		}
		//last frame
		animation.getKeyFrames().add(new KeyFrame(Duration.millis(animDuration), 
									 new KeyValue(theNode.translateXProperty(), 0, WEB_EASE)));
		return animation;
	}
	
	/**
	 * Creates the timeline animation for shifting text around based on frames
	 * This is a little choppy at the moment, a better alternative is based on translation
	 * if getting bounds is not an issue
	 *
	 * @param theLabel- the label
	 * @param interval -the interval
	 * @param charsToSkip - chars to skip
	 * @param filler -the filler
	 * @return - the timeline
	 */
	public Timeline createTextWrapAnimation(Label theLabel, int interval, int charsToSkip, String filler) {
		assert(theLabel != null);
		Timeline timeline = new Timeline();
		timeline.setCycleCount(Timeline.INDEFINITE);
		timeline.setAutoReverse(true);

		KeyValue keyValue = new KeyValue(theLabel.scaleXProperty(), 1);
		Duration duration = Duration.millis(interval);
		EventHandler<ActionEvent> onFinished = new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {
				String myText = theLabel.getText();
				myText = myText.substring(charsToSkip, myText.length()) + myText.substring(0, charsToSkip);
				theLabel.setText(myText);
			}
		};

		KeyFrame keyFrame = new KeyFrame(duration, onFinished, keyValue);
		timeline.getKeyFrames().add(keyFrame);
		return timeline;
	}
}
```
###### \taskey\src\taskey\ui\utility\UiGridHelper.java
``` java
 * This class contains convenience methods to manipulate a GridPane
 * It is used by all operations that involve a gridpane, including UiAlertsController.
 * Hence it is a very important class
 * 
 * @author junwei
 * 
 */

public class UiGridHelper {
	
	private String defaultWrapperStyle; // used to style the initial StackPane in a cell on creation 
	public UiGridHelper(String wrapperStyle) {
		defaultWrapperStyle = wrapperStyle;
	}

	/**
	 * This sets up the grid using predefined GridSettings which only set for column constraints
	 * Row constraints have to be set manually.
	 *
	 * @param settings - the UiGridSettings
	 * @return - the grid pane
	 */
	public GridPane setUpGrid(UiGridSettings settings) {
		assert(settings != null);
		GridPane gridPane = new GridPane();
		gridPane.setPadding(settings.getPaddings());
		gridPane.setHgap(settings.getHGap());
		gridPane.setVgap(settings.getVGap());
		ArrayList<Integer> colPercents = settings.getColPercents();
		for (int i = 0; i < colPercents.size(); i++) {
			ColumnConstraints column = new ColumnConstraints();
			column.setPercentWidth(colPercents.get(i));
			gridPane.getColumnConstraints().add(column);
		}
		return gridPane;
	}

	/**
	 * Note that every cell in the grid is wrapped by a StackPane for styling
	 * @param col - the column
	 * @param row - the row
	 * @param cellStyle - the style you want to use
	 * @param gridPane - the grid pane
	 * @return
	 */
	public StackPane createStyledCell(int col, int row, String cellStyle, GridPane gridPane) {
		assert(gridPane != null);
		StackPane styledCell = new StackPane();
		styledCell.getStyleClass().add(cellStyle);
		gridPane.add(styledCell, col, row);
		return styledCell;
	}
	
	/**
	 * Gets the wrapper at cell. Note that the wrapper is a StackPane object which will be auto created 
	 * by createStyledCell if it does not exist
	 *
	 * @param col - the col
	 * @param row - the row
	 * @param gridPane - the grid pane
	 * @return - the wrapper at cell
	 */
	public StackPane getWrapperAtCell(int col, int row, GridPane gridPane ) {
		assert(gridPane != null);
		Node theNode = null;
		ObservableList<Node> childrens = gridPane.getChildren();
		for(int i = 0; i < childrens.size(); i ++ ) {
			if ( i == 0 && gridPane.isGridLinesVisible()) {
				continue; // skip the grid lines which have no row/col
			}
			Node node = childrens.get(i);
		    if(GridPane.getRowIndex(node) == row && GridPane.getColumnIndex(node) == col) {
		    	theNode = node;
		        break;
		    }
		}
		// create a cell if not available
		if ( theNode == null ) {
			theNode = createStyledCell(col,row,defaultWrapperStyle,gridPane);
		}
		return (StackPane)theNode;
	}
	
	public void addTextFlowToCell(int col, int row, TextFlow textFlow, TextAlignment align, GridPane gridPane ) {
		assert(gridPane != null);
		assert(textFlow != null);
		StackPane cellWrapper = getWrapperAtCell(col,row,gridPane);
		cellWrapper.getChildren().add(textFlow);
		textFlow.setTextAlignment(align);	
	}
	
	public void addCircleToCell(int col, int row, Circle circle, GridPane gridPane) {
		assert(gridPane != null);
		StackPane cellWrapper = getWrapperAtCell(col,row,gridPane);
		cellWrapper.getChildren().add(circle);
	}

	public ImageView createImageInCell( int col, int row, Image img, int width, int height, GridPane gridPane) {
		assert(gridPane != null);
		StackPane imageWrapper = getWrapperAtCell(col,row,gridPane);
		ImageView myImg = new ImageView(img);
		myImg.setFitHeight(width);
		myImg.setFitWidth(height);
		myImg.setPreserveRatio(true);
		imageWrapper.getChildren().add(myImg);
		return myImg;
	}
	
	public Label createLabelInCell( int col, int row, String text, String labelStyle, GridPane gridPane) {
		assert(gridPane != null);
		StackPane cellWrapper = getWrapperAtCell(col,row,gridPane);
		Label myLabel = new Label(text);
		myLabel.getStyleClass().add(UiConstants.STYLE_TEXT_ALL);
		myLabel.getStyleClass().add(labelStyle);
		cellWrapper.getChildren().add(myLabel);
		return myLabel;
	}		
	
	/**
	 * Stacks a pane onto the cell, note that to place elements in this new pane, it has to be done manually 
	 * for different formatters, methods for the single wrapper can still be used, but switch the parents
	 * @param col - the col
	 * @param row - the row
	 * @param paneStyle - the pane style
	 * @param gridPane - the grid pane
	 * @return - the stack pane
	 */ 
	public StackPane createStackPaneInCell( int col, int row, String paneStyle, GridPane gridPane) {
		assert(gridPane != null);
		StackPane cellWrapper = getWrapperAtCell(col,row,gridPane);
		StackPane pane = new StackPane();
		pane.getStyleClass().add(paneStyle);
		cellWrapper.getChildren().add(pane);
		return pane;
	}
	
	public Rectangle createScaledRectInCell( int col, int row, Color theColor, GridPane gridPane) {
		assert(gridPane != null);
		StackPane cellWrapper = getWrapperAtCell(col,row,gridPane);
		Rectangle scaledRect = new Rectangle(0,0,0,0);
		scaledRect.setFill(Paint.valueOf(theColor.toString()));
		cellWrapper.getChildren().add(scaledRect);

		double offset = 1.5f;
		// problem with precision which shifts the whole row, thus we subtract a fixed amount
		scaledRect.widthProperty().bind(cellWrapper.widthProperty().subtract(offset)); 
		scaledRect.heightProperty().bind(cellWrapper.heightProperty().subtract(offset));
		return scaledRect;
	}
}
```
###### \taskey\src\taskey\ui\utility\UiGridSettings.java
``` java
 * Helper class for static initialization objects for grid, placed in UiConstants.
 *
 * @author JunWei
 * 
 */

public class UiGridSettings {

	private int gridHGap;
	private int gridVGap;
	private int paddings;
	private ArrayList<Integer> colPercents;
	
	/**
	 * Instantiates a new ui grid settings.
	 *
	 * @param _gridHGap - the horizontal gap between cells
	 * @param _gridVGap - the vertical gap between cells
	 * @param _paddings - the insets of cells
	 * @param _colPercents - how much space a column occupies
	 */
	public UiGridSettings( int _gridHGap, int _gridVGap, int _paddings, int ... _colPercents) {
		gridHGap = _gridHGap;
		gridVGap = _gridVGap;
		paddings = _paddings;
		colPercents = new ArrayList<Integer>();
		for ( int percent : _colPercents ) {
			colPercents.add(new Integer(percent));
		}
	}
	
	public int getHGap() {
		return gridHGap;
	}
	
	public int getVGap() {
		return gridVGap;
	}
	
	public Insets getPaddings() {
		return new Insets(paddings);
	}
	
	public ArrayList<Integer> getColPercents() {
		return colPercents;
	}
}
```
###### \taskey\src\taskey\ui\utility\UiImageManager.java
``` java
 * This class handles loading of image resources 
 * which are likely to be permanent throughout the application life
 * 
 * @author Junwei
 *
 */
public class UiImageManager {
	
	/**
```
###### \taskey\src\taskey\ui\utility\UiImageManager.java
``` java
	private String helpFolder = UiConstants.UI_IMAGE_PATH_OFFSET + UiConstants.UI_IMAGE_HELP_PATH_OFFSET; // path
	private HashMap<ImageID, Image> myImageContainer = new HashMap<ImageID, Image>();
	
	private static UiImageManager instance = null;
	private UiImageManager() {
	}
	public static UiImageManager getInstance() {
		if ( instance == null ) {
			instance = new UiImageManager();
		}
		return instance;
	}
	
	public void loadImages() {
		try {
			myImageContainer.put(ImageID.WINDOW_ICON, 
					new Image(getClass().getResourceAsStream(UiConstants.UI_IMAGE_PATH_OFFSET + ImageID.WINDOW_ICON.filename)));
			myImageContainer.put(ImageID.CROSS_DEFAULT, 
					new Image(getClass().getResourceAsStream(UiConstants.UI_IMAGE_PATH_OFFSET + ImageID.CROSS_DEFAULT.filename)));
			myImageContainer.put(ImageID.CROSS_SELECT, 
					new Image(getClass().getResourceAsStream(UiConstants.UI_IMAGE_PATH_OFFSET + ImageID.CROSS_SELECT.filename)));
			myImageContainer.put(ImageID.MINUS_DEFAULT, 
					new Image(getClass().getResourceAsStream(UiConstants.UI_IMAGE_PATH_OFFSET + ImageID.MINUS_DEFAULT.filename)));
			myImageContainer.put(ImageID.MINUS_SELECT, 
					new Image(getClass().getResourceAsStream(UiConstants.UI_IMAGE_PATH_OFFSET + ImageID.MINUS_SELECT.filename)));
			myImageContainer.put(ImageID.URGENT_MARK, 
					new Image(getClass().getResourceAsStream(UiConstants.UI_IMAGE_PATH_OFFSET + ImageID.URGENT_MARK.filename)));
			myImageContainer.put(ImageID.FLOATING, 
					new Image(getClass().getResourceAsStream(UiConstants.UI_IMAGE_PATH_OFFSET + ImageID.FLOATING.filename)));
			myImageContainer.put(ImageID.DEADLINE, 
					new Image(getClass().getResourceAsStream(UiConstants.UI_IMAGE_PATH_OFFSET + ImageID.DEADLINE.filename)));
			myImageContainer.put(ImageID.EVENT, 
					new Image(getClass().getResourceAsStream(UiConstants.UI_IMAGE_PATH_OFFSET + ImageID.EVENT.filename)));
			
			loadHelpMenuImages();
			
		} catch ( NullPointerException e ) {
			System.out.println("Images cant be loaded for some reason, please refresh the taskey.ui.images package");
		}
	}
	
	/**
```
###### \taskey\src\taskey\ui\utility\UiImageManager.java
``` java
	 */
	public Image getImage(ImageID id) {
		Image theImage = myImageContainer.get(id);
		if ( theImage == null ) {
			System.out.println("Image not found by " + id);
		}
		return theImage;
	}

	public void cleanUp() {
		myImageContainer.clear();
	}
}
```
###### \taskey\src\taskey\ui\utility\UiPopupManager.java
``` java
 * This class creates various types of pop up windows, 
 * and provides methods to scale / hide pop ups as they are not handled by 
 * the main window.
 * 
 * @author JunWei
 *
 */

public class UiPopupManager {
	private double X_Ratio = 1, Y_Ratio = 1; // window ratios
	private ArrayList<Popup> popupList = new ArrayList<Popup>();
	private static UiPopupManager instance = null;
	private UiPopupManager() {
	}
	public static UiPopupManager getInstance() {
		if (instance == null) {
			instance = new UiPopupManager();
		}
		return instance;
	}
	
	/**
	 * This method creates a label at the node position with offset
	 * Note that this offset is in screen space coordinates
	 * 
	 * @param text - what to display in the label
	 * @param offsetX - from node X position
	 * @param offsetY - from node Y position
	 * @return Popup object
	 */
	public Popup createPopupLabelAtNode(String text, Node node, double offsetX, double offsetY, boolean deleteAfter) {
		assert(node != null);
		Popup thePopup = new Popup();
		Bounds bounds = node.getBoundsInLocal();
		Bounds screenBounds = node.localToScreen(bounds);
		Label content = new Label();
		content.setText(text);
		content.getStyleClass().add(UiConstants.STYLE_TEXT_ALL);
		content.getStyleClass().add(UiConstants.STYLE_PROMPT_SELECTED);
		thePopup.getContent().add(content);
		resize(thePopup);
		thePopup.show(node, screenBounds.getMinX() + offsetX * X_Ratio, 
							screenBounds.getMinY() + offsetY * Y_Ratio); // lower left hand corner  
		popupList.add(thePopup);
		
		if ( deleteAfter == true ) {
			FadeTransition fade = UiAnimationManager.getInstance().createFadeTransition(
					thePopup.getContent().get(0), UiConstants.DEFAULT_FADE_START_DELAY, 
					UiConstants.DEFAULT_ANIM_DURATION, 1.0, 0.0);
			fade.play();
			fade.setOnFinished(new EventHandler<ActionEvent>() {
				@Override
				public void handle(ActionEvent event) {
					removePopup(thePopup);
				}
			});
		}
		return thePopup;
	}

	/**
	 * This method sets the X and Y ratio of the stage
	 * such that when pop ups are created, they are positioned correctly
	 * but not scaled, or shifted as window changes
	 * these need to depend on anchor points which makes it difficult to alter 
	 * @param mainStage
	 */
	public void updateWindowRatios(Window mainStage) {
		X_Ratio = mainStage.getWidth()/2/UiConstants.WINDOW_MIN_SIZE.getWidth();
		Y_Ratio = mainStage.getHeight()/2/UiConstants.WINDOW_MIN_SIZE.getHeight();
		
		// one solution is to hide the pop up when window changes
		for ( int i = 0; i < popupList.size(); i ++  ) {
			Popup thePopup = (Popup) popupList.get(i);
			thePopup.hide();
		}
	}
	
	/**
	 * This method does a simple resize on a popup, assuming that the popup has a container
	 * which should always be the case if it is created using UiPopupManager
	 * @param popup
	 */
	public void resize(Popup popup) {
		Node content = popup.getContent().get(0);
		content.setScaleX(X_Ratio > 1 ? X_Ratio : 1); // such that problems with translation are avoided
		content.setScaleY(Y_Ratio > 1 ? Y_Ratio : 1); 
		// since nodes are positioned from top left and scaling is from center
	}
	
	public double getYRatio() {
		return Y_Ratio;
	}
	
	public double getXRatio() {
		return X_Ratio;
	}
	
	/**
	 * This method creates a pop up menu with a Popup container instead of a ContextMenu with MenuItems
	 * To provide more customization, this customization is provided by other classes, for example UiDropDown
	 * @param numRows
	 * @return Popup
	 */
	public Popup createPopupMenu() {
		Popup newPopup = new Popup();
		VBox container = new VBox(); // VBox is used only for formatting purposes purposes
		container.setFillWidth(true);
		newPopup.getContent().add(container);
		popupList.add(newPopup);
		return newPopup;
	}
	
	public void removePopup(Popup thePopup) {
		assert(thePopup != null);
		popupList.remove(thePopup);
	}
	
	public void cleanUp() {
		popupList.clear();
	}
}
```
###### \taskey\src\taskey\ui\utility\UiTextBuilder.java
``` java
 * This class provides a way to configure different styles given a string as input.
 * It builds an array of Text objects to be returned 
 *
 * @author Junwei
 * 
 */

public class UiTextBuilder {
	private ArrayList<Pair<Integer, String>> styleMarkers; 
	private char symbol; 
	
	public UiTextBuilder() {
		initVariables();
	}
	
	public UiTextBuilder(String ...styles) { // for quick styling (primarily for building by symbol
		initVariables();
		addMarkers(styles);
	}
	
	private void initVariables() {
		styleMarkers = new ArrayList<Pair<Integer, String>>(); // where to start certain styles 
		addMarker(0, UiConstants.STYLE_TEXT_BLACK); // default marker, will get overridden if there exists another marker at 0
		symbol = '$'; // default symbol
	}

	public void setSymbol(char _symbol) {
		symbol = _symbol;
	}
	
	public void addMarker(Integer startIndex, String style) {
		assert(startIndex >= 0);
		styleMarkers.add(new Pair<Integer, String>(startIndex, style));
	}
	
	// for buildBySymbol
	public void addMarkers(String ...styles) {
		for ( String style : styles) {
			styleMarkers.add(new Pair<Integer, String>(0, style));
		}
	}

	/**
	 * This method converts an arraylist of Text objects into a Textflow
	 * for displaying
	 * @param theText
	 * @return
	 */
	public TextFlow convertTextArray(ArrayList<Text> theText) {
		TextFlow element = new TextFlow();
		element.getChildren().addAll(theText);
		return element;
	}
	/**
	 * Builds the textFlow object based on the markers, which mark out certain segments of a text
	 * so that styles can be switched then
	 *
	 * @param line - the line to process
	 * @return - TextFlow object
	 */
	public TextFlow build(String line) {
		ArrayList<Text> myTexts = new ArrayList<Text>();
		int currentStart = styleMarkers.get(0).getKey();
		int currentEnd = 0;
		String currentStyle = "";
		String segment = "";

		// start segment
		if (currentStart != 0) {
			segment = line.substring(0, currentStart); // note substring excludes the end index
			Text newText = new Text(segment);
			myTexts.add(newText);
		}

		for (int i = 0; i < styleMarkers.size() && currentEnd < line.length(); i++) { // not end of line yet 
			currentStyle = styleMarkers.get(i).getValue();

			if (i == styleMarkers.size() - 1) { // just set the style for the rest of the string
				currentEnd = line.length();
			} else {
				currentEnd = Math.min(styleMarkers.get(i + 1).getKey(), line.length());
			}
			segment = line.substring(currentStart, currentEnd);
			Text newText = new Text(segment);
			newText.getStyleClass().add(UiConstants.STYLE_TEXT_ALL);
			newText.getStyleClass().add(currentStyle);
			myTexts.add(newText);
			currentStart = currentEnd;
		}
		return convertTextArray(myTexts);
	}
	
	/**
	 * Using a symbol like #, etc to build, reuse markers but not using indexes
	 * Markers are ignored in a queue-like fashion for each symbol encountered.
	 * This is very slow because it goes through each character, but is more convenient
	 *
	 * @param line - line to build text objects from
	 * @return - the text flow object
	 */
	public TextFlow buildBySymbol(String line) {
		ArrayList<Text> myTexts = new ArrayList<Text>();
		String segment = "";
		int styleIndex = 0;
		String currentStyle = "";
		for (int i = 0; i < line.length(); i++) { // not end of line yet 
			char c = line.charAt(i);
			if ( c != symbol ) {
				segment += c;
			} 
			if ( c == symbol || i == line.length() - 1) { // hit symbol or hit end of line
				if ( styleIndex < styleMarkers.size()) {
					currentStyle = styleMarkers.get(styleIndex).getValue();
					styleIndex++; // ignore previous style
				}
				Text newText = new Text(segment);
				newText.getStyleClass().add(UiConstants.STYLE_TEXT_ALL);
				newText.getStyleClass().add(currentStyle);
				myTexts.add(newText);
				segment = "";
			}
		}
		return convertTextArray(myTexts);
	}
}
```
###### \taskey\test\taskey\junit\LoggerTest.java
``` java
 * 
 * This class does some tests for TaskeyLog.
 * @author Junwei
 */

public class LoggerTest {

	@Test
	public void testHandlers() {
		Logger UiLog = TaskeyLog.getInstance().getLogger(LogSystems.UI);

		/* This is a boundary case for negative file count partition */
		try {
			TaskeyLog.getInstance().addHandler(LogSystems.UI, "test.out", -10);
		} catch (Exception e) {
			assertTrue(true);
		}
		assertTrue(UiLog.getHandlers().length == 0);
		TaskeyLog.getInstance().addHandler(LogSystems.UI, "test.out", 1);
		assertTrue(UiLog.getHandlers().length == 1);
		TaskeyLog.getInstance().addHandler(LogSystems.UI, "test2.out", 1);
		assertTrue(UiLog.getHandlers().length == 2);
		
		String longString = "";
		for ( int i = 0; i < 10000; i ++ ) { 
			longString += "aaaaaaaaaaa";	
		} 
		/* This is a boundary case for character counter > MAX_BYTES partition */
		TaskeyLog.getInstance().log(LogSystems.UI, longString,  Level.ALL);
		File fileOne = new File("logs/test.out");
		assertTrue(fileOne.exists());	
		assertTrue( fileOne.length() <= 100000); // overwrites repeatedly
		File fileTwo = new File("logs/test2.out");
		assertTrue(fileTwo.exists());	
		assertTrue( fileTwo.length() <= 100000);
	}
	
}
```
