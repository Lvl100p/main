# A0107345L
###### src\constants\ParserConstants.java
``` java
 * Constants for usage by the Parser package
 * @author Xue Hui
 *
 */
public class ParserConstants {
	public static final String FINISHED_COMMAND = "FINISHED_COMMAND";
	public static final String DISPLAY_COMMAND = "DISPLAY_COMMAND"; 
	public static final String NO_SUCH_COMMAND = "NO_SUCH_COMMAND"; 
	public static final String DELETE_BY_INDEX = "DELETE_BY_INDEX"; 
	public static final String DELETE_BY_NAME = "DELETE_BY_NAME"; 
	public static final String DELETE_BY_CATEGORY = "DELETE_BY_CATEGORY"; 
	public static final String DONE_BY_INDEX = "DONE_BY_INDEX"; 
	public static final String DONE_BY_NAME = "DONE_BY_NAME"; 
	public static final String UPDATE_BY_INDEX_CHANGE_NAME = "UPDATE_BY_INDEX_CHANGE_NAME"; 
	public static final String UPDATE_BY_INDEX_CHANGE_DATE = "UPDATE_BY_INDEX_CHANGE_DATE"; 
	public static final String UPDATE_BY_INDEX_CHANGE_BOTH = "UPDATE_BY_INDEX_CHANGE_BOTH";
	public static final String UPDATE_BY_INDEX_CHANGE_PRIORITY = "UPDATE_BY_INDEX_CHANGE_PRIORITY";
	public static final String UPDATE_BY_NAME_CHANGE_NAME = "UPDATE_BY_NAME_CHANGE_NAME";
	public static final String UPDATE_BY_NAME_CHANGE_DATE = "UPDATE_BY_NAME_CHANGE_DATE";
	public static final String UPDATE_BY_NAME_CHANGE_BOTH = "UPDATE_BY_NAME_CHANGE_BOTH";
	public static final String UPDATE_BY_NAME_CHANGE_PRIORITY = "UPDATE_BY_NAME_CHANGE_PRIORITY";
	public static final String NEW_FILE_LOC = "CHANGE_FILE_LOC"; 
	
	/* Errors */ 
	public static final String ERROR = "ERROR"; 
	public static final String ERROR_DATE_FORMAT = "Error: \"%s\" is not an accepted date format"; 
	public static final String ERROR_DATE_GRAMMAR = "Error: \"%s\" is a grammatically incorrect date"; 
	public static final String ERROR_DATE_KEYWORD = "Error: Date keywords detected but no date found";
	public static final String ERROR_VIEW_TYPE = "Error: \"%s\" is not a valid category"; 
	public static final String ERROR_VIEW_TYPE_TAG = "Error: \"%s\" is not a valid tag";
	public static final String ERROR_VIEW_EMPTY = "Error: No view type selected";
	public static final String ERROR_COMMAND = "Error: \"%s\" is not a valid command"; 
	public static final String ERROR_ADD_EMPTY = "Error: Cannot be an empty add";
	public static final String ERROR_ADD_INVALID_TAG = "Error: Invalid tags added to the task"; 
	public static final String ERROR_EVENT_TIME_INVALID = "Error: Event starting time cannot be later than the ending time"; 
	public static final String ERROR_ONLY_NUMS = "Error: Task name cannot consist entirely of numbers";
	public static final String ERROR_INPUT_EMPTY = "Error: Cannot be an empty change"; 
	public static final String ERROR_NAME_EMPTY = "Error: Task name/index is not given";
	public static final String ERROR_STRING_FORMAT = "Error: Wrong format for new task name/date";
	public static final String ERROR_DEL_EMPTY_CAT = "Error: Cannot delete an empty category!";
	public static final String ERROR_DEL_EMPTY = "Error: No task has been selected for deletion";
	public static final String ERROR_DONE_EMPTY = "Error: No task has been selected as done";
	public static final String ERROR_EMPTY_SEARCH = "Error: No search phrase entered"; 
	public static final String ERROR_SET_NEW_PRIORITY = "Error: Invalid task priority entered"; 
	
	/*Date Handling Constants*/
	public static final String DAY_END = "23:59:59"; 
	public static final String DAY_END_SHORT = "23:59"; 
	
	public static final long ONE_DAY = 86400; 
	public static final long TWO_DAYS = 2*ONE_DAY; 
	public static final long THREE_DAYS = 3*ONE_DAY; 
	public static final long FOUR_DAYS = 4*ONE_DAY; 
	public static final long FIVE_DAYS = 5*ONE_DAY; 
	public static final long SIX_DAYS = 6*ONE_DAY; 
	public static final long ONE_WEEK = 604800; 
}
```
###### src\messenger\ProcessedAC.java
``` java
 * This class is a short form for ProcessedAutoComplete.
 * It holds all the information that Logic needs to know about 
 * what list to display for the Auto Complete feature in the UI. 
 * 
 * Command Types: 
 * 1. DISPLAY_COMMAND : user is halfway through his command, show the list still
 * 2. FINISHED_COMMAND : user has completed typing his command, 
 * 						no need to display anything
 * 3. NO_SUCH_COMMAND : user keyed in a command that doesn't exist, show the red box 
 * 3. to be added when we add more auto complete features 
 * @author Xue Hui
 */
public class ProcessedAC {
	private String command = null; 
	private ArrayList<String> availCommands = null; 
	
	/**
	 * Constructs a ProcessedAC Object
	 * @param command
	 */
	public ProcessedAC(String command) {
		this.command = command; 
	}
	
	/**
	 * Overloaded constructor 
	 * @param command
	 * @param availCommands
	 */
	public ProcessedAC(String command, ArrayList<String> availCommands) {
		this.command = command; 
		this.availCommands = availCommands; 
	}
	
	/**
	 * @return command type
	 */
	public String getCommand() {
		return command;
	}
	
	/**
	 * Set the command type 
	 * @param command
	 */
	public void setCommand(String command) {
		this.command = command; 
	}
	
	/**
	 * @return availCommands to display to the user 
	 */
	public ArrayList<String> getAvailCommands() {
		return availCommands;
	}
	
	/**
	 * set a lit of commands to display to the user 
	 * @param availCommands
	 */
	public void setAvailCommands(ArrayList<String> availCommands) {
		this.availCommands = availCommands; 
	}
	
	/**
	 * For Debugging purposes
	 */
	public String toString() {
		String stringRep = ""; 
		
		if (command != null) {
			stringRep += "Command: " + command + "\n";
		}
		
		if (availCommands != null) {
			stringRep += "Options: "; 
			for(int i=0; i < availCommands.size(); i++) {
				stringRep += availCommands.get(i) + ", ";
			}
		}
		stringRep += "\n";
		
		return stringRep; 
	}
	
}
```
###### src\messenger\ProcessedObject.java
``` java
 * This class will be used for facilitating transfer of a processed task from 
 * Parser to Logic. 
 * 
 * command types:
 * 1. ADD_FLOATING
 * 2. ADD_DEADLINE
 * 3. ADD_EVENT
 * 4. ADD_RECURRING //not implementing 
 * 5. DELETE_BY_INDEX
 * 6. DELETE_BY_NAME 
 * 7. DELETE_BY_CATEGORY
 * 8. UPDATE_BY_INDEX_CHANGE_NAME
 * 9. UPDATE_BY_INDEX_CHANGE_DATE
 * 10. UPDATE_BY_INDEX_CHANGE_BOTH
 * 11. UPDATE_BY_INDEX_CHANGE_PRIORITY
 * 12. UPDATE_BY_NAME_CHANGE_NAME
 * 13. UPDATE_BY_NAME_CHANGE_DATE
 * 14. UPDATE_BY_NAME_CHANGE_BOTH
 * 15. UPDATE_BY_NAME_CHANGE_PRIORITY
 * 16. VIEW_TAGS
 * 17. VIEW_BASIC
 * 18. ERROR 
 * 19. DONE_BY_INDEX
 * 20. DONE_BY_NAME
 * 21. SEARCH
 * 22. UNDO 
 * 23. CHANGE_FILE_LOC
 * 24. SAVE
 * 25. CLEAR 
 * 
 * @author Xue Hui
 *
 */
public class ProcessedObject {
	/*
	 * index is only used if command type is DELETE_BY_INDEX or UPDATE_BY_INDEX
	 * viewType is only used if command type is VIEW. 
	 * possible values for viewType:
	 * 1. ALL
	 * 2. GENERAL
	 * 3. DEADLINES
	 * 4. EVENTS 
	 * 5. ARCHIVE 
	 * 6. HELP 
	 */
	private String command = null;
	private Task task = null; 
	private int index = -1; 
	private ArrayList<String> viewType = null; 
	private String errorType = null;
	private String searchPhrase = null; 
	private String newTaskName = null; 
	private int newPriority = -1; 
	private String newFileLoc = null; 
	private String category = null; 
	
	
	//CONSTRUCTORS ====================================================
	
	/**
	 * Empty Constructor for testing, shouldn't be used if possible 
	 */
	public ProcessedObject() {
		
	}
	
	/**
	 * Constructor for ERROR/UNDO/SEARCH/CHANGE_FILE_LOC/DELETE_BY_CATEGORY/
	 * SAVE/CLEAR
	 * @param command
	 */
	public ProcessedObject(String command) {
		this.command = command; 
	}
	
	/**
	 * Constructor for VIEW_BASIC, VIEW_TAGS 
	 * @param command
	 */
	public ProcessedObject(String command, ArrayList<String> viewType) {
		this.command = command; 
		this.viewType = viewType; 
	}
	
	/**
	 * Constructor for ADD_FLOATING, ADD_DEADLINE, ADD_EVENT, ADD_RECURRING,
	 * DELETE_BY_NAME, UPDATE_BY_NAME_CHANGE_NAME, UPDATE_BY_NAME_CHANGE_DATE,
	 * UPDATE_BY_NAME_CHANGE_BOTH
	 * @param command
	 * @param task
	 */
	public ProcessedObject(String command, Task task) {
		this.command = command;
		this.task = task; 
	}
	
	/**
	 * Constructor for DELETE_BY_INDEX, UPDATE_BY_INDEX_CHANGE_NAME, 
	 * UPDATE_BY_INDEX_CHANGE_DATE, UPDATE_BY_INDEX_CHANGE_BOTH
	 * @param command
	 * @param task
	 * @param index
	 */
	public ProcessedObject(String command, int index) {
		this.command = command;
		this.index = index; 
	}
	
	//=================================================================
	
	//Corresponding GET/SET methods ===================================
	
	/**
	 * @return command that the user has keyed in, or error
	 */
	public String getCommand() {
		return command;
	}
	
	/**
	 * Set the command that the user has keyed in. 
	 * @param command
	 */
	public void setCommand(String command) {
		this.command = command; 
	}
	
	/**
	 * @return Task object attached to this ProcessedObject, 
	 * if there is any
	 */
	public Task getTask() {
		return task;
	}
	
	/**
	 * Set the task object if required. 
	 * @param task
	 */
	public void setTask(Task task) {
		this.task = task; 
	}
	
	/**
	 * @return index of the task to update or delete
	 */
	public int getIndex() {
		return index; 
	}
	
	/**
	 * set the index of the task to update or delete
	 * @param index
	 */
	public void setIndex(int index) {
		this.index = index; 
	}
	
	/**
	 * @return view type of a view command
	 */
	public ArrayList<String> getViewType() {
		return viewType; 
	}
	
	/**
	 * Set view type of a view command
	 * @param viewType
	 */
	public void setViewType(ArrayList<String> viewType) {
		this.viewType = viewType; 
	}
	
	/**
	 * set the details of an ERROR command
	 * @param errorType
	 */
	public void setErrorType(String errorType) {
		this.errorType = errorType;
	}
	
	/**
	 * @return get details of an ERROR command
	 */
	public String getErrorType() {
		return errorType; 
	}
	
	/**
	 * Set search phrase, if the command is SEARCH
	 * @param searchPhrase
	 */
	public void setSearchPhrase(String searchPhrase) {
		this.searchPhrase = searchPhrase; 
	}
	
	/**
	 * @return search phrase, if the command is SEARCH
	 */
	public String getSearchPhrase() {
		return searchPhrase; 
	}
	
	/**
	 * Set new task name of a task,
	 * used with a "SET" command
	 * @param taskName
	 */
	public void setNewTaskName(String taskName) {
		newTaskName = taskName; 
	}
	
	/**
	 * @return new task name of a task; used with "SET" command
	 */
	public String getNewTaskName() {
		return newTaskName; 
	}
	
	/**
	 * @return directory of new file location to be used
	 */
	public String getNewFileLoc() {
		return newFileLoc; 
	}
	
	/**
	 * Set new directory of new file location to be used 
	 * @param newFileLoc
	 */
	public void setNewFileLoc(String newFileLoc) {
		this.newFileLoc = newFileLoc; 
	}
	
	/**
	 * Set category of tasks to delete
	 * @param category
	 */
	public void setCategory(String category) {
		this.category = category;
	}
	
	/**
	 * @return category of tasks to delete 
	 */
	public String getCategory() {
		return category; 
	}
	
	/**
	 * @return new priority of the task (for set) 
	 */
	public int getNewPriority() {
		return newPriority; 
	}
	
	/**
	 * @param newPriority set new priority of the task (for set) 
	 */
	public void setNewPriority(int newPriority) {
		this.newPriority = newPriority; 
	}
	
	@Override 
	/**
	 * For debugging
	 */
	public String toString() {
		String stringRep = ""; 
		
		stringRep += "Command: " + command + "\n";
		
		if (task != null) {
			stringRep += task.toString(); 
		}
		
		if (index != -1) {
			stringRep += "at index: " + String.valueOf(index) + "\n"; 
		}
		
		if (viewType != null) {
			stringRep += "view type: "; 
			for(int i = 0; i < viewType.size(); i++) {
				stringRep += viewType.get(i) + ", "; 
			}
			stringRep += "\n"; 
		}
		
		if (errorType != null) {
			stringRep += "error type: " + errorType + "\n"; 
		}
		
		if (searchPhrase != null) {
			stringRep += "search phrase: " + searchPhrase + "\n"; 
		} 
		
		if (newTaskName != null) {
			stringRep += "new TaskName: " + newTaskName + "\n"; 		
		}
		
		if (category != null) {
			stringRep += "category: " + category + "\n";
		}
		
		if (newPriority != -1) {
			stringRep += "newPriority: " + newPriority + "\n"; 
		}
		
		if (newFileLoc != null) {
			stringRep += "newLocation: " + newFileLoc + "\n"; 
		}
		
		return stringRep; 
	}
}
```
###### src\messenger\TagCategory.java
``` java
 * This Tag Category encapsulates the tag name and the
 * number of times this tag occurs in the user's tasks. 
 * @author Xue Hui
 *
 */
public class TagCategory implements Comparable<TagCategory> {
	private String tagName = null;
	private int numTags = 0;
	
	public TagCategory(String tagName) {
		this.tagName = tagName; 
		numTags += 1; 
	}
	
	public TagCategory(TagCategory other) {
		tagName = other.tagName;
		numTags = other.numTags;
	}
	
	/**
	 * @return Tag name of the TagCategory
	 */
	public String getTagName() {
		return tagName;
	}
	
	/**
	 * Set the tag name of the tag category
	 * @param tagName
	 */
	public void setTagName(String tagName) {
		this.tagName = tagName;
	}
	
	/**
	 * Get the number of tasks with this tag 
	 * @return
	 */
	public int getNumTags() {
		return numTags;
	}
	
	/**
	 * Set the number of tasks with this tag 
	 * @param numTags
	 */
	public void setNumTags(int numTags) {
		this.numTags = numTags;
	}
	
	/**
	 * Increase the count of numTags by 1
	 * ie. there's a new task with that tag
	 */
	public void increaseCount() {
		numTags += 1; 
	}
	
	/**
	 * Decrease the count of numTags by 1
	 * ie. a task with this tag has been deleted.
	 */
	public void decreaseCount() {
		if (numTags > 0) {
			numTags -= 1; 
		}
	}
	
	/**
	 * @return true if numTag count is 0. 
	 */
	public boolean isEmpty() {
		if (numTags == 0) {
			return true;
		}
		return false; 
	}
	
```
###### src\messenger\TagCategory.java
``` java
	public int compareTo(TagCategory tag) {
		String otherTagName = tag.getTagName(); 
        if (this.tagName.compareTo(otherTagName) == 0) {
        	return 0; 
        } else if (this.tagName.compareTo(otherTagName) > 0) {
        	return 1;
        } 
		return -1;
	}
}
```
###### src\messenger\Task.java
``` java
 * Task object holds all the details of the task 
 * 
 * taskType can have the following values:
 * 1. FLOATING
 * 2. EVENT (has a start and end time)
 * 3. DEADLINE 
 * 
 * 
 * date arrays have the following format:
 * dates*[0]: recurring interval (if recurring event/deadline) 
 * dates*[1]: start Time (events)
 * dates*[2]: end Time (events) 
 * dates*[3]: deadline 
 * idea for recurring : store the diff in time to the next recurrence in seconds
 * RECURRING WILL NOT BE IMPLEMENTED FOR NOW 
 * 
 * PRIORITY FOR THE TASK:
 * HIGH: 3
 * MEDIUM: 2
 * LOW: 1
 * Default: LOW (1) 
 * 
 * @author Xue Hui 
 *
 */

public class Task implements Comparable<Task> {
	public static final int NONE = -1; 
	public static final String EMPTY = ""; 
	
	private String taskName = null;
	private ArrayList<String> taskTags = null;
	private String taskType = null; 
	private long[] datesEpoch = {NONE,NONE,NONE,NONE}; 
	private String[] datesHuman = {EMPTY,EMPTY,EMPTY,EMPTY};
	private int priority = 1; //default. to add this to toString for debugging
	boolean pinTask = false; //default: not pinned, to decide whether or not to add this
	
	private TimeConverter timeConverter = new TimeConverter(); 
	
	//CONSTRUCTORS ==============================================
	public Task() {
		
	}
	
	public Task(String taskName) {
		this.taskName = taskName;
	}
	
	public Task(String taskName, ArrayList<String> taskTags) {
		this.taskName = taskName;
		this.taskTags = taskTags;
	}
	
	public Task(Task other) {
		if (other.taskName != null) {
			taskName = other.taskName;
		}
		
		if (other.taskTags != null) {
			taskTags = new ArrayList<String>(other.taskTags);
		}
		
		priority = other.priority;
		
		if (other.taskType != null) {
			taskType = other.taskType;
			
			switch(taskType) {
				case "FLOATING":
					//nothing else to add. 
					break;
				case "DEADLINE":
					setDeadline(other.getDeadlineEpoch());
					break;
				case "EVENT":
					setStartDate(other.getStartDateEpoch());
					setEndDate(other.getEndDateEpoch());
					break; 
			}
		}	
	}	
	
	//BASIC GET/SET METHODS =====================================
	
	/**
	 * @return Task Name
	 */
	public String getTaskName() {
		return taskName;
	}
	
	/**
	 * Set the Task Name of the task
	 * @param taskName
	 */
	public void setTaskName(String taskName) {
		this.taskName = taskName; 
	}
	
	/**
	 * @return all tags that the task contains as an ArrayList
	 */
	public ArrayList<String> getTaskTags() {
		return taskTags; 
	}
	
	/**
	 * Set an ArrayList of task tags to a task 
	 * @param taskTags
	 */
	public void setTaskTags(ArrayList<String> taskTags) {
		this.taskTags = taskTags; 
	}
	
	/**
	 * @return type of the task (event, floating, deadline)
	 */
	public String getTaskType() {
		return taskType; 
	}
	
	/**
	 * Set the task type (event, floating, deadline) 
	 * @param taskType
	 */
	public void setTaskType(String taskType) {
		this.taskType = taskType; 
	}
	
	/**
	 * @return Start Date of an event, without 23:59
	 */
	public String getStartDate() {
		String date = datesHuman[1]; 
		
		if (date.contains(DAY_END_SHORT)) {
			date = date.replaceFirst(DAY_END_SHORT, ""); 
		}
		return date.trim(); 
	}
	
	/**
	 * @return startDate of an event without stripping off 23:59
	 */
	public String getStartDateFull() {
		return datesHuman[1]; 
	}
	
	/**
	 * @return startDate of an event in epoch
	 */
	public long getStartDateEpoch() {
		return datesEpoch[1]; 
	}
	
	/**
	 * @return end date of an event in human time, without 23:59
	 */
	public String getEndDate() {
		String date = datesHuman[2]; 
		
		if (date.contains(DAY_END_SHORT)) {
			date = date.replaceFirst(DAY_END_SHORT, ""); 
		}
		return date.trim(); 
	}
	
	/**
	 * @return end date of an event in human time,
	 * without stripping off 23:59 
	 */
	public String getEndDateFull() {
		return datesHuman[2]; 
	}
	
	/**
	 * @return end date of an event in epoch time
	 */
	public long getEndDateEpoch() {
		return datesEpoch[2]; 
	}
	
	/**
	 * @return human deadline without 23:59 
	 */
	public String getDeadline() {
		String date = datesHuman[3]; 
		
		if (date.contains(DAY_END_SHORT)) {
			date = date.replaceFirst(DAY_END_SHORT, ""); 
		}
		return date.trim(); 
	}
	
	/**
	 * @return human deadline with 23:59
	 */
	public String getDeadlineFull() {
		return datesHuman[3]; 
	}
	
	/**
	 * @return deadline in epoch time 
	 */
	public long getDeadlineEpoch() {
		return datesEpoch[3]; 
	}
	
	/**
	 * Given the startDate in the format dd MMM yyyy HH:mm:ss, 
	 * auto-key in the epoch time as well. 
	 * @param startDate
	 */
	public void setStartDate(String startDate) {
		datesHuman[1] = startDate; 
		try {
			datesEpoch[1] = timeConverter.toEpochTime(startDate);
		} catch (ParseException error) {
			//do nothing
		}
	}
	
	/**
	 * Given the startDate in Epoch, 
	 * auto-key in the human time as well. 
	 * @param startDate
	 */
	public void setStartDate(long startDate) {
		datesEpoch[1] = startDate; 
		datesHuman[1] = timeConverter.toHumanTime(startDate); 
	}
	
	/**
	 * Given the endDate in the format dd MMM yyyy HH:mm:ss, 
	 * auto-key in the epoch time as well. 
	 * @param endDate
	 */
	public void setEndDate(String endDate) {
		datesHuman[2] = endDate; 
		try {
			datesEpoch[2] = timeConverter.toEpochTime(endDate); 
		} catch (ParseException error) {
			
		}
	}
	
	/**
	 * Given the endDate in Epoch, 
	 * auto-key in the human time as well. 
	 * @param endDate
	 */
	public void setEndDate(long endDate) {
		datesEpoch[2] = endDate; 
		datesHuman[2] = timeConverter.toHumanTime(endDate); 		
	}
	
	/**
	 * Given the deadline in the format dd MMM yyyy HH:mm:ss, 
	 * auto-key in the epoch time as well. 
	 * @param deadline
	 */
	public void setDeadline(String deadline) {
		datesHuman[3] = deadline; 
		try {
			datesEpoch[3] = timeConverter.toEpochTime(deadline); 
		} catch (ParseException error) {
			
		}
	}
	
	/**
	 * Given the deadline in Epoch,
	 * auto-key in the human time as well. 
	 * @param deadline
	 */
	public void setDeadline(long deadline) {
		datesEpoch[3] = deadline; 
		datesHuman[3] = timeConverter.toHumanTime(deadline); 	
		
	}
	
	/**
	 * @return priority of the task. where 1 is the lowest priority and
	 * 3 is the highest priority
	 */
	public int getPriority() {
		return priority;
	}
	
	/**
	 * Set the priority of the task, where 1 is the lowest priority and
	 * 3 is the highest priority 
	 * @param priority
	 */
	public void setPriority(int priority) {
		this.priority = priority; 
	}
	
	//NON-BASIC METHODS ==========================================
	
	/**
	 * @return Start and End time of an event in human readable
	 * form, without 23:59 
	 */
	public String[] getEventTime() {
		String[] eventTime = {getStartDate(),getEndDate()};
		return eventTime; 
	}
	
	/**
	 * @return Start and End time of an event in human readable
	 * form, with 23:59 
	 */
	public String[] getEventTimeFull() {
		String[] eventTime = {getStartDateFull(),getEndDateFull()};
		return eventTime; 
	}
	
	/**
	 * @return Start and End time of an event in epoch form 
	 */
	public long[] getEventTimeEpoch() {
		long[] eventTime = {datesEpoch[1],datesEpoch[2]}; 
		return eventTime; 
	}
	
	/**
	 * Add a new tag to your task 
	 * @param tag
	 */
	public void addTaskTag(String tag) {
		if (taskTags != null) {
			taskTags.add(tag); 
		} else {
			taskTags = new ArrayList<String>();
			taskTags.add(tag); 
		}
	}
	
	/**
	 * Remove a tag from your task 
	 * @param tag
	 */
	public void removeTaskTag(String tag) {
		for(int i = 0; i < taskTags.size(); i++) {
			String temp = taskTags.get(i); 
			if(tag.compareTo(temp) == 0) {
				taskTags.remove(i); 
				break; 
			}
		}
		//if empty, remove the arraylist 
		if (taskTags.isEmpty()) {
			taskTags = null; 
		}
	}
	
	@Override
	/**
	 * Tasks are comparable by their start time. 
	 * Used for sorting in ArrayList<Task>
	 * So that one can easily just call Collections.sort(taskList) 
	 */
	public int compareTo(Task anotherTask) {
		long startTime = -1; 
		long endTime = -1; 
		if (this.taskType.compareTo("EVENT") == 0) {
			startTime = getStartDateEpoch(); 
			endTime = getEndDateEpoch(); 
		} else if (this.taskType.compareTo("DEADLINE") == 0) { 
			startTime = getDeadlineEpoch(); 
		}
		
		String otherTaskType = anotherTask.getTaskType(); 
		String otherTaskName = anotherTask.getTaskName(); 
		int otherTaskPriority = anotherTask.getPriority(); 
		long otherStartTime = -1; 
		long otherEndTime = -1; 
		if (anotherTask.getTaskType().compareTo("EVENT") == 0) {
			otherStartTime = anotherTask.getStartDateEpoch(); 
			otherEndTime = anotherTask.getEndDateEpoch(); 
		} else if (anotherTask.getTaskType().compareTo("DEADLINE") == 0) { 
			otherStartTime = anotherTask.getDeadlineEpoch(); 
		}
		
		//1. Sort by Priority
		//2. Sort by type (Event and Deadline first, floating behind)
		//3. Sort by task name (alphabetical order) 
		
		if (this.priority > otherTaskPriority) {
			return 1; 
		} else if (this.priority == otherTaskPriority) {
			return compareByTaskType(startTime, endTime, otherTaskType, 
					otherTaskName, otherStartTime, otherEndTime);
		} else {
			return -1; //this.priority < otherTaskPriority 
		}
	}
	
	/**
	 * Compare the priority of the tasks based on whether it is floating, deadline or event
	 * @param startTime
	 * @param otherTaskType
	 * @param otherTaskName
	 * @param otherStartTime
	 * @return 1 if this task is "greater" than the other Task, 0 if they are the same,
	 * and -1 if this task is "lesser" then the other Task 
	 */
	private int compareByTaskType(long startTime, long endTime,
			String otherTaskType, String otherTaskName, long otherStartTime, long otherEndTime) {
		//FLOATING HAS THE LOWEST PRIORITY : compare by name 
		if (this.taskType.equals("FLOATING") && otherTaskType.equals("FLOATING")) {
			return compareTaskNames(otherTaskName);
		} else if (this.taskType.equals("FLOATING") && otherTaskType.equals("EVENT")) {
			return -1; 
		} else if (this.taskType.equals("FLOATING") && otherTaskType.equals("DEADLINE")) {
			return -1; 
		} else if (this.taskType.equals("EVENT") && otherTaskType.equals("FLOATING")) { 
			return 1; 
		} else if (this.taskType.equals("EVENT") && otherTaskType.equals("DEADLINE")) {
			return compareNonFloating(startTime, endTime, otherTaskName, otherTaskType,
					otherStartTime, otherEndTime);
		} else if (this.taskType.equals("EVENT") && otherTaskType.equals("EVENT")) {
			return compareNonFloating(startTime, endTime, otherTaskName, otherTaskType,
					otherStartTime, otherEndTime);
		} else if (this.taskType.equals("DEADLINE") && otherTaskType.equals("FLOATING")) { 
			return 1; 
		} else if (this.taskType.equals("DEADLINE") && otherTaskType.equals("EVENT")) {
			return compareNonFloating(startTime, endTime, otherTaskName, otherTaskType,
					otherStartTime, otherEndTime);
		} else if (this.taskType.equals("DEADLINE") && otherTaskType.equals("DEADLINE")) {
			return compareNonFloating(startTime, endTime, otherTaskName, otherTaskType,
					otherStartTime, otherEndTime);
		} 
		return 0; //shouldn't get here. 
	}

	/**
	 * Compare Events and Deadline:
	 * 1) Based on Time
	 * 2) Based on name, if time is the same 
	 * @param startTime
	 * @param endTime
	 * @param otherTaskName
	 * @param otherTaskType
	 * @param otherStartTime
	 * @param otherEndTime 
	 * @return 0 if equal, 1 if this task is greater, -1 if this task is lesser
	 */
	private int compareNonFloating(long startTime, long endTime, String otherTaskName, String otherTaskType,
			long otherStartTime, long otherEndTime) {
		
		if (this.taskType.equals("EVENT") && otherTaskType.equals("DEADLINE")) {
			return compareEventDeadline(startTime, endTime, otherTaskName, otherStartTime); 
		} else if (this.taskType.equals("EVENT") && otherTaskType.equals("EVENT")) {
			return compareTwoEvents(startTime, endTime, otherTaskName, otherStartTime, otherEndTime);
		} else if (this.taskType.equals("DEADLINE") && otherTaskType.equals("EVENT")) {
			return compareDeadlineEvent(startTime, otherTaskName, otherStartTime, otherEndTime); 
		} else { //this.taskType == Deadline && other.taskType == deadline 
			return compareTwoDeadlines(startTime, otherTaskName, otherStartTime);
		}
	}
	
	/**
	 * This Task is a Deadline, and the other task is an Event.
	 * Do a comparison based on start and end times. 
	 * @param deadlineTime
	 * @param otherTaskName
	 * @param eventStartTime
	 * @param eventEndTime
	 * @return 0 if equal, 1 if this task is greater, -1 if this task is lesser
	 */
	private int compareDeadlineEvent(long deadlineTime, String otherTaskName, long eventStartTime, long eventEndTime) {
		if (deadlineTime < eventEndTime) {
			return 1; //deadline ends earlier, so it gets a higher priority
		} else if (deadlineTime == eventEndTime) {
			if (deadlineTime < eventStartTime) {
				return 1; //deadline ends before (other) eventStartTime, so deadline gets higher priority
			} else if (eventStartTime == deadlineTime) {
				return compareTaskNames(otherTaskName); 
			} else {
				return -1; 
			}
		} else {
			return -1; 
		}
	}
	
	/**
	 * This Task is an Event, and the other task is a deadline.
	 * Do a comparison based on start and end times. 
	 * @param eventStartTime
	 * @param eventEndTime
	 * @param otherTaskName
	 * @param deadlineTime
	 * @return 0 if equal, 1 if this task is greater, -1 if this task is lesser
	 */
	private int compareEventDeadline(long eventStartTime, long eventEndTime, String otherTaskName, long deadlineTime) {
		if (eventEndTime > deadlineTime) {
			return -1; //deadline ends earlier, so it gets a higher priority
		} else if (eventEndTime == deadlineTime) {
			if (eventStartTime > deadlineTime) {
				return -1; //event starts after deadline, so deadline gets higher priority
			} else if (eventStartTime == deadlineTime) {
				return compareTaskNames(otherTaskName); 
			} else {
				return 1; 
			}
		} else {
			return 1; 
		}
	}
	
	/**
	 * Compare the time priority for 2 events. If they start at the same time,
	 * the event which ends earlier gets higher priority. 
	 * @param startTime
	 * @param endTime
	 * @param otherTaskName
	 * @param otherStartTime
	 * @param otherEndTime
	 * @return 0 if equal, 1 if this task is greater, -1 if this task is lesser
	 */
	private int compareTwoEvents(long startTime, long endTime, String otherTaskName, 
			long otherStartTime, long otherEndTime) {
		if (startTime > otherStartTime) {
			return -1; //this task starts later, so it gets less priority
		} else if (startTime == otherStartTime) {
			if (endTime < otherEndTime) {
				return 1; //this task ends earlier, so it gets more priority 
			} else if (endTime == otherEndTime) {
				return compareTaskNames(otherTaskName);
			} else {
				return -1; 
			}
		} else {
			return 1; 
		}
	}

	/**
	 * Compare two start times for 2 deadline tasks 
	 * @param startTime
	 * @param otherTaskName
	 * @param otherStartTime
	 * @return 0 if equal, 1 if this task is greater, -1 if this task is lesser
	 */
	private int compareTwoDeadlines(long endTime, String otherTaskName, long otherEndTime) {
		if (endTime > otherEndTime) {
			return -1; //this task ends later, so it gets less priority 
		} else if (endTime == otherEndTime) {
			return compareTaskNames(otherTaskName);
		} else {
			return 1; 
		}
	}
	
	/**
	 * Compare events, floating or deadlines based on their task names
	 * ie. arrange in alphabetical order 
	 * @param otherTaskName
	 * @return 0 if equal, 1 if this task is greater, -1 if this task is lesser
	 */
	private int compareTaskNames(String otherTaskName) {
		//compare by name 
		if (this.taskName.compareToIgnoreCase(otherTaskName) == 0) {
			return 0; 
		} else if (this.taskName.compareToIgnoreCase(otherTaskName) > 0) {
			//this task name is greater than the other task name and should be ordered in front,
			//so that sortReverse() will return it in alphabetical order. 
			//eg. this is Zephyr, that is Wine, then that should come before this. 
			return -1; 
		} else {
			return 1; //less impt than the other task name
		}
		//return taskName.compareTo(otherTaskName);
	}
	
```
###### src\messenger\Task.java
``` java
	 * For debugging 
	 */
	public String toString() {
		String stringRep = ""; 
		
		if (taskName != null) {
			stringRep += taskName;
			stringRep += ", ";
		}
		
		if (taskType != null) {
			stringRep += taskType; 
			stringRep += ", ";
		
			switch(taskType) {
				case "EVENT":
					String[] eventTime = getEventTime(); 
					stringRep += "from " + eventTime[0];
					stringRep += " to " + eventTime[1]; 
					break;
				case "DEADLINE":
					stringRep += "due on " + getDeadline(); 
					break; 
				default:
					break;
			}
		}
		stringRep += "\n";
		
		if (taskTags != null) { 
			stringRep += "tags: ";
			for(int i = 0; i < taskTags.size(); i++) {
				stringRep += taskTags.get(i) + ", "; 
			}
			stringRep += "\n";
		}
		
		if (priority > 1) {
			stringRep += "priority: " + priority + "\n";
		}
		
		return stringRep; 
	}
	
```
###### src\parser\AutoComplete.java
``` java
 * This class processes what words should be shown in the dropdown
 * menu if the user types into the CLI - it allows the user to auto-complete
 * his commands. 
 * @author Xue Hui
 *
 */
public class AutoComplete {
	private DateTimePatternMatcher pm = new DateTimePatternMatcher(); 
	private TimeConverter tc = new TimeConverter(); 
	
	private HashMap<String,String> commandList = new HashMap<String,String>();
	private ArrayList<String> specialDays = new ArrayList<String>(); 
	private ArrayList<String> specialDaysThis = new ArrayList<String>();
	private ArrayList<String> specialDaysNext = new ArrayList<String>(); 
	private ArrayList<String> commands = new ArrayList<String>();
	private ArrayList<String> viewList = new ArrayList<String>();
	private ArrayList<String> months = new ArrayList<String>(); 
	private HashMap<String, String> monthsMap = new HashMap<String,String>(); 
	private HashMap<String, String> daysOfWeek = new HashMap<String,String>(); 
	private HashMap<String, String> allDaysOfWeek = new HashMap<String, String>(); 
	
	/**
	 * CONSTRUCTOR 
	 */
	public AutoComplete() {
		
		processCommands();
		processViewList();
		processSpecialDays();
		processMonths(); 
		processDaysOfWeek();
		processAllDaysOfWeek();
		
	}

	/**
	 * Process command database
	 */
	private void processCommands() {
		commands.add("add");
		commands.add("view");
		commands.add("del");
		commands.add("setdir");
		commands.add("set");
		commands.add("search");
		commands.add("done");
		commands.add("undo");
		commands.add("save");
		commands.add("clear");
		
		commandList.put("add","add");
		commandList.put("view","view");
		commandList.put("del", "del");
		commandList.put("set","set");
		commandList.put("search","search");
		commandList.put("done","done");
		commandList.put("undo","undo");
		commandList.put("setdir","setdir");
		commandList.put("save","save");
		commandList.put("clear","clear");
	}

	/**
	 * Process ViewList Database 
	 */
	private void processViewList() {
		viewList.add("all");
		viewList.add("today");
		viewList.add("tomorrow");
		viewList.add("general");
		viewList.add("deadlines");
		viewList.add("events");
		viewList.add("archive");
		viewList.add("help");
		viewList.add("high");
		viewList.add("medium");
		viewList.add("low");
	}

	/**
	 * Process Special days database 
	 */
	private void processSpecialDays() {
		specialDays.add("sun");
		specialDays.add("mon");
		specialDays.add("tue");
		specialDays.add("wed");
		specialDays.add("thu");
		specialDays.add("fri");
		specialDays.add("sat");
		
		specialDaysThis.add("this sun");
		specialDaysThis.add("this mon");
		specialDaysThis.add("this tue");
		specialDaysThis.add("this wed");
		specialDaysThis.add("this thu");
		specialDaysThis.add("this fri");
		specialDaysThis.add("this sat");
		
		specialDaysNext.add("next sun");
		specialDaysNext.add("next mon");
		specialDaysNext.add("next tue");
		specialDaysNext.add("next wed");
		specialDaysNext.add("next thu");
		specialDaysNext.add("next fri");
		specialDaysNext.add("next sat");
	}

	/**
	 * Process months database
	 */
	private void processMonths() {
		months.add("jan");
		months.add("feb");
		months.add("mar");
		months.add("apr");
		months.add("may");
		months.add("jun");
		months.add("jul");
		months.add("aug");
		months.add("sep");
		months.add("oct");
		months.add("nov");
		months.add("dec");
		
		monthsMap.put("jan", "jan"); 
		monthsMap.put("feb", "feb"); 
		monthsMap.put("mar", "mar"); 
		monthsMap.put("apr", "apr"); 
		monthsMap.put("may", "may"); 
		monthsMap.put("jun", "jun"); 
		monthsMap.put("jul", "jul"); 
		monthsMap.put("aug", "aug"); 
		monthsMap.put("sep", "sep"); 
		monthsMap.put("oct", "oct"); 
		monthsMap.put("nov", "nov"); 
		monthsMap.put("dec", "dec");
	}

	/**
	 * Process dayOfWeek database
	 */
	private void processDaysOfWeek() {
		daysOfWeek.put("mon", "mon");
		daysOfWeek.put("tue", "tue");
		daysOfWeek.put("wed", "wed");
		daysOfWeek.put("thu", "thu");
		daysOfWeek.put("fri", "fri");
		daysOfWeek.put("sat", "sat");
		daysOfWeek.put("sun", "sun");
		
		daysOfWeek.put("monday", "monday");
		daysOfWeek.put("tuesday", "tuesday");
		daysOfWeek.put("wednesday", "wednesday");
		daysOfWeek.put("thursday", "thursday");
		daysOfWeek.put("friday", "friday");
		daysOfWeek.put("saturday", "saturday");
		daysOfWeek.put("sunday", "sunday");
	}

	/**
	 * Process alldaysofweek database
	 */
	private void processAllDaysOfWeek() {
		allDaysOfWeek.put("mon", "mon");
		allDaysOfWeek.put("tue", "tue");
		allDaysOfWeek.put("wed", "wed");
		allDaysOfWeek.put("thu", "thu");
		allDaysOfWeek.put("fri", "fri");
		allDaysOfWeek.put("sat", "sat");
		allDaysOfWeek.put("sun", "sun");
		
		allDaysOfWeek.put("monday", "monday");
		allDaysOfWeek.put("tuesday", "tuesday");
		allDaysOfWeek.put("wednesday", "wednesday");
		allDaysOfWeek.put("thursday", "thursday");
		allDaysOfWeek.put("friday", "friday");
		allDaysOfWeek.put("saturday", "saturday");
		allDaysOfWeek.put("sunday", "sunday");
		
		allDaysOfWeek.put("this mon", "mon");
		allDaysOfWeek.put("this tue", "tue");
		allDaysOfWeek.put("this wed", "wed");
		allDaysOfWeek.put("this thu", "thu");
		allDaysOfWeek.put("this fri", "fri");
		allDaysOfWeek.put("this sat", "sat");
		allDaysOfWeek.put("this sun", "sun");
		
		allDaysOfWeek.put("this monday", "monday");
		allDaysOfWeek.put("this tuesday", "tuesday");
		allDaysOfWeek.put("this wednesday", "wednesday");
		allDaysOfWeek.put("this thursday", "thursday");
		allDaysOfWeek.put("this friday", "friday");
		allDaysOfWeek.put("this saturday", "saturday");
		allDaysOfWeek.put("this sunday", "sunday");
		
		allDaysOfWeek.put("next mon", "mon");
		allDaysOfWeek.put("next tue", "tue");
		allDaysOfWeek.put("next wed", "wed");
		allDaysOfWeek.put("next thu", "thu");
		allDaysOfWeek.put("next fri", "fri");
		allDaysOfWeek.put("next sat", "sat");
		allDaysOfWeek.put("next sun", "sun");
		
		allDaysOfWeek.put("next monday", "monday");
		allDaysOfWeek.put("next tuesday", "tuesday");
		allDaysOfWeek.put("next wednesday", "wednesday");
		allDaysOfWeek.put("nextthursday", "thursday");
		allDaysOfWeek.put("next friday", "friday");
		allDaysOfWeek.put("next saturday", "saturday");
		allDaysOfWeek.put("next sunday", "sunday");
	}
	
	/**
	 * For Logic: Get a list of suggestions for the user to input 
	 * (in case he forgets any command or misspelt them, etc... ) 
	 * @param rawPhrase
	 * @param tagDB
	 * @return ProcessedAC
	 */
	public ProcessedAC getSuggestions(String rawPhrase, ArrayList<TagCategory> tagDB) {
		ProcessedAC suggestions = null;
		String phrase = rawPhrase.toLowerCase().trim();
		String[] split = phrase.split(" ");
		
		if (split.length == 1) {
			//likely only command 
			suggestions = completeCommand(phrase); 
			return suggestions; 
		}
		
		//look for the correct word to auto-suggest and return 
		switch (split[0].trim()) {
			case "view": 
				suggestions = completeView(phrase, tagDB); 
				break;
			
			case "add": 
				suggestions = completeAdd(phrase, tagDB);
				break;
				
			case "set":
				suggestions = completeEdit(phrase);
				break;		
			
			case "del":
			case "search":
			case "done":
			case "undo":
			case "setdir":
			case "save":
			case "clear": 
				suggestions = new ProcessedAC(ParserConstants.FINISHED_COMMAND);
				break; 
				
			default:
				suggestions = new ProcessedAC(ParserConstants.NO_SUCH_COMMAND);
				break; 
		}		
		
		return suggestions; 
	}
	
	/**
	 * Given a partial input of the command, return a list of commands 
	 * that contain that input as a sub-string. 
	 * @param phrase
	 * @return If no such command exists, return null
	 */
	private ProcessedAC completeCommand(String phrase) {
		phrase = phrase.toLowerCase().trim(); 
		
		//if the command is completed, don't need to process
		if (commandList.containsKey(phrase)) {
			return new ProcessedAC(ParserConstants.FINISHED_COMMAND);
		}
		
		ArrayList<String> availCommands = new ArrayList<String>();
		
		//find list normally  
		for(int i = 0; i < commands.size(); i++) {
			if (commands.get(i).indexOf(phrase) == 0) {
				availCommands.add(commands.get(i)); 
			}
		}
		
		if (!availCommands.isEmpty()) {
			return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availCommands);
		} else {
			//try to check if command is misspelt
			availCommands = correctCommandError(phrase); 
			if (availCommands != null && !availCommands.isEmpty()) {
				return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availCommands); 
			}
		}
		//no such command containing that sub-string
		return new ProcessedAC(ParserConstants.NO_SUCH_COMMAND); 
	}
	
	/**
	 * Given a partial input that contains "view xxxx xxx",
	 * return a list of available view types that the user can access in his 
	 * latest word 
	 * @param phrase
	 * @return If no such list of views is available, return null 
	 */
	private ProcessedAC completeView(String phrase, ArrayList<TagCategory> tagDB) {
		ArrayList<String> availViews = new ArrayList<String>();
		phrase = phrase.toLowerCase();
		phrase = phrase.replaceFirst("view", "").trim(); 
		String[] parts = phrase.split(" ");
		//only want to auto-complete the latest word
		String word = parts[parts.length-1].trim(); 
		
		//check if basic view exists 
		for(int i = 0; i < viewList.size(); i++) {
			if (viewList.get(i).indexOf(word) == 0) {
				availViews.add(viewList.get(i)); 
			}
		}
		
		//check if tag view exists 
		for(int i = 0; i < tagDB.size(); i++) {
			String tag = "#" + tagDB.get(i).getTagName(); 
			if (tag.contains(word)) {
				//if user types without #, 
				//then he should select the dropdown suggestion
				availViews.add(tag); 
			}
		}
		
		if (!availViews.isEmpty()) {
			return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availViews); 
		}
		return new ProcessedAC(ParserConstants.NO_SUCH_COMMAND); 
	}
	
	/**
	 * Help a user suggest dates/categories/priority if any 
	 * @param phrase
	 * @param utd 
	 * @return ProcessedAutoComplete Object 
	 */
	private ProcessedAC completeAdd(String phrase, ArrayList<TagCategory> tagDB) { 
		String keyWords = "(at|on|by|from)";
		
		ArrayList<String> availSuggestions = new ArrayList<String>(); 
		phrase = phrase.toLowerCase();
		phrase = phrase.replaceFirst("add", "").trim();
		String[] splitString = phrase.split(" ");
		String latestWord = splitString[splitString.length - 1]; 
		
		if (latestWord.contains("#")) {
			return addSuggestTags(tagDB, availSuggestions, latestWord); 
		} else if (latestWord.contains("!")) {
			//suggest priorities to the user 
			return suggestPriority(phrase, availSuggestions); 
		} else if (latestWord.matches(keyWords)) {
			//suggest some dates to the user, since keywords spotted 
			return addSuggestNonsenseDates(availSuggestions); 
		} else if (!hasKeywords(splitString)) {
			return new ProcessedAC(ParserConstants.FINISHED_COMMAND); 
		} else {
			availSuggestions = suggestDates(latestWord, phrase); 
			if (availSuggestions == null) {
				//might be task name, don't indicate error 
				return new ProcessedAC(ParserConstants.FINISHED_COMMAND); 
			}
		}
		
		if (!availSuggestions.isEmpty()) {
			return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availSuggestions); 
		}
		return new ProcessedAC(ParserConstants.NO_SUCH_COMMAND);
	}

	/**
	 * No date entered yet, but keywords detected, so suggest some nonsense
	 * dates to the user 
	 * @param availSuggestions
	 * @return ProcessedAC
	 */
	private ProcessedAC addSuggestNonsenseDates(ArrayList<String> availSuggestions) {
		availSuggestions.add("tmr");
		availSuggestions.add("8pm");
		availSuggestions.add("next mon");
		return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availSuggestions);
	}
	
	/**
	 * Adding and Editing: Suggest priorities to the user 
	 * @param phrase
	 * @param availSuggestions
	 * @return ProcessedAC
	 */
	private ProcessedAC suggestPriority(String phrase, ArrayList<String> availSuggestions) {
		if (phrase.contains("!!!!")) {
			//anything more than 3 !s is an error
			return new ProcessedAC(ParserConstants.NO_SUCH_COMMAND);
		} else if (phrase.contains("!!!")) {
			//no need to suggest anything else 
			return new ProcessedAC(ParserConstants.FINISHED_COMMAND);
		} else if (phrase.contains("!!")) {
			availSuggestions.add("!!");
			availSuggestions.add("!!!");
			return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availSuggestions);
		} else {
			//only 1 ! 
			availSuggestions.add("!"); 
			availSuggestions.add("!!");
			availSuggestions.add("!!!");
			return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availSuggestions);
		}
	}
	
	/**
	 * Adding: suggest tag categories to the user if the user already has 
	 * tags in his TagDatabase
	 * @param tagDB
	 * @param availSuggestions
	 * @param latestWord
	 * @return ProcessedAC  
	 */
	private ProcessedAC addSuggestTags(ArrayList<TagCategory> tagDB, ArrayList<String> availSuggestions,
			String latestWord) {
		latestWord = latestWord.replace("#", "").trim(); 
		//suggest categories to the user 
		//if empty tag, suggest anything
		if (latestWord.equals("")) {
			return addSuggestForEmptyTags(tagDB, availSuggestions);
		}
		//if typed halfway, can suggest tags that match 
		return addSuggestForTags(tagDB, availSuggestions, latestWord);
	}

	/**
	 * If the user has typed halfway, suggest tags that match,
	 * else return finished_command as it could be a new category 
	 * @param tagDB
	 * @param availSuggestions
	 * @param latestWord
	 * @return ProcessedAC
	 */
	private ProcessedAC addSuggestForTags(ArrayList<TagCategory> tagDB, ArrayList<String> availSuggestions,
			String latestWord) {
		for(int i = 0; i < tagDB.size(); i++) {
			String tag = tagDB.get(i).getTagName(); 
			if (tag.contains(latestWord)) {
				availSuggestions.add("#" + tag); 
			}
		}
		if (!availSuggestions.isEmpty()) {
			return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availSuggestions);
		}
		//if tag doesnt exist, maybe it's a new tag. don't highlight error
		return new ProcessedAC(ParserConstants.FINISHED_COMMAND);
	}
	
	/**
	 * Suggest tags for the user to key in if his tag is empty
	 * Return finished command if the tag database is empty 
	 * @param tagDB
	 * @param availSuggestions
	 * @return ProcessedAC
	 */
	private ProcessedAC addSuggestForEmptyTags(ArrayList<TagCategory> tagDB, ArrayList<String> availSuggestions) {
		//if tagDB is empty, nth to suggest 
		if (tagDB.size() == 0) {
			return new ProcessedAC(ParserConstants.FINISHED_COMMAND); 
		}
		//else suggest something 
		for(int i = 0; i < tagDB.size(); i++) {
			if (i < 3) {
				availSuggestions.add("#" + tagDB.get(i).getTagName());
			}
		}
		return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availSuggestions);
	}

	/**
	 * Checks if any word in an input contains keywords
	 * @param phraseSplit
	 * @return true if the keywords at/on/by/from exists anywhere
	 */
	private boolean hasKeywords(String[] phraseSplit) {
		String keyWords = "(at|on|by|from)";
		
		for (int i = 0; i < phraseSplit.length; i++) {
			String word = phraseSplit[i];
			if (word.matches(keyWords)) {
				return true; 
			}	
		}
		return false; 
	}
	
	/**
	 * Help user to fill in !!! (priority) or date 
	 * Will not suggest anything for task name or new task name 
	 * @param phrase
	 * @return ProcessedAutoComplete Object 
	 */
	private ProcessedAC completeEdit(String phrase) {
		ArrayList<String> availSuggestions = new ArrayList<String>(); 
		phrase = phrase.toLowerCase();
		phrase = phrase.replaceFirst("set", "").trim();
		
		if (phrase.contains("!")) {
			return suggestPriority(phrase, availSuggestions);
		} else if (phrase.contains("[")) {
			//suggest a date to the user 
			String dates; 
			String[] rawDates = phrase.split("\\[");
			if (rawDates.length > 1) {
				dates = rawDates[1].trim();
				dates = dates.replace("]", "");
			} else {
				//probably an empty [] from autocomplete
				availSuggestions.add("tomorrow"); 
				return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availSuggestions); 
			}
			String date;
			if (dates.split(",").length == 2) {
				//only auto complete the 2nd date 
				date = dates.split(",")[1].trim(); 
			} else {
				//only 1 date, try to auto complete that 
				date = dates; 
			}
			ArrayList<String> suggestedDates = suggestDates(date); 
			if (suggestedDates != null) {
				availSuggestions = suggestDates(date); 	
			} else {
				return new ProcessedAC(ParserConstants.FINISHED_COMMAND);
			}
		} else if (phrase.contains("\"")) {
			return new ProcessedAC(ParserConstants.FINISHED_COMMAND); 
		} else {
			//user has not typed any changes, so suggest format 
			return editSuggestFormat(availSuggestions); 
		}
		
		if (!availSuggestions.isEmpty()) {
			return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availSuggestions); 
		}
		return new ProcessedAC(ParserConstants.FINISHED_COMMAND);
	}
	
	/**
	 * Editing task: to formats input yet, so suggest a format to the user 
	 * @param availSuggestions
	 * @return ProcessedAC
	 */
	private ProcessedAC editSuggestFormat(ArrayList<String> availSuggestions) {
		availSuggestions.add("\"New Task Name\"");
		availSuggestions.add("[New Date]");
		availSuggestions.add("!!"); 
		return new ProcessedAC(ParserConstants.DISPLAY_COMMAND, availSuggestions);
	}
	
	/**
	 * FOR PARSING EDIT/SET 
	 * Suggest some dates and times that the user can type
	 * @param date
	 * @return a list of date/time that the user can type
	 */
	private ArrayList<String> suggestDates(String date) {
		ArrayList<String> availDates = new ArrayList<String>();
		
		availDates = checkIfSpecialDate(date, availDates);
		if (availDates == null) {
			return null; 
		}
		if (!availDates.isEmpty()) {
			return availDates; 
		}
		
		//eg. sun... mon... 
		for(int i = 0; i < specialDays.size(); i++) { 
			if (specialDays.get(i).indexOf(date) == 0) {
				availDates.add(specialDays.get(i));
			}
		}
		
		//check for possible time formats, and suggest times
		if (pm.hasTimeAC(date.trim())) {
			suggestPossibleTime(date, availDates);
		} else if (pm.hasCorrectTimeFormat(date.trim())) {
			//don't suggest any time, if there's no other date format,
			//then suggest "tomorrow"
			suggestPossibleDates(date, availDates);
		} else {
			//suggest a time? 
			//availDates.add("9pm");
		}
		
		//check if month 
		checkIfContainsMonth(date, availDates);
		
		//check for normal date
		checkIfContainsNormalDate(date, availDates);		
		
		if (!availDates.isEmpty()) {
			return availDates; 
		}
		return null; 
	}

	/**
	 * Suggest Possible dates if a date format is detected
	 * @param date
	 * @param availDates
	 */
	private void suggestPossibleDates(String date, ArrayList<String> availDates) {
		String[] temp = date.split(" ");
		String date2 = ""; 
		for (int i = 1; i < temp.length; i++) {
			date2 += temp[i]; 
		}
		if (!pm.hasFullDateAC(date2)) {
			availDates.add("tomorrow"); 
		} else if (pm.hasDateAC(date2)) {
			ArrayList<String> dateRaw = tc.get3MonthsFromNow(); 
			for(int i = 0; i < dateRaw.size(); i++) {
				availDates.add(date2.trim()+ " " + dateRaw.get(i)); //dd mmm
			}
		} else {
			checkIfContainsMonth(date2, availDates);
		}
	}
	
	/**
	 * Suggest possible times if a time format is detected
	 * @param date
	 * @param availDates
	 */
	private void suggestPossibleTime(String date, ArrayList<String> availDates) {
		String date2 = date.replace("h", "");
		date2 = date2.replace("a", "");
		date2 = date2.replace("p", "");
		try {
			int num = Integer.parseInt(date2.trim()); 
			if (num <= 12) {
				availDates.add(date2.trim()+"am");
				availDates.add(date2.trim()+"pm"); 
			}
			if (date2.trim().length() == 4 && num <= 2400 
					&& num != 2016 && num != 2017) { 
				availDates.add(date2.trim()+"h"); 
			}
		} catch (Exception e) {
			//do nth 
		}
	}
	
	/**
	 * Checks if the input contains what looks like a special date
	 * @param date
	 * @param availDates
	 * @return list of avail special dates to autocomplete 
	 */
	private ArrayList<String> checkIfSpecialDate(String date, ArrayList<String> availDates) {
		if (allDaysOfWeek.containsKey(date.trim())) {
			return null; 
		}
		
		if ("this".indexOf(date) == 0) { //eg. this ... 
			availDates = specialDaysThis; 
			return availDates; 
		} else if ("next".indexOf(date) == 0) { //eg. next ...
			availDates = specialDaysNext; 
			return availDates; 
		}
		return availDates;
	}

	/**
	 * Checks if the input possibly contains some normal date,
	 * and attempts to autocomplete it 
	 * @param date
	 * @param availDates
	 */
	private void checkIfContainsNormalDate(String date, ArrayList<String> availDates) {
		if (pm.hasDateAC(date.trim())) {
			ArrayList<String> dateRaw = tc.get3MonthsFromNow(); 
			for(int i = 0; i < dateRaw.size(); i++) {
				availDates.add(date.trim()+ " " + dateRaw.get(i)); //dd mmm
			}
		}
	}
	
	/**
	 * If the date input looks like it contains a month, try to autocomplete the 
	 * month, or autocorrect it if it is spelled wrongly 
	 * @param date
	 * @param availDates
	 */
	private void checkIfContainsMonth(String date, ArrayList<String> availDates) {
		if (date.split(" ").length >= 2) { 
			String day = date.split(" ")[0]; 
			String mth = date.split(" ")[1]; //get the month
			if (mth.length() <= 3) {
				if (mth.length() == 3) {
					if (monthsMap.containsKey(mth)) {
						//do nth
					} else if (daysOfWeek.containsKey(mth)) {
						//do nth
					} else if (pm.hasAmPm(mth)) {
						//do nth 
					} else {
						ArrayList<String> suggestTemp = correctDateError(mth); 
						if (suggestTemp != null) { 
							for(int i = 0; i < suggestTemp.size(); i++) {
								availDates.add(suggestTemp.get(i)); 
							}
						}
					}
				} else {
					for(int i = 0; i < months.size(); i++) {
						String month = months.get(i);
						if (month.indexOf(mth) == 0) {
							availDates.add(day + " " + month); 
						}
					}
				}
			}
		}
	}
	
	/**
	 * OVERLOADED METHOD: FOR PARSING ADD 
	 * Suggest some dates and times that the user can type
	 * @param date
	 * @return a list of date/time that the user can type
	 */
	private ArrayList<String> suggestDates(String date, String phrase) {
		ArrayList<String> availDates = new ArrayList<String>();
		
		availDates = checkIfSpecialDate(date, availDates);
		if (availDates == null) {
			return null; 
		}
		if (!availDates.isEmpty()) {
			return availDates; 
		}
		
		//eg. sun... mon... [Unable to re-factor this part out due to structure] 
		String parts[] = phrase.split(" "); 
		String number = parts[parts.length-2]; //get 2nd last word
		try {
			int num = Integer.parseInt(number); 
		} catch (Exception e) {
			//check if completed first : 
			if (daysOfWeek.containsKey(date)) {
				return null; 
			} else {
				//only add stuff like sun mon if the thing is not a number
				for(int i = 0; i < specialDays.size(); i++) { 
					if (specialDays.get(i).indexOf(date) == 0) {
						availDates.add(specialDays.get(i));
					}
				}
			}
		}
		
		//check for possible time formats, and suggest times
		if (pm.hasTimeAC(date.trim())) {
			suggestPossibleTime(date.trim(), availDates);
		}
		
		//check for normal date
		if (pm.hasDateAC(date.trim())) {
			addSuggestPossibleNormalDate(date, phrase, availDates);
		}
		
		//check if month 
		if (date.length() <= 3) {
			addSuggestPossibleMonth(date, availDates);
		}
		if (!availDates.isEmpty()) {
			return availDates; 
		}
		return null; 
	}

	/**
	 * For Autocompleting ADD: suggest possible month or correct misspelling of month
	 * @param date
	 * @param availDates
	 */
	private void addSuggestPossibleMonth(String date, ArrayList<String> availDates) {
		if (date.length() == 3) {
			if (monthsMap.containsKey(date.trim())) {
				//do nth
			} else if (pm.hasAmPm(date.trim())) {
				//do nth 
			} else {
				ArrayList<String> suggestTemp = correctDateError(date.trim()); 
				if (suggestTemp != null) {
					for(int i = 0; i < suggestTemp.size(); i++) {
						availDates.add(suggestTemp.get(i)); 
					}
				}
			}
		} else {
			for(int i = 0; i < months.size(); i++) {
				String month = months.get(i);
				if (month.indexOf(date) == 0) {
					availDates.add(month); 
				}
			}
		}
	}

	/**
	 * For Autocompleting ADD: Suggest possible normal date
	 * @param date
	 * @param phrase
	 * @param availDates
	 */
	private void addSuggestPossibleNormalDate(String date, String phrase, ArrayList<String> availDates) {
		String tempDateRaw = getDateRaw(phrase); 
		boolean hasMonth = false; 
		for(int i = 0; i < months.size(); i++) {
			if (tempDateRaw.contains(months.get(i)) && !tempDateRaw.contains("from")) {
				hasMonth = true; 
			}
		}
		if (hasMonth == false) { 
			ArrayList<String> dateRaw = tc.get3MonthsFromNow(); 
			for(int i = 0; i < dateRaw.size(); i++) {
				availDates.add(date.trim()+ " " + dateRaw.get(i)); //dd mmm
			}
		}
	}
	
	/**
	 * Get a rough estimate of date from an input phrase
	 * (doesn't matter if location is included) 
	 * @param phrase
	 * @return estimated date phrase
	 */
	private String getDateRaw(String phrase) {
		String dateRaw = ""; 
		String[] parts = phrase.split(" "); 
		boolean canAdd = false;
		
		for(int i = 0; i < parts.length; i++) {
			String temp = parts[i]; 
			if (temp.equalsIgnoreCase("by") || 
					temp.equalsIgnoreCase("from") ||
					temp.equalsIgnoreCase("at") ||
					temp.equalsIgnoreCase("on")) {
				canAdd = true;
			} else if (canAdd == true) {
				dateRaw += temp; 
			}
		}
		return dateRaw; 
	}
	
	/**
	 * If a command spelling is wrong, try to correct it
	 * @param misSpelled
	 * @return an array list of suggestions for the correct command spelling
	 */
	public ArrayList<String> correctCommandError(String misSpelled) {
		ArrayList<String> suggestions = new ArrayList<String>(); 
		
		for(int i = 0; i < commands.size(); i++) {
			String correctComm = commands.get(i); 
			int temp = levenshteinDist(misSpelled, correctComm); 
			if (temp <= 2) {
				suggestions.add(correctComm); 
			}
			
		}
		return suggestions; 
	}
	
	/**
	 * If the user has misspelt his date, suggest a correction for him 
	 * @param misSpelled
	 * @return list of possible correctly spelled dates 
	 */
	public ArrayList<String> correctDateError(String misSpelled) {
		ArrayList<String> suggestions = new ArrayList<String>(); 
		
		for(int i = 0; i < months.size(); i++) {
			String month = months.get(i); 
			int temp = levenshteinDist(misSpelled, month); 
			if (temp == 0) {
				//exactly the same
				return null;  
			}
			if (temp <= 2) {
				suggestions.add(month); 
			}
		}
		return suggestions; 
	}
	
	/**
	 * This algorithm measure the difference in distance between
	 * a source (src) string and a target (tar) string
	 * Algorithm taken from: https://en.wikipedia.org/wiki/Levenshtein_distance
	 * Upper and lower bounds of the algorithm: 
	 * 1) It is at least the difference in the size of the 2 strings
	 * 2) It is at most the length of the longer string
	 * 3) 0 iff the 2 strings are equal
	 * 4) If the 2 strings are the same size, upperBound of Levenstein distance is the Hamming Distance
	 * 5) Satisfies Triangle Inequality [LD(string1,string2) >= LD(string1) + LD(string2)]
	 * @param src
	 * @param tar
	 * @return distance between the 2 strings 
	 */
	private int levenshteinDist(String src, String tar) {
		//init to 0 automatically by java 
		int[][] d = new int[src.length()+1][tar.length()+1]; 
		
		for(int i = 1; i <= src.length(); i++) {
		      d[i][0] = i;
		}
		
		for(int j = 1; j <= tar.length(); j++) {
			d[0][j] = j; 
		}
		
		for(int j = 1; j <= tar.length(); j++) {
			for(int i = 1; i <= src.length(); i++) {
				int substitutionCost; 
				
				if (src.charAt(i-1) == tar.charAt(j-1)) {
					substitutionCost = 0; 
				} else {
					substitutionCost = 1; 
				}
				d[i][j] = Math.min(d[i-1][j] + 1, //deletion
							Math.min(d[i][j-1] + 1, //insertion
									d[i-1][j-1] + substitutionCost)); //substitution
				
			}
		}
		
		return d[src.length()][tar.length()]; 
	}
	
	
```
###### src\parser\DateTimePatternMatcher.java
``` java
 * This class will check the date/time pattern of the user's input
 * and decide if the format falls into its blacklist, as specified
 * by a regex (regular expression). If it does,
 * return an Error object to tell the user to key in the date in some
 * other format. 
 * This blacklist is to ensure that grammatically incorrect dates and times
 * do not get parsed by PrettyTimeParser, as they are potentially confusing
 * and get varied results from the parser. 
 * @author Xue Hui
 *
 */
public class DateTimePatternMatcher {
	/* Blacklist for Adding task with date/time */
	private String pattern1 = "by \\d{1,2}(:|.)?\\d{0,2} ?(am|pm) on"; 
	private String pattern2 = "on \\d{1,2} (jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec) "
			+ "from \\d{1,2}(:|.)?\\d{0,2} ?(am|pm) to";
	private String pattern3 = "on \\d{1,2} (jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec) "
			+ "\\d{4} from \\d{1,2}(:|.)?\\d{0,2} ?(am|pm) to";
	private String pattern4 = "on (this|next)? (mon|tue|wed|thu|fri|sat|sun) from \\d{1,2}(:|.)?\\d{0,2} ?(am|pm) to"; 
	private String pattern5 = "on (tmr|tomorrow|today) from \\d{1,2}(:|.)?\\d{0,2} ?(am|pm) to"; 
	private String pattern6 = "at \\d{1,2}(:|.)?\\d{0,2} ?(am|pm) by"; 
	
	/* White-list for AutoComplete to suggest date/time */
	private String pattern7 = "\\d{1,2}(:|.)?\\d{0,2} ?(a|p|h)?"; //for time
	private String pattern8 = "\\d{1,2}"; //for date
	private String checkTime = "(am|pm)";
	private String correctTimeFormat = "\\d{1,2}(:|.)?\\d{0,2} ?(am|pm)"; //for time
	private String dateFormat = "\\d{1,2} (jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)"; 
	private String dayFormat = "(mon|tue|wed|thu|fri|sat|sun|monday|tuesday|wednesday|thursday|"
			+ "friday|saturday|sunday|tues|thurs|tmr|tomorrow|today)";
	
	/* White-list for ParseEdit to check if the time has am, pm or h, or morning or night */ 
	private String pattern9 = "\\d{1,2}(:|.)?\\d{0,2} ?(am|pm|h)"; //for time
	private String pattern10= "(morning|night)";
	
	/* ParseAdd: Check if Event Time includes time for both start and End s */
	private String timeChecker = "\\d{1,2}(:|.)?\\d{0,2} ?(am|pm|h)"; 
	
	public DateTimePatternMatcher() {
		
	}
	
	/**
	 * Check if both start and end times of events have times included in them.
	 * @param startTime
	 * @param endTime
	 * @return true if both have times 
	 */
	public boolean isBothTime(String startTime, String endTime) {
		Pattern p = Pattern.compile(timeChecker);
		Matcher m = p.matcher(startTime);
		Matcher m2 = p.matcher(endTime);
		
		while (m.find()) {
			//System.out.println("Found a match.");
			while (m2.find()) {
				//System.out.println("Found a match.");
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Checks if any 3letter input has am or pm in it,
	 * so that AutoComplete does not suggest a month correction
	 * @param input
	 * @return true if it has am or pm in it 
	 */
	public boolean hasAmPm(String input) {
		Pattern p = Pattern.compile(checkTime);
		Matcher m = p.matcher(input);
		
		while (m.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		return false; 
	}
	
	/**
	 * For ParseEdit class:
	 * Checks if the input contains something that looks like a time format
	 * @param input
	 * @return true if there seems to be some kind of time format
	 */
	public boolean hasTimeEdit(String input) {
		Pattern p = Pattern.compile(pattern9);
		Matcher m = p.matcher(input);
		
		Pattern p2 = Pattern.compile(pattern10);
		Matcher m2 = p2.matcher(input);
		
		while (m.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		while (m2.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		return false; 
	}
	
	/**
	 * For AutoComplete class:
	 * Checks if the input contains an exact time format
	 * @param input
	 * @return true if there seems to be some kind of time format
	 */
	public boolean hasCorrectTimeFormat(String input) {
		Pattern p = Pattern.compile(correctTimeFormat);
		Matcher m = p.matcher(input);
		
		while (m.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		return false; 
	}
	
	/**
	 * For AutoComplete class:
	 * Checks if the input contains something that looks like a time format
	 * @param input
	 * @return true if there seems to be some kind of time format
	 */
	public boolean hasTimeAC(String input) {
		if (input.matches(pattern7)) {
			return true; 
		}
		return false; 
	}
	
	/**
	 * For AutoComplete class:
	 * Checks if the input contains something that looks like a date format
	 * @param input
	 * @return true if it matches pattern 
	 */
	public boolean hasDateAC(String input) {
		if (input.matches(pattern8)) {
			try {
				int num = Integer.parseInt(input); 
				if (num >= 1 && num <= 31) {
					return true; 
				}
			} catch (Exception e) {
				return false; 
			}
		}
		return false; 
	}
	
	/**
	 * For AutoComplete class:
	 * Checks if the input contains any date format in the string 
	 * @param input
	 * @return true if there is any date format 
	 */
	public boolean hasFullDateAC(String input) {
		Pattern p = Pattern.compile(dateFormat);
		Matcher m = p.matcher(input);
		
		Pattern p2 = Pattern.compile(dayFormat);
		Matcher m2 = p2.matcher(input);
		
		Pattern p3 = Pattern.compile(pattern8);
		Matcher m3 = p3.matcher(input);
		
		while (m.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		while (m2.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		while (m3.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		return false; 
	}
	
	
	/**
	 * Check if the input falls into any of the patterns specified in this class
	 * @param input
	 * @return true if it contains the pattern, false if it doesn't 
	 */
	public boolean hasPattern(String input) {
		Pattern p = Pattern.compile(pattern1);
		Matcher m = p.matcher(input);
		
		Pattern p2 = Pattern.compile(pattern2);
		Matcher m2 = p2.matcher(input);
		
		Pattern p3 = Pattern.compile(pattern3);
		Matcher m3 = p3.matcher(input);
		
		Pattern p4 = Pattern.compile(pattern4);
		Matcher m4 = p4.matcher(input);
		
		Pattern p5 = Pattern.compile(pattern5);
		Matcher m5 = p5.matcher(input);
		
		Pattern p6 = Pattern.compile(pattern6);
		Matcher m6 = p6.matcher(input);
		
		while (m.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		while (m2.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		while (m3.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		while (m4.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		while (m5.find()) {
			//System.out.println("Found a match.");
			return true;
		}
		
		while (m6.find()) {
			//System.out.println("Found a match.");
			return true;
		}	
		return false; 
	}
	
}
```
###### src\parser\ParseAdd.java
``` java
 * Job of this class is to parse "add" commands. 
 * @author Xue Hui
 *
 */
public class ParseAdd extends ParseCommand { 
	private DateTimePatternMatcher timeChecker = new DateTimePatternMatcher(); 
	private HashMap<String,String> keywordsList = new HashMap<String,String>(); 
	private HashMap<String,Long> specialDays = new SpecialDaysConverter().getSpecialDays();
	
	private TimeConverter timeConverter = new TimeConverter(); 
	private PrettyTimeParser prettyParser = new PrettyTimeParser();
	private DateTimePatternMatcher pm = new DateTimePatternMatcher();  
	
	public ParseAdd() {	
		super();
		
		keywordsList.put("every", "every");
		keywordsList.put("by", "by");
		keywordsList.put("on", "on");
		keywordsList.put("from", "from");
		keywordsList.put("to", "to");
	}
	
	/**
	 * If command is ADD, process and categorise into:
	 * 1. FLOATING
	 * 2. EVENT
	 * 3. DEADLINE 
	 * @param command
	 * @param stringInput
	 * @return appropriate ProcessedObject 
	 */
	protected ProcessedObject processAdd(String command, String stringInput) {
		assert(stringInput != null); 
		
		ProcessedObject processed = null;
		Task task = new Task(); 
		String simpString = stringNoCommand(stringInput); //string without command ADD
		String simpString2 = simpString.split("#")[0].trim(); //string without tags 
		
		//catch any initial format errors first
		processed = catchBasicErrors(simpString2); 
		if (processed != null) {
			return processed; 
		}
		
		//if no basic error, process as floating, event, deadline, or error 
		processed = processNormally(command, processed, task, simpString);
		
		//if there's error, don't continue to process tags
		if (processed.getCommand().compareTo(ParserConstants.ERROR) == 0) {
			return processed;
		}
		
		//process tags now: if there are tags, add it in.
		return processTags(processed, simpString); 
	}
	
	/**
	 * Catch any initial format errors such as empty adds, task names with 
	 * only numbers, and task that only contains !!! 
	 * @param simpString2
	 * @return ProcessedObject 
	 */
	private ProcessedObject catchBasicErrors(String stringInput) {
		ProcessedObject processed = null; 
		String onlyPriorityPattern = "(!|!!|!!!|!!!!|!!!!!|!!!!!!)"; 
		
		if (isEmptyAdd(stringInput)) {	
			processed = super.processError(ParserConstants.ERROR_ADD_EMPTY);
		}
		
		if(isOnlyNumbers(stringInput)) {
			processed = super.processError(ParserConstants.ERROR_ONLY_NUMS);
		} 
		
		if (stringInput.matches(onlyPriorityPattern)) {
			processed = super.processError(ParserConstants.ERROR_ADD_EMPTY);
		}
		return processed; 
	}
	
	/**
	 * Process tags for a task if there is any
	 * @param processed
	 * @param simpString
	 * @return ProcessedObject
	 */
	private ProcessedObject processTags(ProcessedObject processed, String simpString) {
		if (simpString.split("#").length != 1) {
			ArrayList<String> tags = getTagList(simpString); 
			if (!isValidTagList(tags)) {
				return super.processError(ParserConstants.ERROR_ADD_INVALID_TAG); 
			}
			processed.getTask().setTaskTags(tags);
		}
		return processed;
	}
	
	/**
	 * Check that the taglist does not contain default category words (eg. event)
	 * or that the categories repeat multiple times 
	 * @param tagList
	 * @return true if none of the tags in tagList repeats. 
	 */
	private boolean isValidTagList(ArrayList<String> tagList) {
		String pattern = "(deadline|deadlines|event|events|general|all)";
		for(int i = 0; i < tagList.size(); i++) {
			String tag = tagList.get(i); 
			if (tag.matches(pattern)) {
				return false; 
			}
			//compare with every other tag in the list to ensure no repeats
			for (int j = i+1; j < tagList.size(); j++) {
				String otherTag = tagList.get(j); 
				if (tag.equals(otherTag)) {
					return false; 
				}
			}
		}
		return true; 
	}
	
	
	/**
	 * Processes the string normally as either a 
	 * floating, deadline or event task.
	 * If there is any formatting error, return error 
	 * @param command
	 * @param processed
	 * @param task
	 * @param simpString
	 * @return ProcessedObject 
	 */
	private ProcessedObject processNormally(String command, ProcessedObject processed, 
			Task task, String simpString) {
		String taskNameRaw; 
		//catch incorrect input where "by/at/from/on" is used without a time 
		try {
			taskNameRaw = removeTimeFromName(simpString); 
		} catch (Exception e) {
			return super.processError(ParserConstants.ERROR_DATE_KEYWORD); 
		}
		
		String taskName = taskNameRaw.substring(0, 1).toUpperCase() + taskNameRaw.substring(1);
		String rawDate = simpString.replace(taskNameRaw, "").trim();
		int priority = getPriority(rawDate); 
		
		//invalid priority given
		if (priority == -1) {
			return super.processError(ParserConstants.ERROR_SET_NEW_PRIORITY);
		}
		
		rawDate = rawDate.split("!")[0].trim(); //remove priority
		rawDate = rawDate.split("#")[0].trim(); //remove tags
		
		//do pattern matching on raw date here: catch blacklisted dates
		if (pm.hasPattern(rawDate)) {
			processed = super.processError(String.format(
					ParserConstants.ERROR_DATE_GRAMMAR, rawDate));
			return processed; 
		}
		
		if (rawDate.contains("from")) {
			if (simpString.split("from").length != 1) {
				//event
				processed = handleEvent(task, taskName, rawDate);
			}
		} else if (rawDate.indexOf("by") == 0) {
			if (simpString.split("by").length != 1) {
				//deadline 
				processed = handleDeadline(task, taskName, rawDate);
			} 
		} else if (rawDate.indexOf("on") == 0) {
			if (simpString.split("on").length != 1) {
				//deadline
				processed = handleDeadline(task, taskName, rawDate);	
			}
		} else if (rawDate.indexOf("at") == 0) {
			if (simpString.split("at").length != 1) {
				//handle as deadline 
				processed = handleDeadline(task, taskName, rawDate);
			}
		} else {
			//set as floating task, remove priority first  
			priority = getPriority(taskName); 
			//invalid priority given
			if (priority == -1) {
				return super.processError(ParserConstants.ERROR_SET_NEW_PRIORITY);
			}
			if (priority != 0) {
				taskName = taskName.split("!")[0].trim();
			}
			processed = handleFloating(command, taskName);
		}
		//set the priority
		if (priority != 0) {
			processed.getTask().setPriority(priority);
		}
		return processed;
	}
	
	/**
	 * If the task description is empty, it is considered an 
	 * empty add. So, return true to indicate error. 
	 * @param simpString
	 * @return ProcessedObject
	 */
	private boolean isEmptyAdd(String simpString) {
		if (simpString.compareTo("") == 0) {
			return true; 
		}
		return false; 
	}
	
	/**
	 * if taskname consists entirely of numbers, return true
	 * to indicate error
	 * @param simpString
	 * @return true if taskname only consists of numbers
	 */
	private boolean isOnlyNumbers(String simpString) {
		try {
			int temp = Integer.parseInt(simpString); 
			return true; 
		} catch (Exception e) {
			return false;
		} 
	}

	/**
	 * ADD: process event 
	 * @param task
	 * @param simpString
	 * @return ProcessedObject
	 */
	private ProcessedObject handleEvent(Task task, String taskName, String rawDate) {
		long epochTime;
		ProcessedObject processed = null;
		
		String[] changeSplitter = rawDate.split(" ");
		for(int i = 0; i < changeSplitter.length; i++) {
			if (changeSplitter[i].equals("to")) {
				changeSplitter[i] = ";"; 
			}
		}
		String rawDate2 = String.join(" ", changeSplitter);
		String simpString2 = rawDate2.replace("2day", "today"); 
		simpString2 = simpString2.replace("tmr", "tomorrow"); 
		simpString2 = simpString2.replace("from", "").trim();
		String[] dateList = simpString2.split(";"); 
		String dateForPrettyParser = rawDate;
		
		String rawStartDate = dateList[0].trim().toLowerCase().trim();
		String rawEndDate = dateList[1].trim().toLowerCase().trim(); 
		long epochTimeStart = -1;
		long epochTimeEnd = -1;  
		
		//if both start and end contain time, use PrettyTime 
		if (pm.isBothTime(rawStartDate, rawEndDate)) {
			try {
				long[] epochTimeEvent = getPrettyTimeEvent(dateForPrettyParser);
				epochTimeStart = epochTimeEvent[0]; 
				epochTimeEnd = epochTimeEvent[1]; 
				task.setStartDate(epochTimeStart);
				task.setEndDate(epochTimeEnd);
				task.setTaskName(taskName);
				task.setTaskType("EVENT");
				processed = new ProcessedObject("ADD_EVENT",task);
				
				//make sure start time < end Time 
				if (!isValidEvent(epochTimeStart, epochTimeEnd)) {
					return super.processError(ParserConstants.ERROR_EVENT_TIME_INVALID); 
				}	
				return processed;
			} catch (Error e) {
				//do nothing, try to process below
			}
		} 
		
		//Start Time Handling 
		epochTime = getPrettyTime(rawStartDate);
		if (epochTime != -1) {
			epochTimeStart = epochTime; 
			task.setStartDate(epochTime); 
		} else if (!specialDays.containsKey(rawStartDate)) {
			try {
				epochTime = timeConverter.toEpochTime(rawStartDate);
				epochTimeStart = epochTime; 
				task.setStartDate(epochTime);
			} catch (ParseException error) {
				processed = super.processError(String.format(
						ParserConstants.ERROR_DATE_FORMAT, rawStartDate)); 
				return processed; 
			}
		} else {
			//process the special day
			epochTime = specialDays.get(rawStartDate);
			epochTimeStart = epochTime; 
			task.setStartDate(epochTime);
		}
		
		//End Time Handling
		epochTime = getPrettyTime(rawEndDate);
		if (epochTime != -1) {
			epochTimeEnd = epochTime; 
			task.setEndDate(epochTime); 
		} else if (!specialDays.containsKey(rawEndDate)) {
			try {
				epochTime = timeConverter.toEpochTime(rawEndDate);
				epochTimeEnd = epochTime; 
				task.setEndDate(epochTime);
			} catch (ParseException error) {
				processed = super.processError(String.format(
						ParserConstants.ERROR_DATE_FORMAT, rawEndDate)); 
				return processed; 
			}
		} else {
			//process the special day
			epochTime = specialDays.get(rawEndDate);
			epochTimeEnd = epochTime; 
			task.setEndDate(epochTime);
		}
		
		task.setTaskName(taskName);
		task.setTaskType("EVENT");
		processed = new ProcessedObject("ADD_EVENT",task);
		
		
		//check to make sure startDate < end date 
		if (!isValidEvent(epochTimeStart, epochTimeEnd)) {
			return super.processError(ParserConstants.ERROR_EVENT_TIME_INVALID); 
		}
		
		return processed;
	}
	
	/**
	 * Checks if an event time is valid (ie, start time < end time) 
	 * @param eventStartTime
	 * @param eventEndTime
	 * @return true if start time < end time 
	 */
	private boolean isValidEvent(long eventStartTime, long eventEndTime) {
		if (eventStartTime == -1 || eventEndTime == -1) {
			return false; 
		}
		if (eventStartTime >= eventEndTime) {
			return false; 
		}
		return true; 
	}
	
	/**
	 * ADD: process deadlines with the keyword "by", "on" and "at" 
	 * @param task
	 * @param simpString
	 * @return ProcessedObject
	 */
	private ProcessedObject handleDeadline(Task task, String taskName, String rawDate) {
		long epochTime;
		ProcessedObject processed;
		String dateForPrettyParser = rawDate;
		String[] splitDate = rawDate.split(" ");
		rawDate = ""; 
		for(int i=1; i < splitDate.length; i++) { 
			rawDate += splitDate[i] + " "; 
		}
		rawDate = rawDate.trim(); 
		rawDate = rawDate.replace("tmr", "tomorrow"); 
		
		
		//if time contains am or pm or morning or night, 
		//call pretty parser to process the time.
		epochTime = getPrettyTime(dateForPrettyParser);
		if (epochTime != -1) {
			task.setDeadline(epochTime); 
		} else if (!specialDays.containsKey(rawDate.toLowerCase())) {
			//process standard calendar dates (eg. 17 Feb) 
			try {
				epochTime = timeConverter.toEpochTime(rawDate); 
				task.setDeadline(epochTime);
			} catch (ParseException error) {
				processed = super.processError(String.format(
						ParserConstants.ERROR_DATE_FORMAT, rawDate)); 
				return processed; 
			}
		} else {
			//process the special day
			epochTime = specialDays.get(rawDate.toLowerCase());
			task.setDeadline(epochTime);
		}
		
		task.setTaskName(taskName);
		task.setTaskType("DEADLINE");
		processed = new ProcessedObject("ADD_DEADLINE",task);
		return processed;
	}
	
	/**
	 * ADD: Process floating event 
	 * @param command
	 * @param simpString
	 * @return ProcessedObject
	 */
	private ProcessedObject handleFloating(String command, String simpString) {
		ProcessedObject processed;
		String taskName = simpString.split("#")[0].trim();
		Task newTask = new Task(taskName); 
		
		newTask.setTaskType("FLOATING");
		processed = new ProcessedObject("ADD_FLOATING",newTask);
		
		return processed;
	}
	
	/**
	 * Given a stringInput, remove the command from the string
	 * @param command
	 * @param stringInput
	 * @return taskName without command
	 */
	private String stringNoCommand(String stringInput) {
		String command = stringInput.split(" ")[0]; //so we don't need to worry about case
		String task = stringInput.replaceFirst(command, "");
		
		return task.trim(); 
	}
	
	/**
	 * If the rawDate contains a time field, use PrettyTimeParser to
	 * parse the date
	 * @param rawDate
	 * @return epochTime (long) of rawDate
	 */
	private long getPrettyTime(String rawDate) {
		//use regex to check for time format
		if (timeChecker.hasTimeEdit(rawDate)) {
			//if the date contains any of the time words, call PrettyParser
			List<Date> processedTime = prettyParser.parse(rawDate); 
			if (!processedTime.isEmpty()) {
				return processedTime.get(0).getTime() / 1000; 
			} else {
				return -1; //unable to process 
			}
		}
		return -1; //no time indicated, or time is in the wrong format
	}
	
	/**
	 * If the rawDate contains time field for an event, 
	 * use PrettyTimeParser to parse the date
	 * @param rawDate
	 * @return epochTime (long array) of rawDate (FOR EVENTS) 
	 */
	private long[] getPrettyTimeEvent(String rawDate) throws Error {
		//use regex to check for time format
		if (timeChecker.hasTimeEdit(rawDate)) {
			//if the date contains any of the time words, call prettyParser
			List<Date> processedTime = prettyParser.parse(rawDate); 
			if (processedTime.size() >= 2) {
				long[] epochTimes = {processedTime.get(0).getTime() / 1000,
						processedTime.get(1).getTime() / 1000}; 
					
				return epochTimes; 
			} else {
				throw new Error(); 
			}
		}
		throw new Error(); //no time indicated, or time is in the wrong format
	}
	
	/**
	 * Get tag list for a task
	 * Assumptions: all tags must be added to the back of the userInput
	 * @param rawInput
	 * @return ArrayList of Tags
	 */
	private ArrayList<String> getTagList(String rawInput) {
		ArrayList<String> tagList = new ArrayList<String>();
		String[] splitString = rawInput.split("#");
		for(int i = 1; i < splitString.length; i++) {
			String tag = splitString[i].replace("!", "").trim(); 
			tagList.add(tag);
		}
		return tagList; 
	}
	
	/**
	 * Return the priority for a task 
	 * @param rawDate: date with priority still stuck there... 
	 * @return priority for the task
	 */
	private int getPriority(String rawDate) {
		//rawDate = rawDate.trim(); 
		int count = 0; 
		int dateLen = rawDate.length(); 
		boolean canContinue = false; 
		
		for(int i = dateLen-1; i >= 0; i--) {
			char k = rawDate.charAt(i); 
			//check that the end of the string has !, 
			//else there's no priority to check 
			if (i == dateLen-1 && k == '!') {
				canContinue = true; 
				count += 1;
			} else if (canContinue == true) {
				if (k == '!') {
					count += 1; 
				}
			} else {
				return 0; //user did not indicate a priority 
			}
		}
		
		if (count <= 3) {
			return count;
		}
		return -1; //error with priority 
	}
	
	/**
	 * Depending on where the user keyed in his dates, the task name
	 * might still contain the time in it. So this function will remove
	 * the time from the task name (if it is there) 
	 * @param taskName
	 * @return task name without time. 
	 */
	private String removeTimeFromName(String taskName) throws Exception {
		String keyword = "(at|from|on|by)";
		String combinedTime = "\\d{1,2}(:|.)?\\d{0,2}(am|pm|h)";
		String combinedTime2 = "(tonight|night|morning)"; //not in special days converter
		String timeSpecifier = "(am|pm|h)";
		String timePattern = "\\d{1,2}(:|.)?\\d{0,2}"; //regex
		String specialDaysKeywords = "(this|next)";
		String stringRep = ""; 
		String[] splitName = taskName.split(" "); 
		int size = splitName.length; 
		
		for(int i = 0; i < size; ) {
			String word = splitName[i]; 
			if (word.matches(keyword)) {
				if (i+1 < size) {
					String time = splitName[i+1];
					if (time.matches(combinedTime) || specialDays.containsKey(time) ||
							time.matches(combinedTime2)) {
						//eg. 3pm or 3h or today/tomorrow/fri
						i += 2; 
						break;
					} else if (time.matches(timePattern) || time.matches(specialDaysKeywords)) {
						//eg. only a number or contains "this/next" 
						if (i+2 < size) {
							String time2 = splitName[i+2];
							String time3 = time + " " + time2; 
							if (time2.matches(timeSpecifier) || time2.length() == 3) {
								//eg. 3 pm or 2300 h or a month like feb 
								//(assume v. few words len(3) after num) 
								i += 2;
								break;								
							} else if (specialDays.containsKey(time3)) {
								//eg. this fri or next fri
								i += 2;
								break; 							
							} else {
								//probably a place and not time
								stringRep += word + " " + time + " " + time2 + " ";
								i += 3; 
								continue; 
							}
						} else {
							stringRep += time + " "; 
							i += 2; 
						}
					} else {
						//probably a place and not time,
						//so add it to the task name 
						stringRep += word + " " + time + " ";
						i += 2; 
						continue; 
					}
				} else {
					//i+1 doesnt exist 
					throw new Exception(); 
				}
			} else {
				stringRep += word + " "; 
				i += 1; 
			}
		}	
		return stringRep.trim(); 
	}
}
```
###### src\parser\ParseClear.java
``` java
 * Job of this class is to parse "Clear" commands. 
 * @author Xue Hui
 *
 */
public class ParseClear extends ParseCommand {
	
	public ParseClear() {
		super(); 
	}
	
	protected ProcessedObject processClear(String command) {
		assert(command != null);
		
		return new ProcessedObject(command.toUpperCase()); 
	}

}
```
###### src\parser\ParseCommand.java
``` java
 * Parent class for all kinds of Parse (eg. ParseAdd, etc..)
 * This is to ensure that all Parse classes has a means to 
 * process error. 
 * @author Xue Hui
 *
 */
public class ParseCommand {
	
	public ParseCommand() {
		
	}
	
	/**
	 * Process Errors for string formatting/commands/etc... 
	 * @param errorType
	 * @return
	 */
	protected ProcessedObject processError(String errorType) {
		assert(errorType != null); 
		
		ProcessedObject processed = new ProcessedObject("ERROR");
		processed.setErrorType(errorType); 
		
		return processed;
	}

}
```
###### src\parser\ParseDelete.java
``` java
 * Purpose of this class is to parse the "delete" command
 * @author Xue Hui
 *
 */
public class ParseDelete extends ParseCommand {
	
	public ParseDelete() {
		super(); 
	}
	
	/**
	 * If command is delete, check if the deletion is by 
	 * 1. NAME, or
	 * 2. INDEX 
	 * 3. By Category (either by user defined tags or basic categories
	 * and return the appropriate ProcessedObject
	 * @param command
	 * @param stringInput
	 * @return appropriate ProcessedObject 
	 */
	protected ProcessedObject processDelete(String stringInput) {
		assert(stringInput != null); 
		
		ProcessedObject processed; 
		String taskName = getTaskName(stringInput);
		
		if (taskName.compareTo("") == 0) {
			return super.processError(ParserConstants.ERROR_DEL_EMPTY); 
		}
		
		//delete by category
		if (taskName.contains("#")) {
			return handleDeleteByCategory(taskName);
		}
		
		//handle delete by index of delete by task name
		processed = handleSingleDelete(taskName);
		
		return processed; 
	}
	
	/**
	 * Handle deleting by a single index or a single task name
	 * @param taskName
	 * @return ProcessedObject
	 */
	private ProcessedObject handleSingleDelete(String taskName) {
		ProcessedObject processed;
		try {
			//delete by index
			int index = Integer.parseInt(taskName);
			processed = new ProcessedObject(ParserConstants.DELETE_BY_INDEX, index-1); 
			
		} catch (Exception e) {
			//if the delete is not by index, then it's by task name. 
			processed = new ProcessedObject(ParserConstants.DELETE_BY_NAME, new Task(taskName));
		}
		return processed;
	}

	/**
	 * Process the deleting by category
	 * @param taskName
	 * @return ProcessedObject
	 */
	private ProcessedObject handleDeleteByCategory(String taskName) {
		ProcessedObject processed;
		String[] splitArr = taskName.split("#");
		if (splitArr.length > 1) { 
			String category = splitArr[1].trim(); 
			processed = new ProcessedObject(ParserConstants.DELETE_BY_CATEGORY); 
			processed.setCategory(category);
			return processed; 
		} else {
			return super.processError(ParserConstants.ERROR_DEL_EMPTY_CAT); 
		}
	}
	
	/**
	 * Given a stringInput, remove the command from the string
	 * @param command
	 * @param stringInput
	 * @return taskName without command
	 */
	private String getTaskName(String stringInput) {
		String command = stringInput.split(" ")[0]; 
		String task = stringInput.replaceFirst(command, "");
		
		return task.trim(); 
	}
}
```
###### src\parser\ParseDone.java
``` java
 * Purpose of this class is to parse the "done" command 
 * @author Xue Hui
 *
 */
public class ParseDone extends ParseCommand {
		
	public ParseDone() {
		super(); 
	}

	/**
	 * If command is done, check if the done is by 
	 * 1. NAME, or
	 * 2. INDEX 
	 * and return the appropriate ProcessedObject
	 * @param command
	 * @param stringInput
	 * @return appropriate ProcessedObject 
	 */
	protected ProcessedObject processDone(String stringInput) {
		assert(stringInput != null); 
		
		ProcessedObject processed; 
		String taskName = getTaskName(stringInput);
		
		if (taskName.compareTo("") == 0) {
			return super.processError(ParserConstants.ERROR_DONE_EMPTY);
		}
		
		//handle done by index/done by task name
		processed = handleNormalDone(taskName);
		
		return processed; 
	}

	/**
	 * Handle done by index/ done by task name
	 * @param taskName
	 * @return ProcessedObject
	 */
	private ProcessedObject handleNormalDone(String taskName) {
		ProcessedObject processed;
		try {
			int index = Integer.parseInt(taskName);
			processed = new ProcessedObject(ParserConstants.DONE_BY_INDEX, index-1); 
			
		} catch (Exception e) {
			//if the done is not by index, then it's by task name. 
			processed = new ProcessedObject(ParserConstants.DONE_BY_NAME, new Task(taskName));
		}
		return processed;
	}
	
	/**
	 * Given a stringInput, remove the command from the string
	 * @param command
	 * @param stringInput
	 * @return taskName without command
	 */
	private String getTaskName(String stringInput) {
		String command = stringInput.split(" ")[0]; 
		String task = stringInput.replaceFirst(command, "");
		
		return task.trim(); 
	}
}
```
###### src\parser\ParseEdit.java
``` java
 * Purpose is to parse the "set" command. 
 * @author Xue Hui
 *
 */
public class ParseEdit extends ParseCommand {
	private DateTimePatternMatcher timeChecker = new DateTimePatternMatcher(); 
	private HashMap<String,String> keywordsList = new HashMap<String,String>(); 
	private HashMap<String,Long> specialDays = new SpecialDaysConverter().getSpecialDays();
	
	private TimeConverter timeConverter = new TimeConverter(); 
	private PrettyTimeParser prettyParser = new PrettyTimeParser();
	
	public ParseEdit() {
		super(); 
		keywordsList.put("every", "every");
		keywordsList.put("by", "by");
		keywordsList.put("on", "on");
		keywordsList.put("from", "from");
		keywordsList.put("to", "to");
	}
	
	/**
	 * If command is SET, categorise into:
	 * 1. UPDATE_BY_INDEX_CHANGE_NAME
	 * 2. UPDATE_BY_INDEX_CHANGE_DATE
	 * 3. UPDATE_BY_INDEX_CHANGE_BOTH
	 * 4. UPDATE_BY_INDEX_CHANGE_PRIORITY
	 * 5. UPDATE_BY_NAME_CHANGE_NAME
	 * 6. UPDATE_BY_NAME_CHANGE_DATE
	 * 7. UPDATE_BY_NAME_CHANGE_BOTH
	 * 8. UPDATE_BY_NAME_CHANGE_PRIORITY 
	 * @param command
	 * @param stringInput
	 * @return appropriate ProcessedObject
	 */
	protected ProcessedObject processSet(String stringInput) {
		assert(stringInput != null); 
		
		String strNoCommand = removeCommand(stringInput);
		
		if (stringInput.split(" ").length > 1) {
			String rawIndex = getTaskName(strNoCommand);
			String newTaskName = getNewName(strNoCommand);
			String newDate = getNewDate(strNoCommand); 
			int newPriority = getNewPriority(strNoCommand); 
			
			if (rawIndex.compareTo("") == 0) {
				return super.processError(ParserConstants.ERROR_NAME_EMPTY);
			}
			
			if (newPriority == -1) {
				return super.processError(ParserConstants.ERROR_SET_NEW_PRIORITY); 
			}
			
			try {
				int index = Integer.parseInt(rawIndex);	
				return updateByIndex(index-1, newTaskName, newDate, newPriority); 
			} catch (Exception e) {
				//if the update is not by index, then it's by task name. 
				//here rawIndex == old Task Name 
				return updateByName(rawIndex, newTaskName, newDate, newPriority); 
			}
		}
		//empty input, return error 
		return super.processError(ParserConstants.ERROR_INPUT_EMPTY);
	}
	
	/**
	 * Called by processSet(). Updates based on index the user has keyed in 
	 * @param index
	 * @param newTaskName
	 * @param newDateRaw
	 * @param newPriority
	 * @return ProcessedObject
	 */
	private ProcessedObject updateByIndex(int index, String newTaskName, String newDateRaw,
			int newPriority) {
		ProcessedObject processed = null; 
		
		//changing priority only 
		if (newPriority != 0) { 
			return updatePriorityByIndex(index, newPriority); 
		}
		
		//changing name only
		if (newTaskName != null && newDateRaw == null) {
			processed = new ProcessedObject(ParserConstants.UPDATE_BY_INDEX_CHANGE_NAME, index); 
			return updateChangeName(processed, newTaskName); 
		} else if (newDateRaw != null && newTaskName == null) {
			//changing date only 
			newDateRaw = newDateRaw.replace("tmr", "tomorrow"); //prettytime cannot accept tmr
			processed = new ProcessedObject(ParserConstants.UPDATE_BY_INDEX_CHANGE_DATE, index);
			return updateDate(newDateRaw, processed);
		} else if (newDateRaw != null && newTaskName != null) {
			//change both name and date 
			newDateRaw = newDateRaw.replace("tmr", "tomorrow"); 
			processed = new ProcessedObject(ParserConstants.UPDATE_BY_INDEX_CHANGE_BOTH, index);
			processed = updateChangeName(processed, newTaskName); 
			return updateDate(newDateRaw, processed);
		} else {
			//error: wrong format
			processed = super.processError(ParserConstants.ERROR_STRING_FORMAT);
			return processed; 
		}
	}

	/**
	 * Update a date of a task by its index
	 * @param newDateRaw
	 * @param processed
	 * @return ProcessedObject
	 */
	private ProcessedObject updateDate(String newDateRaw, ProcessedObject processed) {
		if (newDateRaw.toLowerCase().compareTo("none") == 0) {
			//change the task to floating
			return updateToFloating(processed); 
		} else if (newDateRaw.split(",").length == 2) {
			//change the task to event
			return updateToEvent(processed, newDateRaw); 
		} else {
			// change the task to deadline
			return updateToDeadline(processed, newDateRaw);
		}
	}

	/**
	 * Change the priority of a task
	 * @param index
	 * @param newPriority
	 * @return ProcessedObject
	 */
	private ProcessedObject updatePriorityByIndex(int index, int newPriority) {
		ProcessedObject processed;
		processed = new ProcessedObject(ParserConstants.UPDATE_BY_INDEX_CHANGE_PRIORITY,
				index); 
		processed.setNewPriority(newPriority);
		return processed;
	}
	
	/**
	 * Called by processSet(). Updates based on task name that user has keyed in 
	 * @param oldTaskName
	 * @param newTaskName
	 * @param newDateRaw
	 * @param newPriority
	 * @return ProcessedObject
	 */
	private ProcessedObject updateByName(String oldTaskName, String newTaskName,
			String newDateRaw, int newPriority) {
		ProcessedObject processed = null; 
		
		//changing priority only 
		if (newPriority != 0) { 
			return updatePriorityByName(oldTaskName, newPriority); 
		}
		
		//if changing name only
		if (newTaskName != null && newDateRaw == null) {
			processed = new ProcessedObject(ParserConstants.UPDATE_BY_NAME_CHANGE_NAME, 
					new Task(oldTaskName)); 
			return updateChangeName(processed, newTaskName); 
		} else if (newDateRaw != null && newTaskName == null) {
			//changing date only
			processed = new ProcessedObject(ParserConstants.UPDATE_BY_NAME_CHANGE_DATE, 
					new Task(oldTaskName)); 
			
			return updateDate(newDateRaw, processed);
		} else if (newTaskName != null && newDateRaw != null) {
			//changing both name and date 
			processed = new ProcessedObject(ParserConstants.UPDATE_BY_NAME_CHANGE_BOTH,
					new Task(oldTaskName));
			processed = updateChangeName(processed, newTaskName); 
			return updateDate(newDateRaw, processed);
		} else {
			//error: wrong format
			processed = super.processError(ParserConstants.ERROR_STRING_FORMAT);
			return processed; 
		}
	}

	/**
	 * Update priority of a task by its task name
	 * @param oldTaskName
	 * @param newPriority
	 * @return ProcessedObject
	 */
	private ProcessedObject updatePriorityByName(String oldTaskName, int newPriority) {
		ProcessedObject processed;
		processed = new ProcessedObject(ParserConstants.UPDATE_BY_NAME_CHANGE_PRIORITY,
						new Task(oldTaskName)); 
		processed.setNewPriority(newPriority);
		return processed;
	}
	
	/**
	 * Given a task name, we want to change that task's name 
	 * @param processed
	 * @param taskName
	 * @return ProcessedObject
	 */
	private ProcessedObject updateChangeName(ProcessedObject processed,	String newTaskName) {
		processed.setNewTaskName(newTaskName);
		return processed; 
	}
	
	
	/**
	 * Given a task we want to we want to change the task type to event. 
	 * @param processed
	 * @param newDateRaw
	 * @return ProcessedObject
	 */
	private ProcessedObject updateToEvent(ProcessedObject processed, String newDateRaw) {
		long epochTime; 
		long startTime = -1;
		long endTime = -1; 
		String[] dateList = newDateRaw.split(","); 
		String startDate = dateList[0].trim().toLowerCase();
		String endDate = dateList[1].trim().toLowerCase();
		Task changedTask = null; 
		
		if (processed.getCommand().compareTo(ParserConstants.UPDATE_BY_NAME_CHANGE_BOTH) == 0) {
			changedTask = processed.getTask(); 
		} else if (processed.getCommand().compareTo(ParserConstants.UPDATE_BY_NAME_CHANGE_DATE) == 0) {
			changedTask = processed.getTask();
		} else {
			changedTask = new Task(); 
		}
		changedTask.setTaskType("EVENT");
		//if time contains am or pm or morning or night, 
		//call pretty parser to process the time.
		epochTime = getPrettyTime(startDate);
		if (epochTime != -1) {
			startTime = epochTime; 
			changedTask.setStartDate(epochTime); 
		} else if (!specialDays.containsKey(startDate)) {
			try {
				epochTime = timeConverter.toEpochTime(startDate);
				startTime = epochTime; 
				changedTask.setStartDate(epochTime);
			} catch (ParseException error) {
				processed = super.processError(String.format(
						ParserConstants.ERROR_DATE_FORMAT, startDate)); 
				return processed; 
			}
		} else {
			//process the special day
			epochTime = specialDays.get(startDate);
			startTime = epochTime; 
			changedTask.setStartDate(epochTime);
		}
		
		epochTime = getPrettyTime(endDate);
		if (epochTime != -1) {
			endTime = epochTime; 
			changedTask.setEndDate(epochTime); 
		} else if (!specialDays.containsKey(endDate)) {
			try {
				epochTime = timeConverter.toEpochTime(endDate);
				endTime = epochTime; 
				changedTask.setEndDate(epochTime);
			} catch (ParseException error) {
				processed = super.processError(String.format(
						ParserConstants.ERROR_DATE_FORMAT, endDate)); 
				return processed; 
			}
		} else {
			//process the special day
			epochTime = specialDays.get(endDate);
			endTime = epochTime; 
			changedTask.setEndDate(epochTime);
		}
		//check to make sure valid event time 
		if (!isValidEvent(startTime, endTime)) {
			return super.processError(ParserConstants.ERROR_EVENT_TIME_INVALID);
		}
		
		processed.setTask(changedTask);
		return processed;
	}
	
	/**
	 * Checks if an event time is valid (ie, start time < end time) 
	 * @param eventStartTime
	 * @param eventEndTime
	 * @return true if start time < end time 
	 */
	private boolean isValidEvent(long eventStartTime, long eventEndTime) {
		if (eventStartTime == -1 || eventEndTime == -1) {
			return false; 
		}
		
		if (eventStartTime >= eventEndTime) {
			return false; 
		}
		return true; 
	}
	
	/**
	 * Given a task we want to update the task type to deadline
	 * @param processed
	 * @param newDateRaw
	 * @return ProcessedObject
	 */
	private ProcessedObject updateToDeadline(ProcessedObject processed, String newDateRaw) {
		long epochTime; 
		Task changedTask = null; 
		
		if (processed.getCommand().compareTo(ParserConstants.UPDATE_BY_NAME_CHANGE_BOTH) == 0) {
			changedTask = processed.getTask(); 
		} else if (processed.getCommand().compareTo(ParserConstants.UPDATE_BY_NAME_CHANGE_DATE) == 0) {
			changedTask = processed.getTask();
		} else {
			changedTask = new Task(); 
		}
		changedTask.setTaskType("DEADLINE");
		
		epochTime = getPrettyTime(newDateRaw);
		if (epochTime != -1) {
			changedTask.setDeadline(epochTime); 
		} else if (!specialDays.containsKey(newDateRaw.toLowerCase())) {
			try {
				epochTime = timeConverter.toEpochTime(newDateRaw.toLowerCase());
				changedTask.setDeadline(epochTime);
			} catch (ParseException error){
				processed = super.processError(String.format(
						ParserConstants.ERROR_DATE_FORMAT, newDateRaw.toLowerCase())); 
				return processed; 
			}
		} else {
			//process the special day
			epochTime = specialDays.get(newDateRaw);
			changedTask.setDeadline(epochTime);
		}
		
		processed.setTask(changedTask);
		return processed; 
	}
	
	/**
	 * Given a task we want to update task type to floating
	 * @param processed
	 * @return ProcessedObject
	 */
	private ProcessedObject updateToFloating(ProcessedObject processed) {
		Task changedTask = null; 
		
		if (processed.getCommand().compareTo(ParserConstants.UPDATE_BY_NAME_CHANGE_BOTH) == 0) {
			changedTask = processed.getTask(); 
		} else if (processed.getCommand().compareTo(ParserConstants.UPDATE_BY_NAME_CHANGE_DATE) == 0) {
			changedTask = processed.getTask();
		} else {
			changedTask = new Task(); 
		}
		changedTask.setTaskType("FLOATING");
		processed.setTask(changedTask);
		return processed;
	}
	
	/**
	 * Given a stringInput, remove the command from the string
	 * @param command
	 * @param stringInput
	 * @return taskName without command
	 */
	private String removeCommand(String stringInput) {
		String command = stringInput.split(" ")[0]; 
		String task = stringInput.replaceFirst(command, "");
		
		return task.trim(); 
	}
	
	/**
	 * Remove new dates and new task name from the stringInput
	 * ie, just retrieve either the old task name or index of the old task
	 * @param stringInput
	 * @return
	 */
	private String getTaskName(String stringInput) {
		int strLen = stringInput.length(); 
		boolean canAdd = true;
		String taskName = ""; 
		
		for(int i = 0; i < strLen; i++) {
			char k = stringInput.charAt(i); 
			if (k == '"') {
				//specifier for change task name
				canAdd = false;
				break; 
			} else if (k == '[') {
				//specifier for change date
				canAdd = false;
				break;
			} else if (k == '!') {
				//specifier for change priority
				canAdd = false;
				break; 
			} else if (canAdd == true) {
				taskName += k; 
			}
		}
		return taskName.trim(); 
	}
	
	/**
	 * Get new priority for the task
	 * @param stringInput
	 * @return priority level 1,2,3 or -1 if error
	 */
	private int getNewPriority(String stringInput) {
		int strLen = stringInput.length();
		int count = 0; 
		
		for(int i = 0; i < strLen; i++) {
			char k = stringInput.charAt(i);
			//specifier for change priority
			if (k == '!') {
				count += 1; 
			} 
		}
		if (count <= 3) {
			return count; 
		} 
		return -1; 	
	}
	
	/**
	 * If stringInput has a new date entered, look for the []
	 * and get the dates 
	 * @param stringInput
	 * @return newDate if there is any, else return null 
	 */
	private String getNewDate(String stringInput) {
		int strLen = stringInput.length(); 
		boolean canAdd = false; 
		String date = ""; 
		
		for(int i = 0; i < strLen; i++) {
			char k = stringInput.charAt(i); 
			if (k == '[') {
				canAdd = true; 
			} else if (k == ']') {
				canAdd = false;
				break;
			} else if (canAdd == true) {
				date += k; 
			}
		}	
		
		if (date.compareTo("") == 0) {
			return null; 
		}
		return date.trim().toLowerCase(); 
	}
	
	/**
	 * Given a raw input string, look for the new name of
	 * the task if there is any
	 * @param stringInput
	 * @return new task name if there is, else return null. 
	 */
	private String getNewName(String stringInput) {
		String newName = null;
		String[] splitString = stringInput.split("\""); 
		
		if (splitString.length > 1) {
			newName = splitString[1].trim(); 
		}
		if (newName != null) { 
			if (newName.compareTo("") == 0) {
				return null; 
			}
		}
		return newName; 
	}
	
	/**
	 * If the rawDate contains a time field, use PrettyTimeParser to
	 * parse the date
	 * @param rawDate
	 * @return epochTime (long) of rawDate
	 */
	private long getPrettyTime(String rawDate) {
		//use regex to check for time format
		if (timeChecker.hasTimeEdit(rawDate)) {
			//if the date contains any of the time words, call PrettyParser
			List<Date> processedTime = prettyParser.parse(rawDate); 
			if (!processedTime.isEmpty()) {
				return processedTime.get(0).getTime() / 1000; 
			} else {
				return -1; //unable to process 
			}
		}
		return -1; //no time indicated, or time is in the wrong format
	}

}
```
###### src\parser\ParseError.java
``` java
 * Purpose of this class is to parse "errors" for any 
 * wrong command formats/etc...
 * @author Xue Hui
 *
 */
public class ParseError extends ParseCommand {
	
	public ParseError() {
		super(); 
	}
}
```
###### src\parser\ParseFileLocation.java
``` java
 * Purpose of this class is to Parse a new directory location
 * for storing files in other locations. 
 * @author Xue Hui
 *
 */
public class ParseFileLocation extends ParseCommand {
	
	public ParseFileLocation() {
		super(); 
	}
	
	protected ProcessedObject processLoc(String rawInput) {
		assert(rawInput != null);
		
		String pathname = getFileName(rawInput); 
		ProcessedObject po = new ProcessedObject(ParserConstants.NEW_FILE_LOC);
		po.setNewFileLoc(pathname); 
		
		return po; 
	}
	
	/**
	 * Given a stringInput, remove the command from the string
	 * @param command
	 * @param stringInput
	 * @return taskName without command
	 */
	private String getFileName(String stringInput) {
		String command = stringInput.split(" ")[0]; 
		String task = stringInput.replaceFirst(command, "");
		
		return task.trim(); 
	}

}
```
###### src\parser\Parser.java
``` java
 * Logic can only call this class parse inputs from the user.
 * This Parser is a high level interface that acts as a facade
 * between the other parts of Parser. Commands parsed here make
 * use of the Command pattern as well. 
 * @author Xue Hui
 *
 */
public class Parser {	
	private ParseError parseError = new ParseError(); 
	private ParseAdd parseAdd = new ParseAdd(); 
	private ParseEdit parseEdit = new ParseEdit(); 
	private ParseUndo parseUndo = new ParseUndo();  
	private ParseSearch parseSearch = new ParseSearch(); 
	private ParseDelete parseDelete = new ParseDelete();
	private ParseDone parseDone = new ParseDone(); 
	private ParseFileLocation parseDir = new ParseFileLocation(); 
	private ParseSave parseSave = new ParseSave(); 
	private ParseClear parseClear = new ParseClear(); 
	
	private ParseView parseView = new ParseView();
	
	/**
	 * Constructor 
	 */
	public Parser() {
		TaskeyLog.getInstance().removeHandlers(LogSystems.PARSER);
		TaskeyLog.getInstance().addHandler(LogSystems.PARSER, "ParserLog.txt", 1);
		TaskeyLog.getInstance().log(LogSystems.PARSER, "Initialised Parser", Level.ALL);
	}	

	/**
	 * Process the user's command and execute it accordingly 
	 * @param command: string of command keyed in by user
	 * @return message to be displayed
	 */
	public ProcessedObject parseInput(String stringInput) {
		assert(stringInput != null);
		
		ProcessedObject processed = null;  
		String command = getCommand(stringInput); 
		
		switch(command) {
			//don't need to check date, just get "task"
			case "view":
				processed = parseView.processView(stringInput); 
				break; 
			case "del":
				processed = parseDelete.processDelete(stringInput); 
				break;
			case "setdir":
				processed = parseDir.processLoc(stringInput);
				break; 	
			case "save":
				processed = parseSave.processSave(command); 
				break;
			case "clear":
				processed = parseClear.processClear(command);
				break; 
				
			//need to check date: 
			case "add":
				processed = parseAdd.processAdd(command, stringInput); 
				break;
			case "set":
				processed = parseEdit.processSet(stringInput); 
				break;
			case "search":
				processed = parseSearch.processSearch(command, stringInput); 
				break;
			case "undo":
				processed = parseUndo.processUndo(command); 
				break; 
			case "done":
				processed = parseDone.processDone(stringInput);
				break; 
			default:
				//error goes here
				processed = parseError.processError(String.format(
						ParserConstants.ERROR_COMMAND, command)); 
				break; 
		}
		
		return processed;   
	}
	
	
	/**
	 * Returns command (first word) from a string that the user entered 
	 * @param stringInput
	 * @return command
	 */
	private String getCommand(String stringInput) {
		String[] splitString = stringInput.split(" ");
		String command = splitString[0].toLowerCase();
		
		return command;
	}
}
```
###### src\parser\ParseSave.java
``` java
 * Job of this class is to parse "save" commands. 
 * @author Xue Hui
 *
 */
public class ParseSave extends ParseCommand {

	public ParseSave() {
		super(); 
	}
	
	protected ProcessedObject processSave(String command) {
		assert(command != null); 
		
		return new ProcessedObject(command.toUpperCase()); 
	}
	
}
```
###### src\parser\ParseSearch.java
``` java
 * Purpose of this class is to parse the "search" command 
 * @author Xue Hui
 *
 */
public class ParseSearch extends ParseCommand {
	
	public ParseSearch() {
		super(); 
	}
	
	/**
	 * Return ProcessedObject for Search 
	 * @param command
	 * @param stringInput
	 * @return
	 */
	protected ProcessedObject processSearch(String command, String stringInput) {
		assert(stringInput != null);
		
		ProcessedObject processed = new ProcessedObject(command.toUpperCase()); 
		String searchPhrase = getTaskName(stringInput);
		
		if (searchPhrase.compareTo("") != 0) { 
			processed.setSearchPhrase(searchPhrase);
		} else {
			processed = super.processError(ParserConstants.ERROR_EMPTY_SEARCH); 
		}
		return processed; 
	}
	
	/**
	 * Given a stringInput, remove the command from the string
	 * @param command
	 * @param stringInput
	 * @return taskName without command
	 */
	private String getTaskName(String stringInput) {
		String command = stringInput.split(" ")[0]; 
		String task = stringInput.replaceFirst(command, "");
		
		return task.trim(); 
	}

}
```
###### src\parser\ParseUndo.java
``` java
 * Purpose is to parse the "undo" command 
 * @author Xue Hui
 *
 */
public class ParseUndo extends ParseCommand {
	
	public ParseUndo() {
		super(); 
	}

	/**
	 * Return ProcessedObject for Undo 
	 * @param command
	 * @return
	 */
	protected ProcessedObject processUndo(String command) {
		assert(command != null); 
		
		return new ProcessedObject(command.toUpperCase()); 
	}
}
```
###### src\parser\ParseView.java
``` java
 * Purpose of this class is to parse the "view" command 
 * Parse as: VIEW_BASIC and VIEW_TAGS
 * @author Xue Hui
 *
 */
public class ParseView extends ParseCommand {
	private HashMap<String,String> viewList = new HashMap<String,String>();

	public ParseView() {
		super(); 
		
		viewList.put("all", "all"); 
		viewList.put("general", "general");
		viewList.put("deadlines", "deadlines");
		viewList.put("events", "events"); 
		viewList.put("archive", "archive"); 
		viewList.put("help", "help"); 
		viewList.put("high", "high");
		viewList.put("medium", "medium"); 
		viewList.put("low", "low"); 
		viewList.put("today", "today");
		viewList.put("tomorrow", "tomorrow"); 
	}
	
	/**
	 * If the command is view, process what kind of view it is:
	 * 1. ALL
	 * 2. GENERAL
	 * 3. DEADLINES
	 * 4. EVENTS 
	 * 5. ARCHIVE
	 * 6. HELP 
	 * 7. #tags 
	 * 8. Priority: high, medium, low
	 * @param command
	 * @param stringInput
	 * @return processedStuff
	 */
	protected ProcessedObject processView(String stringInput) {
		assert(stringInput != null); 
		
		String stringWithoutCommand = getStringWithoutCommand(stringInput);
		
		//empty view
		if (stringWithoutCommand.compareTo("") == 0) {
			return super.processError(ParserConstants.ERROR_VIEW_EMPTY);
		}
		
		//note: let logic handle if the view exists or not.  
		return getView(stringWithoutCommand); 
	}
	
	/**
	 * @param command
	 * @param stringInput
	 * @return string without the "view" command attached to it. 
	 */
	private String getStringWithoutCommand(String stringInput) {
		String command = stringInput.split(" ")[0]; 
		return stringInput.replace(command, "").trim().toLowerCase();
	}
	
	/**
	 * Get all the categories that the user wants to view 
	 * @param command
	 * @param stringInput
	 * @return ProcessedObject of the processed VIEW
	 */
	private ProcessedObject getView(String stringInput) {
		ArrayList<String> views = new ArrayList<String>(); 
		String[] split = stringInput.split(" ");
		String category; 
		
		//if only one view 
		if (split.length == 1) {
			category = split[0].trim().toLowerCase();
			
			//check if it is a tagged view: Logic to handle if tag doesnt exist
			if (category.startsWith("#")) {
				views.add(category.replace("#", "").trim());
				return new ProcessedObject("VIEW_TAGS", views); 
			} else {
				if (viewList.containsKey(category)) {
					views.add(category);
					return new ProcessedObject("VIEW_BASIC", views);
				} else {
					//no such category 
					return super.processError(String.format(
							ParserConstants.ERROR_VIEW_TYPE, category));
				}
			}
		}
		
		//multiple views: only for hashtags 
		for(int i = 0; i < split.length; i++) {
			category = split[i].trim().toLowerCase(); 
			//tags view type
			if (category.startsWith("#")) {
				views.add(category.replace("#", "").trim());
			} else {
				return super.processError(String.format(
						ParserConstants.ERROR_VIEW_TYPE_TAG, category));
			}
		}
		return new ProcessedObject("VIEW_TAGS", views); 
	}
	
```
###### src\parser\SpecialDaysConverter.java
``` java
 * Purpose of this class is to convert date formats like
 * "tomorrow" or "next Wed" into forms that the Parser can process. 
 * Used by ParseAdd and ParseEdit
 * @author Xue Hui
 *
 */
public class SpecialDaysConverter {
	long currTime = -1;
	private HashMap<String,Long> specialDays = new HashMap<String,Long>();
	private TimeConverter timeConverter = new TimeConverter(); 
	private int toEndOfWeek = -1; //num. of days to the end of the current week.  
	
	public SpecialDaysConverter() { 
		try {
			String dateToday = timeConverter.getDate(timeConverter.getCurrTime());
			currTime = timeConverter.toEpochTime(dateToday); 
			 
			specialDays.put("tomorrow", 
					currTime + ParserConstants.ONE_DAY);
			specialDays.put("tmr", 
					currTime + ParserConstants.ONE_DAY); 
			specialDays.put("2day", currTime);
			specialDays.put("today", currTime);
			
			processDayOfTheWeek(); 
		} catch (ParseException e) {
			//do nothing
		} 
	}
	
	/**
	 * Returns the number of days to the end of the current week
	 * @return
	 */
	public int getToEndOfWeek() {
		return toEndOfWeek; 
	}
	
	/**
	 * Returns the HashMap specialDays
	 * @return
	 */
	public HashMap<String,Long> getSpecialDays() {
		return specialDays; 
	}
	
	/**
	 * Add corresponding day of the week to the specialDays HashMap,
	 * so that Parser can process human defined date formats like next friday
	 */
	public void processDayOfTheWeek() {
		Calendar cal = Calendar.getInstance();
		cal.set(timeConverter.getYear(currTime),
				timeConverter.getMonth(currTime)-1,
				timeConverter.getDay(currTime));
		int day = cal.get(cal.DAY_OF_WEEK); 
		
		
		switch (day) {
			case 1: //sun
				processSun(currTime); 
				break; 
			case 2: //mon
				processMon(currTime); 
				break; 
			case 3: //tue
				processTue(currTime);
				break; 
			case 4: //wed
				processWed(currTime);
				break; 
			case 5: //thu
				processThu(currTime);
				break; 
			case 6: //fri
				processFri(currTime);
				break; 
			case 7: //sat
				processSat(currTime);
				break; 
		}
		
	}
	
	/**
	 * Process days relative to today being friday
	 * @param currTime
	 */
	private void processFri(long currTime) {
		//toEndOfWeek = 2;
		
		specialDays.put("sun", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("mon", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("tue", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("wed", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("thu", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("fri", 
				currTime);
		specialDays.put("sat",
				currTime + ParserConstants.ONE_DAY);
		
		specialDays.put("sunday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("monday", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("tuesday", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("wednesday", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("thursday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("friday", 
				currTime);
		specialDays.put("saturday",
				currTime + ParserConstants.ONE_DAY);
		
		specialDays.put("tues", 
				currTime + ParserConstants.FOUR_DAYS);
		specialDays.put("thurs", 
				currTime + ParserConstants.SIX_DAYS);
		
		specialDays.put("this sun", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this mon", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this tue", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("this wed", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("this thu", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this fri", 
				currTime);
		specialDays.put("this sat",
				currTime + ParserConstants.ONE_DAY);
		
		specialDays.put("this sunday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this monday", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this tuesday", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("this wednesday", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("this thursday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this friday", 
				currTime);
		specialDays.put("this saturday",
				currTime + ParserConstants.ONE_DAY);
		
		specialDays.put("this thurs", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this tues", 
				currTime + ParserConstants.FOUR_DAYS); 
		
		specialDays.put("next sun", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next mon", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next tue", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next wed", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next thu", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next fri", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next sat",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY);
		
		specialDays.put("next sunday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next monday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next tuesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next wednesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next thursday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next friday", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next saturday",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY);
		
		specialDays.put("next tues", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next thurs", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
	}
	
	/**
	 * Process days relative to today being thursday
	 * @param currTime
	 */
	private void processThu(long currTime) {
		//toEndOfWeek = 3;
		
		specialDays.put("sun", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("mon", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("tue", 
				currTime +  ParserConstants.FIVE_DAYS); 
		specialDays.put("wed", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("thu", 
				currTime); 
		specialDays.put("fri", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("sat",
				currTime + ParserConstants.TWO_DAYS);
		
		specialDays.put("sunday", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("monday", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("tuesday", 
				currTime +  ParserConstants.FIVE_DAYS); 
		specialDays.put("wednesday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("thursday", 
				currTime); 
		specialDays.put("friday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("saturday",
				currTime + ParserConstants.TWO_DAYS);
		
		specialDays.put("tues", 
				currTime +  ParserConstants.FIVE_DAYS); 
		specialDays.put("thurs", 
				currTime); 
		
		specialDays.put("this sun", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this mon", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("this tue", 
				currTime +  ParserConstants.FIVE_DAYS); 
		specialDays.put("this wed", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this thu", 
				currTime); 
		specialDays.put("this fri", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this sat",
				currTime + ParserConstants.TWO_DAYS);
		
		specialDays.put("this sunday", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this monday", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("this tuesday", 
				currTime +  ParserConstants.FIVE_DAYS); 
		specialDays.put("this wednesday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this thursday", 
				currTime); 
		specialDays.put("this friday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this saturday",
				currTime + ParserConstants.TWO_DAYS);
		
		specialDays.put("this tues", 
				currTime +  ParserConstants.FIVE_DAYS);  
		specialDays.put("this thurs", 
				currTime); 
		
		
		specialDays.put("next sun", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next mon", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next tue", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next wed", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next thu", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next fri", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next sat",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS);
		
		specialDays.put("next sunday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next monday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next tuesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next wednesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next thursday", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next friday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next saturday",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS);
		
		specialDays.put("next tues", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next thurs", 
				currTime + ParserConstants.ONE_WEEK); 
	}
	
	/**
	 * Process days relative to today being wednesday
	 * @param currTime
	 */
	private void processWed(long currTime) {
		//toEndOfWeek = 4;
		
		specialDays.put("sun", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("mon", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("tue", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("wed", 
				currTime); 
		specialDays.put("thu", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("fri", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("sat",
				currTime + ParserConstants.THREE_DAYS);
		
		specialDays.put("sunday", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("monday", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("tuesday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("wednesday", 
				currTime); 
		specialDays.put("thursday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("friday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("saturday",
				currTime + ParserConstants.THREE_DAYS);
		
		specialDays.put("tues", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("thurs", 
				currTime + ParserConstants.ONE_DAY); 
		
		specialDays.put("this sun", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("this mon", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("this tue", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this wed", 
				currTime); 
		specialDays.put("this thu", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this fri", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this sat",
				currTime + ParserConstants.THREE_DAYS);
		
		specialDays.put("this sunday", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("this monday", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("this tuesday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this wednesday", 
				currTime); 
		specialDays.put("this thursday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this friday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this saturday",
				currTime + ParserConstants.THREE_DAYS);
		
		specialDays.put("this tues", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this thurs", 
				currTime + ParserConstants.ONE_DAY); 
		
		specialDays.put("next sun", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next mon", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next tue", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next wed", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next thu", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next fri", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next sat",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS);
		
		specialDays.put("next sunday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next monday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next tueday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next wednesday", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next thursday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next friday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next saturday",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS);
		
		specialDays.put("next tues", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next thurs", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
	}

	/**
	 * Process days relative to today being tuesday
	 * @param currTime
	 */
	private void processTue(long currTime) {
		//toEndOfWeek = 5;
		
		specialDays.put("sun", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("mon", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("tue", 
				currTime); 
		specialDays.put("wed", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("thu", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("fri", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("sat",
				currTime + ParserConstants.FOUR_DAYS);
		
		specialDays.put("sunday", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("monday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("tuesday", 
				currTime); 
		specialDays.put("wednesday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("thursday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("friday", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("saturday",
				currTime + ParserConstants.FOUR_DAYS);
		
		specialDays.put("tues", 
				currTime); 
		specialDays.put("thurs", 
				currTime + ParserConstants.TWO_DAYS); 
		
		specialDays.put("this sun", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("this mon", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this tue", 
				currTime); 
		specialDays.put("this wed", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this thu", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this fri", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this sat",
				currTime + ParserConstants.FOUR_DAYS);
		
		specialDays.put("this sunday", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("this monday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this tuesday", 
				currTime); 
		specialDays.put("this wednesday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this thursday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this friday", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this saturday",
				currTime + ParserConstants.FOUR_DAYS);
		
		specialDays.put("this tues", 
				currTime); 
		specialDays.put("this thurs", 
				currTime + ParserConstants.TWO_DAYS); 
		
		specialDays.put("next sun", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next mon", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next tue", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next wed", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next thu", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next fri", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next sat",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS);
		
		specialDays.put("next sunday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next monday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next tuesday", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next wednesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next thursday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next friday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next saturday",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS);
		
		specialDays.put("next tues", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next thurs", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
	}

	/**
	 * Process days relative to today being monday
	 * @param currTime
	 */
	private void processMon(long currTime) {
		//toEndOfWeek = 6;
		
		specialDays.put("sun", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("mon", 
				currTime);
		specialDays.put("tue", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("wed", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("thu", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("fri", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("sat",
				currTime + ParserConstants.FIVE_DAYS); 
		
		specialDays.put("sunday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("monday", 
				currTime);
		specialDays.put("tuesday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("wednesday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("thursday", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("friday", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("saturday",
				currTime + ParserConstants.FIVE_DAYS);
		
		specialDays.put("tues", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("thurs", 
				currTime + ParserConstants.THREE_DAYS);
		
		specialDays.put("this sun", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this mon", 
				currTime);
		specialDays.put("this tue", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this wed", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this thu", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this fri", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("this sat",
				currTime + ParserConstants.FIVE_DAYS); 
		
		specialDays.put("this sunday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this monday", 
				currTime);
		specialDays.put("this tuesday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this wednesday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this thursday", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this friday", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("this saturday",
				currTime + ParserConstants.FIVE_DAYS); 
		
		specialDays.put("this tues", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this thurs", 
				currTime + ParserConstants.THREE_DAYS); 
		
		specialDays.put("next sun", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next mon", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next tue", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next wed", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next thu", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next fri", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next sat",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS);
		
		specialDays.put("next sunday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next monday", 
				currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next tuesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next wednesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next thursday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next friday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next saturday",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS);
		
		specialDays.put("next tues", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next thurs", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
	}
	
	/**
	 * Process days relative to today being sunday
	 * @param currTime
	 */
	private void processSun(long currTime) {
		//toEndOfWeek = 7;
		
		specialDays.put("mon", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("tue", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("wed", 
				currTime  + ParserConstants.THREE_DAYS); 
		specialDays.put("thu", 
				currTime  + ParserConstants.FOUR_DAYS); 
		specialDays.put("fri", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("sat",
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("sun",
				currTime);
		
		specialDays.put("monday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("tuesday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("wednesday", 
				currTime  + ParserConstants.THREE_DAYS); 
		specialDays.put("thursday", 
				currTime  + ParserConstants.FOUR_DAYS); 
		specialDays.put("friday", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("saturday",
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("sunday",
				currTime);
		
		specialDays.put("tues", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("thurs", 
				currTime  + ParserConstants.FOUR_DAYS);
		
		specialDays.put("this mon", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this tue", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this wed", 
				currTime  + ParserConstants.THREE_DAYS); 
		specialDays.put("this thu", 
				currTime  + ParserConstants.FOUR_DAYS); 
		specialDays.put("this fri", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("this sat",
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this sun",
				currTime);
		
		specialDays.put("this monday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this tuesday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this wednesday", 
				currTime  + ParserConstants.THREE_DAYS); 
		specialDays.put("this thursday", 
				currTime  + ParserConstants.FOUR_DAYS); 
		specialDays.put("this friday", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("this saturday",
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this sunday",
				currTime);
		
		specialDays.put("this tues", 
				currTime + ParserConstants.TWO_DAYS);  
		specialDays.put("this thurs", 
				currTime  + ParserConstants.FOUR_DAYS); 
		
		specialDays.put("next sun", currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next mon", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY ); 
		specialDays.put("next tue", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next wed", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next thu", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next fri", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next sat",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS);
		
		specialDays.put("next sunday", currTime + ParserConstants.ONE_WEEK); 
		specialDays.put("next monday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY ); 
		specialDays.put("next tuesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next wednesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next thursday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next friday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next saturday",
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS);
		
		specialDays.put("next tues", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS);  
		specialDays.put("next thurs", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
	}

	/**
	 * Process days relative to today being saturday
	 * @param currTime
	 */
	private void processSat(long currTime) {
		//toEndOfWeek = 0;
		
		specialDays.put("sun", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("mon", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("tue", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("wed", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("thu", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("fri", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("sat", 
				currTime);
		
		specialDays.put("sunday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("monday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("tuesday", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("wednesday", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("thursday", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("friday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("saturday", 
				currTime);
		
		specialDays.put("tues", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("thurs", 
				currTime + ParserConstants.FIVE_DAYS); 
		
		specialDays.put("this sun", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this mon", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this tue", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this wed", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("this thu", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("this fri", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this sat", 
				currTime);
		
		specialDays.put("this sunday", 
				currTime + ParserConstants.ONE_DAY); 
		specialDays.put("this monday", 
				currTime + ParserConstants.TWO_DAYS); 
		specialDays.put("this tuesday", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this wednesday", 
				currTime + ParserConstants.FOUR_DAYS); 
		specialDays.put("this thursday", 
				currTime + ParserConstants.FIVE_DAYS); 
		specialDays.put("this friday", 
				currTime + ParserConstants.SIX_DAYS); 
		specialDays.put("this saturday", 
				currTime);
		
		specialDays.put("this tues", 
				currTime + ParserConstants.THREE_DAYS); 
		specialDays.put("this thurs", 
				currTime + ParserConstants.FIVE_DAYS); 
		
		specialDays.put("next sun", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next mon", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next tue", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next wed", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next thu", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next fri", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next sat",
				currTime + ParserConstants.ONE_WEEK);
		
		specialDays.put("next sunday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.ONE_DAY); 
		specialDays.put("next monday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.TWO_DAYS); 
		specialDays.put("next tuesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next wednesday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FOUR_DAYS); 
		specialDays.put("next thursday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
		specialDays.put("next friday", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.SIX_DAYS); 
		specialDays.put("next saturday",
				currTime + ParserConstants.ONE_WEEK);
		
		specialDays.put("next tues", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.THREE_DAYS); 
		specialDays.put("next thurs", 
				currTime + ParserConstants.ONE_WEEK + ParserConstants.FIVE_DAYS); 
	}
}
```
###### src\parser\TimeConverter.java
``` java
 * The purpose of this class is to convert time anywhere in taskey. 
 * @author Xue Hui
 *
 */
public class TimeConverter {
	
	//store curr time in seconds 
	private long currTime = System.currentTimeMillis()/1000;
	//======================================================
	
	/**
	 * Constructor 
	 */
	public TimeConverter() {
		
	}
	
	/**
	 * @return the value of the variable, currTime. 
	 * Update the currTime every time this is called.
	 */
	public long getCurrTime() {
		currTime = System.currentTimeMillis()/1000;
		return currTime; 
	}	
	
	/**
	 * Method to update currentTime in this class. 
	 */
	public void setCurrTime() {
		currTime = System.currentTimeMillis()/1000;
	}
	
	/**
	 * Convert a properly formatted date to its Epoch Format
	 * @param date: String in the format: dd MMM yyyy HH:mm:ss
	 * @return date in Epoch Time. 
	 */
	public long toEpochTime(String date) throws ParseException { 
		try {
			SimpleDateFormat format = new java.text.SimpleDateFormat("dd MMM yyyy HH:mm:ss");
			format.setLenient(false); //disallow >=3 numbers for dd <-day of month
			long epochTime = format.parse(date).getTime() / 1000;
			return epochTime; 
		} catch (ParseException e) {
			try {
				//date came in dd MMM yyyy
				SimpleDateFormat format2 = new java.text.SimpleDateFormat("dd MMM yyyy HH:mm:ss");
				format2.setLenient(false);
				String date2 = date + " " + ParserConstants.DAY_END; 
				long epochTime = format2.parse(date2).getTime() / 1000;
				return epochTime; 
			} catch (ParseException e2) {
				try {
					SimpleDateFormat format3 = new java.text.SimpleDateFormat("dd MMM yyyy HH:mm:ss");
					format3.setLenient(false);
					String date3 = date + " 2016 " + ParserConstants.DAY_END; 
					long epochTime = format3.parse(date3).getTime() / 1000;
					return epochTime; 
				} catch (ParseException e3) {
					//System.out.println(e3); 
					throw e3; 
				}
			}
		}	
	}
	
	
	/**
	 * Convert an epoch time to human readable time. 
	 * @param epochTime: a long number that you want to convert to human readable format
	 * @return String: human readable time 
	 */
	public String toHumanTime(long epochTime) {
		String humanTime = new java.text.SimpleDateFormat("dd MMM yyyy HH:mm").format(
				new java.util.Date(epochTime*1000));

		return humanTime; 
	}
	
	/**
	 * Checks if 2 given times in Epoch Format are in the same day
	 * @param epochTime1
	 * @param epochTime2
	 * @return true if they are in the same day 
	 */
	public boolean isSameDay(long epochTime1, long epochTime2) {
		int yearDiff = Math.abs(getYear(epochTime1) - getYear(epochTime2)); 
		int monthDiff = Math.abs(getMonth(epochTime1) - getMonth(epochTime2));
		int dayDiff = Math.abs(getDay(epochTime1) - getDay(epochTime2));
		
		if (yearDiff == 0) {
			if (monthDiff == 0) {
				if (dayDiff == 0) {
					return true;
				}
			}
		} 
		return false; 
	}
	
	/**
	 * Checks if the task falls on today
	 * @param epochTime
	 * @return true if the task deadline/event is today 
	 */
	public boolean isToday(long epochTime) {
		long dateToday = getCurrTime(); 
		int yearDiff = Math.abs(getYear(epochTime) - getYear(dateToday)); 
		int monthDiff = Math.abs(getMonth(epochTime) - getMonth(dateToday));
		int dayDiff = Math.abs(getDay(epochTime) - getDay(dateToday));
		
		if (yearDiff == 0) {
			if (monthDiff == 0) {
				if (dayDiff == 0) {
					return true;
				}
			}
		} 
		return false; 
	}
	
	/**
	 * Checks if the task falls on tomorrow
	 * @param epochTime
	 * @return true if the task deadline/event is tomorrow 
	 */
	public boolean isTmr(long epochTime) {
		long dateToday = getCurrTime(); 
		int yearDiff = Math.abs(getYear(epochTime) - getYear(dateToday)); 
		int monthDiff = Math.abs(getMonth(epochTime) - getMonth(dateToday));
		int dayDiff = Math.abs(getDay(epochTime) - getDay(dateToday));
		
		if (yearDiff == 0) {
			if (monthDiff == 0) {
				if (dayDiff == 1) {
					return true;
				}
			}
		} 
		return false; 
	}
	
	/**
	 * Checks if 2 given times in Epoch Format are in the same week
	 * @param epochTime1
	 * @param epochTime2
	 * @return true if they are in the same week 
	 */
	public boolean isSameWeek(long epochTime1, long epochTime2) {
		Calendar c1 = Calendar.getInstance();
		c1.setFirstDayOfWeek(Calendar.MONDAY);
		c1.set(getYear(epochTime1),
				getMonth(epochTime1)-1,
				getDay(epochTime1));
		int year1 = c1.get(c1.YEAR);
		int week1 = c1.get(c1.WEEK_OF_YEAR);

		Calendar c2 = Calendar.getInstance();
		c2.setFirstDayOfWeek(Calendar.MONDAY);
		c2.set(getYear(epochTime2),
				getMonth(epochTime2)-1,
				getDay(epochTime2));
		int year2 = c2.get(c2.YEAR);
		int week2 = c2.get(c2.WEEK_OF_YEAR);

		if(year1 == year2){
		       if (week1 == week2) {
		         return true; 
		       }
		    }
		return false; 
	}
	
	/**
	 * @param epochTime
	 * @return Year as an integer 
	 */
	public int getYear(long epochTime) {
		String year = new java.text.SimpleDateFormat("yyyy").format(
				new java.util.Date(epochTime*1000));
		
		return Integer.parseInt(year); 
	}
	
	/**
	 * @param epochTime
	 * @return Month as an integer (1-12) 
	 */
	public int getMonth(long epochTime) {
		String month = new java.text.SimpleDateFormat("MM").format(
				new java.util.Date(epochTime*1000));
		
		return Integer.parseInt(month); 
	}
	
	/**
	 * @param epochTime
	 * @return day as an integer (0-31) 
	 */
	public int getDay(long epochTime) {
		String day = new java.text.SimpleDateFormat("dd").format(
				new java.util.Date(epochTime*1000));
		
		return Integer.parseInt(day); 
	}
	
	/**
	 * @return an ArrayList of 3 months starting from the current time
	 */
	public ArrayList<String> get3MonthsFromNow() {
		ArrayList<String> months = new ArrayList<String>();
		
		int currMonth = getMonth(getCurrTime()); 
		
		switch (currMonth) {
			case 1:
				months.add("jan");
				months.add("feb");
				months.add("mar"); 
				break; 
			case 2:
				months.add("feb");
				months.add("mar");
				months.add("apr"); 
				break; 
			case 3:
				months.add("mar");
				months.add("apr");
				months.add("may"); 
				break; 
			case 4:
				months.add("apr");
				months.add("may");
				months.add("jun"); 
				break; 
			case 5:
				months.add("may");
				months.add("jun");
				months.add("jul"); 
				break; 
			case 6:
				months.add("jun");
				months.add("jul");
				months.add("aug"); 
				break; 
			case 7:
				months.add("jul");
				months.add("aug");
				months.add("sep"); 
				break; 
			case 8:
				months.add("aug");
				months.add("sep");
				months.add("oct"); 
				break; 
			case 9:
				months.add("sep");
				months.add("oct");
				months.add("nov"); 
				break; 
			case 10:
				months.add("oct");
				months.add("nov");
				months.add("dec"); 
				break; 
			case 11:
				months.add("nov");
				months.add("dec");
				break; 
			case 12:
				months.add("dec"); 
				break; 
		}
		
		return months; 
	}
	
	/**
	 * converts an epoch time to date, without the hours:mins:seconds inside
	 * @param epochTime
	 * @return string format for date
	 */
	public String getDate(long epochTime) {
		String date = new java.text.SimpleDateFormat("dd MMM yyyy").format(
				new java.util.Date(epochTime*1000));
		
		return date; 
	}
	
	/**
	 * converts an epoch time to only HH:mm (hour and minute) of the day, 
	 * without the date.
	 * @param epochTime
	 * @return
	 */
	public String getTime(long epochTime) {
		String time = new java.text.SimpleDateFormat("HH:mm").format(
				new java.util.Date(epochTime*1000));
		
		return time;
	}
	
	/**
	 * Get human format day of the week.
	 * No params: get today's day
	 * eg. mon, tues... 
	 * @return
	 */
	public String getDayOfTheWeek() {
		//first day of the week starts from Sunday 
		String[] days = {"SUN","MON","TUE","WED","THU","FRI","SAT"}; 
		Calendar cal = Calendar.getInstance();
		cal.set(getYear(currTime),
				getMonth(currTime)-1,
				getDay(currTime));
		int day = cal.get(cal.DAY_OF_WEEK); 
		
		return days[day-1]; 
	}
	
	/**
	 * Get human format day of the week.
	 * with an epoch time: get that epochTime's day
	 * eg. mon, tues... 
	 * @return
	 */
	public String getDayOfTheWeek(long epochTime) {
		//first day of the week starts from Sunday 
		String[] days = {"SUN","MON","TUE","WED","THU","FRI","SAT"}; 
		Calendar cal = Calendar.getInstance();
		cal.set(getYear(epochTime),
				getMonth(epochTime)-1,
				getDay(epochTime));
		int day = cal.get(cal.DAY_OF_WEEK); 
		
		return days[day-1]; 
	}
}
```
###### test\junit\AutoCompleteTest.java
``` java
 * Tests the AutoComplete class
 * Type of test: Component Test 
 * @author Xue Hui
 *
 */
public class AutoCompleteTest {
	AutoComplete ac = new AutoComplete(); 
	ArrayList<TagCategory> tagDB = new ArrayList<TagCategory>(); 
	
	@Before
	public void setUp() {
		tagDB.add(new TagCategory("lala"));
		tagDB.add(new TagCategory("yolo"));
		tagDB.add(new TagCategory("hahaha"));
	}
	
	@Test
	/**
	 * Check that correcting wrong spellings for months
	 * gives the correct suggestions 
	 */
	public void testSpellChecker() {
		String[] months = {"feb","mar","apr"}; 
		ArrayList<String> correction = ac.correctDateError("fbr"); 
		
		assertEquals(months.length, correction.size()); 
		
		for(int i = 0; i < months.length; i++) {
			assertEquals(months[i], correction.get(i)); 
		}
	}
	
	@Test
	public void testCommandSuggestions() {
		assertEquals("Command: DISPLAY_COMMAND\nOptions: view, \n",
				ac.getSuggestions("biw",tagDB).toString());
		assertEquals("Command: DISPLAY_COMMAND\nOptions: add, \n",
				ac.getSuggestions("a", tagDB).toString()); 
	}
	
	@Test
	/**
	 * Test Suggestions for View
	 */
	public void testViewSuggestions() {
		assertEquals("Command: DISPLAY_COMMAND\nOptions: #lala, #yolo, #hahaha, \n",
				ac.getSuggestions("view #", tagDB).toString());
		assertEquals("Command: DISPLAY_COMMAND\nOptions: general, \n",
				ac.getSuggestions("view g", tagDB).toString());
		
		assertEquals("Command: NO_SUCH_COMMAND\n\n",
				ac.getSuggestions("view aadadsdaer", tagDB).toString());
	}
	
	@Test
	/**
	 * Test suggestions for Add
	 */
	public void testAddSuggestions() {
		assertEquals("Command: DISPLAY_COMMAND\nOptions: tmr, 8pm, next mon, \n",
				ac.getSuggestions("add sth by", tagDB).toString());
		assertEquals("Command: FINISHED_COMMAND\n\n",
				ac.getSuggestions("add my task", tagDB).toString());
		assertEquals("Command: DISPLAY_COMMAND\nOptions: 18 apr, 18 may, 18 jun, \n",
				ac.getSuggestions("add sth by 18", tagDB).toString());
		assertEquals("Command: FINISHED_COMMAND\n\n",
				ac.getSuggestions("add sth by the park", tagDB).toString());
		assertEquals("Command: DISPLAY_COMMAND\nOptions: 1800h, \n",
				ac.getSuggestions("add sth by 1800", tagDB).toString());
		assertEquals("Command: DISPLAY_COMMAND\nOptions: #lala, #yolo, #hahaha, \n",
				ac.getSuggestions("add sth #", tagDB).toString());
		assertEquals("Command: DISPLAY_COMMAND\nOptions: #yolo, \n",
				ac.getSuggestions("add sth #y", tagDB).toString());
		assertEquals("Command: FINISHED_COMMAND\n\n",
				ac.getSuggestions("add sth #babablack", tagDB).toString());
	}
	
	@Test
	/**
	 * Test the Add spelling corrector for months
	 */
	public void testAddSpellingCorrector() {
		//test spelling corrector
		assertEquals("Command: DISPLAY_COMMAND\nOptions: feb, mar, apr, \n",
				ac.getSuggestions("add task by 17 fbr", tagDB).toString());
	}
	
	@Test
	/**
	 * Test suggestions for Set
	 */
	public void testEditSuggestions() {
		assertEquals("Command: DISPLAY_COMMAND\nOptions: \"New Task Name\", [New Date], !!, \n",
				ac.getSuggestions("set 1 ", tagDB).toString());
		assertEquals("Command: DISPLAY_COMMAND\nOptions: tomorrow, \n",
				ac.getSuggestions("set 1 [", tagDB).toString());
		
		assertEquals("Command: DISPLAY_COMMAND\nOptions: 1800h, \n",
				ac.getSuggestions("set 1 [1800", tagDB).toString());
		
		assertEquals("Command: DISPLAY_COMMAND\nOptions: tomorrow, \n",
				ac.getSuggestions("set 1 [9pm ", tagDB).toString()); 
		
		
		
		assertEquals("Command: DISPLAY_COMMAND\nOptions: 19 apr, 19 may, 19 jun, \n",
				ac.getSuggestions("set 1 [18 may, 19", tagDB).toString());
		
		assertEquals("Command: FINISHED_COMMAND\n\n",
				ac.getSuggestions("set 1 [18 may", tagDB).toString());
		
		assertEquals("Command: FINISHED_COMMAND\n\n",
				ac.getSuggestions("set 1 \"sth\"", tagDB).toString());
	}
	
	@Test
	/**
	 * Test changing of task priority suggestions
	 */
	public void testEditPrioritySuggestions() {
		assertEquals("Command: DISPLAY_COMMAND\nOptions: !, !!, !!!, \n",
				ac.getSuggestions("set 1 !", tagDB).toString());
		assertEquals("Command: DISPLAY_COMMAND\nOptions: !!, !!!, \n",
				ac.getSuggestions("set 1 !!", tagDB).toString());
		assertEquals("Command: FINISHED_COMMAND\n\n",
				ac.getSuggestions("set 1 !!!", tagDB).toString());
		assertEquals("Command: NO_SUCH_COMMAND\n\n",
				ac.getSuggestions("set 1 !!!!!", tagDB).toString());
	}
	
	@Test
	/**
	 * Test suggestions for other commands
	 */
	public void testOtherCommandSuggestions() {
		assertEquals("Command: FINISHED_COMMAND\n\n",
				ac.getSuggestions("clear", tagDB).toString());
	}
	
	@Test
	/**
	 * Test suggestions for unavailable commands 
	 */
	public void testNoSuchCommand() {
		assertEquals("Command: NO_SUCH_COMMAND\n\n",
				ac.getSuggestions("finderrrrrr ", tagDB).toString());
		assertEquals("Command: NO_SUCH_COMMAND\n\n",
				ac.getSuggestions("finderrrr 1", tagDB).toString());
	}
	
	/*
	 * Manual Testing: Human Times
	 */
	
	@Test
	/**
	 * Test human time suggestions for set 
	 */
	public void testEditSuggestionsHuman() {
		System.out.println(ac.getSuggestions("set 1 [9pm 18", tagDB).toString()); 
		System.out.println(ac.getSuggestions("set 1 [18", tagDB).toString());
	}
}
```
###### test\junit\ParserTest.java
``` java
 * This class tests all the functionality of Parser to ensure 
 * it is returning the correct objects. 
 * Type of test: Component Test 
 * @author Xue Hui
 *
 */
public class ParserTest {
	Parser parser = new Parser();
	PrettyTimeParser p = new PrettyTimeParser();
	
	@Test
	/**
	 * Test that adding floating tasks get parsed correctly 
	 */
	public void testFloating() {		
		assertEquals("Command: ADD_FLOATING\nDo homework, FLOATING, \n",
				parser.parseInput("add do homework").toString());
		
		assertEquals("Command: ADD_FLOATING\nMEETING2, FLOATING, \n",
				parser.parseInput("ADD MEETING2").toString());
	}
	
	@Test
	/**
	 * Test floating tasks that do not parse correctly 
	 */
	public void testFloatingError() {		
		//disallow task names with only numbers 
		assertEquals("Command: ERROR\nerror type: Error: Task name cannot consist "
				+ "entirely of numbers\n",
				parser.parseInput("add 2345").toString());
		//disallow empty adds 
		assertEquals("Command: ERROR\nerror type: Error: Cannot be an empty add\n",
				parser.parseInput("add ").toString());
		assertEquals("Command: ERROR\nerror type: Error: Cannot be an empty add\n",
				parser.parseInput("add !!").toString());
		//invalid priority 
		assertEquals("Command: ERROR\nerror type: Error: Invalid task priority entered\n",
				parser.parseInput("add mtg !!!!!").toString());
		//test that adding a place to the task doesn't get detected as time
		//because of the keywords "by" and "on" 
		assertEquals("Command: ADD_FLOATING\nDo work by the park, FLOATING, \n",
				parser.parseInput("add do work by the park").toString());
	}
	
	@Test
	/**
	 * Test that adding deadline tasks gets parsed correctly 
	 */
	public void testDeadline() {
		assertEquals("Command: ADD_DEADLINE\nProject meeting, DEADLINE, "
				+ "due on 17 Feb 2016 15:00\n",
				parser.parseInput("add project meeting at 3pm on 17 Feb 2016").toString());
			 
		assertEquals("Command: ADD_DEADLINE\nProject meeting, DEADLINE, "
				+ "due on 17 Feb 2016 15:00\n",
				parser.parseInput("add project meeting by 17 feb 2016 3pm").toString());
		 
		assertEquals("Command: ADD_DEADLINE\nProject meeting, DEADLINE, "
				+ "due on 17 Feb 2016 15:00\n",
				parser.parseInput("add project meeting at 3pm on 17 Feb").toString());
		
		assertEquals("Command: ADD_DEADLINE\nDo work, DEADLINE, due on 17 Feb 2016 15:00\n",
				parser.parseInput("add do work at 17 feb 3pm").toString());
	}
	
	@Test
	/**
	 * Test that adding deadline tasks don't give strange results for 
	 * error cases, so on... 
	 */
	public void testDeadlineError() {
		//ensure that words with "by" and "on" in it split correctly
		//ie. make sure that the correct keywords are detected. 
		assertEquals("Command: ADD_DEADLINE\nSing lullaby, DEADLINE, due on 11 Mar 2016\n",
				parser.parseInput("add sing lullaby on 11 mar").toString());
		assertEquals("Command: ADD_DEADLINE\nBuy baygon, DEADLINE, due on 11 Mar 2016\n",
				parser.parseInput("add buy baygon on 11 mar").toString());
		//ensure that numbers in meeting name do not affect date output
		assertEquals("Command: ADD_DEADLINE\nMeeting 222, DEADLINE, due on 17 "
				+ "Feb 2016\n",
				parser.parseInput("add meeting 222 on 17 Feb").toString());
	}
	
	@Test
	/**
	 * Check that grammatically incorrect dates get caught before 
	 * PrettyTime returns the wrong date 
	 */
	public void testDeadlineGrammar() {
		assertEquals("Command: ERROR\nerror type: Error: \"by 3pm on 17 Feb 2016\" is "
				+ "a grammatically incorrect date\n",
				parser.parseInput("add project meeting by 3pm on 17 Feb 2016").toString());
	}
	
	@Test
	/**
	 * Test that adding events get parsed correctly. 
	 */
	public void testEvents() {
		assertEquals("Command: ADD_EVENT\nMeeting, EVENT, from 19 Feb 2016 "
				+ "to 20 Feb 2016\n",
				parser.parseInput("add meeting from 19 Feb 2016 to 20 Feb 2016").toString());
		assertEquals("Command: ADD_EVENT\nMeeting, EVENT, from 19 Feb 2016 "
				+ "to 20 Feb 2016\n",
				parser.parseInput("add meeting from 19 Feb to 20 Feb").toString());	
		
		assertEquals("Command: ADD_EVENT\nMeeting, EVENT, from 19 Feb 2016 15:00 "
				+ "to 19 Feb 2016 16:00\n",
				parser.parseInput("add meeting from 19 feb 3pm to 19 feb 4pm").toString());
		
		assertEquals("Command: ADD_EVENT\nMeeting, EVENT, from 19 Feb 2016 15:00 "
				+ "to 19 Feb 2016 16:00\n",
				parser.parseInput("add meeting from 19 feb 3pm to 4pm").toString());
		
		assertEquals("Command: ADD_EVENT\nProject meeting, EVENT, from 19 Feb 2016 "
				+ "16:00 to 19 Feb 2016 17:00\n",
				parser.parseInput("add project meeting from 4pm to "
						+ "5pm on 19 feb").toString());
	}
	
	@Test 
	/**
	 * Test that events with numbers in their task names get parsed correctly 
	 */
	public void testEventsNumbers() {
		//test events with numbers in task name 
		assertEquals("Command: ADD_EVENT\nMtg2234, EVENT, from 19 Feb 2016 16:00"
				+ " to 19 Feb 2016 17:00\n",
				parser.parseInput("add mtg2234 from 19 feb 4pm to 5pm ").toString());
		//System.out.println(p.parse(" from 4pm to 5pm on 19 feb"));
	}
	
	@Test 
	/**
	 *  Test that for adding events: startTime >= endTime gives error 
	 */
	public void testEventsValidTime() {
		assertEquals("Command: ERROR\nerror type: Error: Event starting time cannot be"
				+ " later than the ending time\n",
				parser.parseInput("add mtg from 19 feb 5pm to 3pm").toString());
		assertEquals("Command: ERROR\nerror type: Error: Event starting time cannot be"
				+ " later than the ending time\n",
				parser.parseInput("add mtg from 21 feb to 20 feb").toString());
		assertEquals("Command: ERROR\nerror type: Error: Event starting time cannot be"
				+ " later than the ending time\n",
				parser.parseInput("add mtg from tmr to 18 feb 3pm").toString());
	}
	
	@Test
	/**
	 * Test that tagging gets parsed correctly 
	 */
	public void testTag() {
		assertEquals("Command: ADD_FLOATING\nMeeting, FLOATING, \ntags: sua, serious, \n",
				parser.parseInput("add meeting #sua #serious").toString());
		assertEquals("Command: ERROR\nerror type: Error: Cannot be an empty add\n",
				parser.parseInput("add  ").toString());
		assertEquals("Command: ADD_DEADLINE\nMeeting, DEADLINE, due on 17 Feb 2016\n"
				+ "tags: sua, serious, \n",
				parser.parseInput("add meeting on 17 Feb #sua #serious").toString());
		assertEquals("Command: ERROR\nerror type: Error: \"17 Fbr\" is not an "
				+ "accepted date format\n",
				parser.parseInput("add meeting on 17 Fbr #sua #serious").toString());
		assertEquals("Command: ERROR\nerror type: Error: \"17 Fbr 2016\" is not "
				+ "an accepted date format\n",
				parser.parseInput("add meeting on 17 Fbr 2016 #sua #serious").toString());
		assertEquals("Command: ADD_EVENT\nMeeting, EVENT, from 17 Feb 2016 "
				+ "to 18 Feb 2016\ntags: sua, serious, \n",
				parser.parseInput("add meeting from 17 Feb to 18 Feb #sua #serious").toString());
		
	}
	
	@Test
	/**
	 * Test invalid tags for adding 
	 */
	public void testTagInvalid() {
		//adding the same tag multiple times
		assertEquals("Command: ERROR\nerror type: Error: Invalid tags added to the task\n",
				parser.parseInput("add meeting #work #work #work").toString());
		//adding deadlines/general/all/events: invalid categories cos these are default categories
		assertEquals("Command: ERROR\nerror type: Error: Invalid tags added to the task\n",
				parser.parseInput("add meeting #work #general #deadline").toString());
	}
	
	@Test
	/**
	 * Test the adding of tasks with priority 
	 */
	public void testAddPriority() {
		//test setting of priority here 
		assertEquals("Command: ADD_FLOATING\nMeeting, FLOATING, \n",
				parser.parseInput("add meeting !").toString());
		assertEquals("Command: ADD_DEADLINE\nMeeting, DEADLINE, due on 18 Feb 2016\npriority: 3\n",
				parser.parseInput("add meeting on 18 feb !!!").toString());
		assertEquals("Command: ADD_EVENT\nMeeting, EVENT, from 18 Feb 2016 to 19 Feb 2016\n"
				+ "priority: 2\n",
				parser.parseInput("add meeting from 18 feb to 19 feb !!").toString());
		assertEquals("Command: ADD_EVENT\nMeeting, EVENT, from 18 Feb 2016 to 19 Feb 2016\n"
				+ "tags: boo, \npriority: 2\n",
				parser.parseInput("add meeting from 18 feb to 19 feb #boo !!").toString());
		assertEquals("Command: ADD_FLOATING\nMeeting, FLOATING, \ntags: sua, \npriority: 2\n",
				parser.parseInput("add meeting #sua !!").toString());
	}
	
	@Test
	/**
	 * Test adding of tasks with wrong priority 
	 */
	public void testAddWrongPriority() {
		assertEquals("Command: ERROR\nerror type: Error: Invalid task priority entered\n",
				parser.parseInput("add test !!!!!").toString());
	}
	
	@Test 
	/**
	 * Test setting of changes via using task index
	 */
	public void testChangesById() {
		//set <task name>/<id> "new task name" 
		//by task id
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_NAME\nat index: 0\n"
				+ "new TaskName: urgent meeting\n",
				parser.parseInput("set 1 \"urgent meeting\"").toString());
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_DATE\nFLOATING, \nat index: 1\n",
				parser.parseInput("set 2 [none]").toString());
		assertEquals("Command: ERROR\nerror type: Error: Wrong format for new task name/date\n",
				parser.parseInput("set 2 []").toString());
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_DATE\nDEADLINE, "
				+ "due on 17 Feb 2016\nat index: 1\n",
				parser.parseInput("set 2 [17 feb]").toString());
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_DATE\nEVENT, from 16 Feb 2016 "
				+ "to 17 Feb 2016\nat index: 1\n",
				parser.parseInput("set 2 [16 feb, 17 Feb]").toString());
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_DATE\nEVENT, from 16 Feb 2016 "
				+ "to 17 Feb 2016\nat index: 1\n",
				parser.parseInput("set 2 [16 feb,17 Feb]").toString());
	}
	
	@Test 
	/**
	 * Test setting of changes via using task name 
	 */
	public void testChangesByName() {
		//by task name
		assertEquals("Command: UPDATE_BY_NAME_CHANGE_NAME\nmeeting, \n"
				+ "new TaskName: urgent meeting\n",
				parser.parseInput("set meeting \"urgent meeting\"").toString());
		assertEquals("Command: UPDATE_BY_NAME_CHANGE_DATE\nmeeting, FLOATING, \n",
				parser.parseInput("set meeting [none]").toString());
		assertEquals("Command: ERROR\nerror type: Error: Wrong format for new task name/date\n",
				parser.parseInput("set meeting []").toString());
		assertEquals("Command: UPDATE_BY_NAME_CHANGE_DATE\nmeeting, DEADLINE, "
				+ "due on 17 Feb 2016\n",
				parser.parseInput("set meeting [17 feb]").toString());
		assertEquals("Command: UPDATE_BY_NAME_CHANGE_DATE\nmeeting, EVENT, "
				+ "from 16 Feb 2016 to 17 Feb 2016\n",
				parser.parseInput("set meeting [16 feb, 17 Feb]").toString());
		assertEquals("Command: UPDATE_BY_NAME_CHANGE_DATE\nmeeting, EVENT, "
				+ "from 16 Feb 2016 to 17 Feb 2016\n",
				parser.parseInput("set meeting [16 feb,17 Feb]").toString());	
	}
	
	@Test
	/**
	 * Test the setting of new time 
	 */
	public void testChangesTimeUsage() { 
		//test time usage
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_DATE\nDEADLINE, due on 16 "
				+ "Feb 2016 15:00\nat index: 1\n",
				parser.parseInput("set 2 [16 feb 3pm]").toString());
		
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_DATE\nEVENT, from 16 Feb 2016"
				+ " 15:00 to 19 Feb 2016 17:00\nat index: 1\n",
				parser.parseInput("set 2 [16 feb 3pm,19 feb 5pm]").toString());
	}
	
	@Test 
	/**
	 * Test the parsing of setting both name and task name in 1 command
	 */
	public void testChangesBothNameDate() { 
		//test combination
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_BOTH\nDEADLINE, due on 16 "
				+ "Feb 2016\nat index: 1\nnew TaskName: newName\n",
				parser.parseInput("set 2 [16 Feb] \"newName\"").toString());
		
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_BOTH\nFLOATING, \nat index: 0\n"
				+ "new TaskName: newName\n",
				parser.parseInput("set 1 \"newName\" [none]").toString());
		
		assertEquals("Command: UPDATE_BY_NAME_CHANGE_BOTH\nmeeting, DEADLINE, "
				+ "due on 19 Feb 2016\nnew TaskName: newName\n",
				parser.parseInput("set meeting \"newName\" [19 feb]").toString());
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_BOTH\nEVENT, from 14 Mar "
				+ "2016 to 15 Mar 2016\nat index: 0\nnew TaskName: task 2\n",
				parser.parseInput("set 1 [14 mar,15 mar] \"task 2\"").toString());
	}
	
	@Test
	/**
	 * Test the changing of task priorities 
	 */
	public void testChangesTaskPriority() {
		//test boundary case 
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_PRIORITY\nat index: 0\n"
				+ "newPriority: 3\n",
				parser.parseInput("set 1 !!!").toString()); 
		//test out of bound case 
		assertEquals("Command: ERROR\nerror type: Error: Invalid task priority entered\n",
				parser.parseInput("set 1 !!!!").toString());
		//test working case 
		assertEquals("Command: UPDATE_BY_NAME_CHANGE_PRIORITY\ndo homework, \n"
				+ "newPriority: 2\n",
				parser.parseInput("set do homework !!").toString());
		//test boundary case 
		assertEquals("Command: UPDATE_BY_INDEX_CHANGE_PRIORITY\nat index: 1\n"
				+ "newPriority: 1\n",
				parser.parseInput("set 2 !").toString()); 
		//test no task name given 
		assertEquals("Command: ERROR\nerror type: Error: Task name/index is not given\n",
				parser.parseInput("set !").toString()); 
		//test no priority given
		assertEquals("Command: ERROR\nerror type: Error: Wrong format for new "
				+ "task name/date\n",
				parser.parseInput("set 2").toString()); 
	}
	
	@Test
	/**
	 * Test: Changing an task to an invalid event date (ie. startTime >= endTime) 
	 */
	public void testChangesInvalidEvent() {
		assertEquals("Command: ERROR\nerror type: Error: Event starting time cannot be"
				+ " later than the ending time\n",
				parser.parseInput("set 1 [19 feb 5pm, 19 feb 3pm]").toString());
		assertEquals("Command: ERROR\nerror type: Error: Event starting time cannot be"
				+ " later than the ending time\n",
				parser.parseInput("set 1 [21 feb, 20 feb]").toString());
		assertEquals("Command: ERROR\nerror type: Error: Event starting time cannot be"
				+ " later than the ending time\n",
				parser.parseInput("set 1 [tmr, 19 feb 3pm]").toString());
	}
	
	@Test 
	/**
	 * Test that trying to do empty changes returns error 
	 */
	public void testChangesEmptyError() {
		assertEquals("Command: ERROR\nerror type: Error: Cannot be an empty change\n",
				parser.parseInput("set ").toString());
	}
	
	@Test
	/**
	 * Tests that the delete by index and by task name parses correctly
	 * Also tests that it parses a category to be deleted correctly. 
	 */
	public void testDelete() {
		assertEquals("Command: DELETE_BY_INDEX\nat index: 4\n",
				parser.parseInput("del 5").toString());
		assertEquals("Command: DELETE_BY_NAME\nhello world, \n",
				parser.parseInput("del hello world").toString());
		assertEquals("Command: DELETE_BY_CATEGORY\ncategory: hello\n",
				parser.parseInput("del #hello").toString());
	}
	
	@Test
	/**
	 * Test that the search feature parses correctly 
	 */
	public void testSearch() {
		assertEquals("Command: SEARCH\nsearch phrase: hello world\n",
				parser.parseInput("search hello world").toString());
	}
	
	@Test
	/**
	 * Test that done parses correctly by both index and task name 
	 */
	public void testDone() {
		assertEquals("Command: DONE_BY_INDEX\nat index: 4\n",
				parser.parseInput("done 5").toString());
		assertEquals("Command: DONE_BY_NAME\nhello world, \n",
				parser.parseInput("done hello world").toString());
			
	}
	
	@Test
	/**
	 * Test that the undo feature parses correctly
	 */
	public void testUndo() {
		assertEquals("Command: UNDO\n",parser.parseInput("undo").toString());	
	}
	
	
	@Test 
	/**
	 * Test that the basic view types are all working correctly 
	 */
	public void testView() {
		assertEquals("Command: VIEW_BASIC\nview type: all, \n",
				parser.parseInput("view all").toString());
		assertEquals("Command: VIEW_BASIC\nview type: general, \n",
				parser.parseInput("View general").toString());
		assertEquals("Command: VIEW_BASIC\nview type: deadlines, \n",
				parser.parseInput("vieW deadlines").toString());
		assertEquals("Command: VIEW_BASIC\nview type: events, \n",
				parser.parseInput("view Events").toString());
		assertEquals("Command: VIEW_BASIC\nview type: archive, \n",
				parser.parseInput("view archive").toString());
		
	}
	
	@Test 
	/**
	 * Test the viewing of tasks by tag categories 
	 */
	public void testViewTags() {
		assertEquals("Command: VIEW_TAGS\nview type: work, \n",
				parser.parseInput("view #work").toString());
		assertEquals("Command: VIEW_TAGS\nview type: work, homework, yolo, \n",
				parser.parseInput("view #work #homework #yolo").toString());
	}
	
	@Test
	/**
	 * Test the error parsing of viewing tasks by tag categories
	 */
	public void testViewTagsError() {
		assertEquals("Command: ERROR\nerror type: Error: \"lala\" is not a valid tag\n",
				parser.parseInput("view lala #yolo").toString());
		assertEquals("Command: ERROR\nerror type: Error: \"lala\" is not a valid tag\n",
				parser.parseInput("view #yolo lala #boo").toString());
	}
	
	@Test
	/**
	 * Test the parsing of the change Directory Command
	 */
	public void testChangeDir() {
		assertEquals("Command: CHANGE_FILE_LOC\nnewLocation: C:/Desktop\n",
				parser.parseInput("setdir C:/Desktop").toString());
	}
	
	@Test
	/**
	 * Test the parsing of the clear command
	 */
	public void testClear() {
		assertEquals("Command: CLEAR\n",
				parser.parseInput("clear").toString());
	}
	
	@Test
	/**
	 * Test the parsing of the save command 
	 */
	public void testSave() {
		assertEquals("Command: SAVE\n",
				parser.parseInput("save").toString());
	}
	
	@Test
	/**
	 * Test parsing of invalid command
	 */
	public void testNoSuchCommand() {
		assertEquals("Command: ERROR\nerror type: Error: \"write\" is not a valid command\n",
				parser.parseInput("write oo").toString());
	}
	
	@Test
	/**
	 * Test parsing of empty search
	 */
	public void testSearchEmpty() {
		assertEquals("Command: ERROR\nerror type: Error: No search phrase entered\n",
				parser.parseInput("search ").toString());
	}
	
	@Test
	/**
	 * Test parsing of empty done
	 */
	public void testDoneEmpty() {
		assertEquals("Command: ERROR\nerror type: Error: No task has been selected as done\n",
				parser.parseInput("done ").toString());
	}
	
	@Test
	/**
	 * Test parsing of empty delete
	 */
	public void testDeleteEmpty() {
		assertEquals("Command: ERROR\nerror type: Error: No task has been selected for deletion\n",
				parser.parseInput("del ").toString());
		assertEquals("Command: ERROR\nerror type: Error: Cannot delete an empty category!\n",
				parser.parseInput("del #").toString());
	}
	
	@Test 
	/**
	 * Test parsing of empty views and
	 * parsing of incorrect category
	 */
	public void testViewIncorrect() {
		assertEquals("Command: ERROR\nerror type: Error: No view type selected\n",
				parser.parseInput("view ").toString());
		assertEquals("Command: ERROR\nerror type: Error: \"wonder\" is not a valid category\n",
				parser.parseInput("view wonder").toString());
	}
	
	/* 
	public void testDate() {
		PrettyTimeParser p  = new PrettyTimeParser(); 
		System.out.println(p.parse("today 3pm"));
		System.out.println(p.parse("tomorrow 3pm"));
		System.out.println(parser.parseInput("set 1 [today 3pm, tmr 3pm]"));
	} */ 
	
	
	/*
	 * All the methods below will be manually tested because 
	 * dates like "tomorrow" and "today" are relative, and the time/date will
	 * change every time the the unit test is run 
	 */
	
	@Test
	/**
	 * Tests that the methods return the correct dates for human defined events 
	 */
	public void testEventsHuman() {
		System.out.println("TestEventsHuman");
		
		System.out.println(parser.parseInput("add meeting from today to 8 Apr"));
		System.out.println(parser.parseInput("add meeting from tomorrow to 8 Apr 2017"));
		System.out.println(parser.parseInput("add meeting from tmr to 8 Apr 2017"));
		System.out.println(parser.parseInput("add meeting from tmr to next wed"));
	}
	
	@Test
	/**
	 * Test human date edits
	 */
	public void testChangesHuman() {
		System.out.println("TestChangesHuman");
		
		System.out.println(parser.parseInput("set 2 [tomorrow 5pm]"));
		System.out.println(parser.parseInput("set 2 [wed 5pm, thu 7pm]"));
	}
	
	@Test 
	/**
	 * Test human deadlines
	 */
	public void testDeadlineHuman() { 
		System.out.println("TestDeadlineHuman");
		
		System.out.println(parser.parseInput("add do homework by tonight")); 
		System.out.println(parser.parseInput("add complete essay by today")); 
		System.out.println(parser.parseInput("add complete essay by tmr")); 
		System.out.println(parser.parseInput("add complete essay by this Wed"));
		System.out.println(parser.parseInput("add complete essay by next Wed"));
		System.out.println(parser.parseInput("add sdasda by mon")); 
		System.out.println(parser.parseInput("add asdsad on sat")); 
		System.out.println(parser.parseInput("add sdasad by sat")); 
	}
	
	@Test
	/**
	 * Test an event that contains 1 time and 1 no time
	 */
	public void testEventsWeirdTimes() {
		System.out.println(parser.parseInput("add event from 12pm to tmr"));
	}
}
```
###### test\junit\PatternMatcherTest.java
``` java
 * JUnit testing class for DateTimePatternMatcher
 * Type of test: Unit Test  
 * @author Xue Hui
 *
 */
public class PatternMatcherTest {
	DateTimePatternMatcher pm = new DateTimePatternMatcher(); 
	
	@Test
	/**
	 * Test that the hasPattern method returns true for dates
	 * that match its format 
	 */
	public void testPatternSet1() {
		
		String string1 = "add project meeting by 3 pm on 17 feb";
		String string2 = "add project meeting on 19 feb from 4pm to 5pm";
		String string3 = "add do homework at 3pm by tomorrow";
		
		assertTrue(pm.hasPattern(string1));
		assertTrue(pm.hasPattern(string2));
		assertTrue(pm.hasPattern(string3));
	}
	
	@Test 
	/**
	 * Test the TimeEdit method
	 */
	public void testPatternSet2() {
		String string4 = "add do homework by 23:00h";
		String string5 = "add do homework by tonight"; 
		
		assertTrue(pm.hasTimeEdit(string4));
		assertTrue(pm.hasTimeEdit(string5));	
	}
	
	@Test 
	/**
	 * Test that correct inputs return false
	 */
	public void testPatternSet3() {
		String string6 = "add do project meeting by 17 feb 3pm";
		assertFalse(pm.hasPattern(string6));
	}
	
	@Test
	/**
	 * Test that time format checkers for autocomplete
	 * works correctly 
	 */
	public void testAutoCompleteTime() {
		assertTrue(pm.hasAmPm("3pm"));
		assertFalse(pm.hasAmPm("feb"));
		
		assertTrue(pm.hasCorrectTimeFormat("3:29 pm")); 
		assertTrue(pm.hasTimeAC("3:30 p"));
		assertTrue(pm.hasTimeAC("08:30 h"));
	}
	
	@Test
	/**
	 * Test date format checkers for autocomplete works correctly
	 */
	public void testAutoCompleteDates() {
		assertTrue(pm.hasDateAC("23"));
		assertFalse(pm.hasDateAC("45")); 
		assertFalse(pm.hasDateAC("23 aug")); 
		
		assertTrue(pm.hasFullDateAC("23 aug")); 
		assertTrue(pm.hasFullDateAC("23")); 
		assertTrue(pm.hasFullDateAC("this friday")); 
		assertFalse(pm.hasFullDateAC("balh balh")); 
	}

}
```
###### test\junit\TimeConverterTest.java
``` java
 *  Tests the TimeConverter class
 *  Type of test: Unit Test 
 *  @author: Xue Hui 
 **/
public class TimeConverterTest {
	private TimeConverter tc = new TimeConverter();
	
	@Test
	/**
	 * Test basic methods for TimeConverter 
	 */
	public void testEpoch() {
		tc.setCurrTime();
		
		try {
			//System.out.println(timeConverter.toHumanTime(1455692400));
			//System.out.println("Current Time in Epoch: " + timeConverter.getCurrTime()); 
			assertEquals(1455123600,tc.toEpochTime("11 Feb 2016 01:00:00"));
			
			assertFalse(tc.isSameDay(tc.getCurrTime(),
					tc.toEpochTime("11 Feb 2016 23:00:00")));
			
			assertEquals(1455206399,tc.toEpochTime("11 Feb 2016"));
			assertEquals(1455206399,tc.toEpochTime("11 Feb"));
			assertEquals(1454342399,tc.toEpochTime("1 Feb 2016"));
			assertEquals(1454342399,tc.toEpochTime("1 Feb"));
			assertEquals("01 Feb 2016 23:59",tc.toHumanTime(1454342399));			
			
		} catch (ParseException e) {
			
		}
		assertEquals("11 Feb 2016 01:00",tc.toHumanTime(1455123600)); 
	}
	
	@Test
	/**
	 * Test isSameWeek and isSameDay 
	 */
	public void testWeekDay() {
		try { 
			
		long time1 = tc.toEpochTime("31 Mar");
		long time2 = tc.toEpochTime("1 Apr");
		assertTrue(tc.isSameWeek(time1, time2));
		
		} catch (Exception e) {
			
		}
		
		//compare 10Feb 11pm vs 11Feb 1am 
		assertFalse(tc.isSameDay(1455123600,1455116400));
		//compare 11 feb a few minutes later 
		assertTrue(tc.isSameDay(1455123600,1455123800));
		//compare 10Feb 11pm and 11Feb 1am 
		assertTrue(tc.isSameWeek(1455123600,1455116400));
	}
	
	@Test 
	/**
	 * Test that the week starts on sunday and not monday 
	 */
	public void testSameWeek() {
		try {
			long epochTime1 = tc.toEpochTime("27 Mar");
			long epochTime2 = tc.toEpochTime("28 Mar"); 
			//sun and mon are diff days of the week
			assertFalse(tc.isSameWeek(epochTime1, epochTime2));
			epochTime1 = tc.toEpochTime("29 Mar");
			//mon and tues are same days of the week 
			assertTrue(tc.isSameWeek(epochTime1, epochTime2));
		} catch (Exception e) {
			System.out.println(e);
		}
	}
	
	@Test 
	/**
	 * Test isToday and isTmr 
	 */
	public void testTodayTmr() {
		assertFalse(tc.isToday(1455123600));
		assertFalse(tc.isTmr(1455123600));
		
		assertTrue(tc.isToday(tc.getCurrTime()));
		assertTrue(tc.isTmr(tc.getCurrTime()+ ParserConstants.ONE_DAY));
	}
	
	@Test 
	/**
	 * Test that the right time/day of the week is given back 
	 */
	public void testTimeConversion() {
		assertEquals("01:00",tc.getTime(1455123600));
		assertEquals("THU",tc.getDayOfTheWeek(1455123600));
	}
	
	/*
	 * Manual Testing: Test human methods
	 */
	
	@Test
	/**
	 * Test that the correct 3 months are given back
	 */
	public void testHumanFunctions() {
		System.out.println(tc.get3MonthsFromNow());
		System.out.println(tc.getDayOfTheWeek());
	}

}
```
